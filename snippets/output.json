{
    "cumulative_sum": {
        "prefix": "cumulative_sum",
        "body": [
            "template <class _Tp>\n",
            "class CumulativeSum {\n",
            " public:\n",
            "  CumulativeSum(const std::vector<_Tp>& vec) : vec_(vec) { build(); }\n",
            "\n",
            "  // return sum of [l, r]\n",
            "  _Tp get(int l, int r) { return sum_[r + 1] - sum_[l]; }\n",
            "\n",
            "  // return the first k where sum of [0, k] >= value\n",
            "  // use only when all element in vec >= 0\n",
            "  int lower_bound(_Tp value) {\n",
            "    return std::distance(sum_.begin() + 1,\n",
            "                         std::lower_bound(sum_.begin() + 1, sum_.end(), value));\n",
            "  }\n",
            "\n",
            "  // return the first k where sum of [0, k] > value\n",
            "  // use only when all element in vec >= 0\n",
            "  int upper_bound(_Tp value) {\n",
            "    return std::distance(sum_.begin() + 1,\n",
            "                         std::upper_bound(sum_.begin() + 1, sum_.end(), value));\n",
            "  }\n",
            "\n",
            " private:\n",
            "  std::vector<_Tp> vec_;\n",
            "  std::vector<_Tp> sum_;\n",
            "\n",
            "  void build() {\n",
            "    sum_.assign(vec_.size() + 1, static_cast<_Tp>(0));\n",
            "    for (size_t i = 0; i < vec_.size(); ++i) {\n",
            "      sum_[i + 1] = sum_[i] + vec_[i];\n",
            "    }\n",
            "  }\n",
            "};\n"
        ]
    },
    "cumulative_sum_2d": {
        "prefix": "cumulative_sum_2d",
        "body": [
            "template <class _Tp>\n",
            "class CumulativeSum2D {\n",
            " public:\n",
            "  CumulativeSum2D(const std::vector<vector<_Tp>>& vec)\n",
            "      : x_(vec.size()), y_(vec[0].size()), vec_(vec) {\n",
            "    build();\n",
            "  }\n",
            "\n",
            "  // return sum of [sx, gx] * [sy, gy]\n",
            "  _Tp get(int sx, int sy, int gx, int gy) {\n",
            "    assert(sx <= gx && sy <= gy);\n",
            "    assert(0 <= sx && sx < x_ && 0 <= gx && gx < x_ && 0 <= sy && sy < y_ &&\n",
            "           0 <= gy && gy < y_);\n",
            "    return sum_[gx + 1][gy + 1] - sum_[gx + 1][sy] - sum_[sx][gy + 1] +\n",
            "           sum_[sx][sy];\n",
            "  }\n",
            "\n",
            " private:\n",
            "  int x_;\n",
            "  int y_;\n",
            "  std::vector<vector<_Tp>> vec_;\n",
            "  std::vector<vector<_Tp>> sum_;\n",
            "\n",
            "  void build() {\n",
            "    sum_.assign(x_ + 1, vector<_Tp>(y_ + 1, static_cast<_Tp>(0)));\n",
            "    for (int i = 0; i < x_; ++i) {\n",
            "      for (int j = 0; j < y_; ++j) {\n",
            "        sum_[i + 1][j + 1] = sum_[i + 1][j] + vec_[i][j];\n",
            "      }\n",
            "    }\n",
            "    for (int i = 0; i < y_; ++i) {\n",
            "      for (int j = 0; j < x_; ++j) {\n",
            "        sum_[j + 1][i + 1] += sum_[j][i + 1];\n",
            "      }\n",
            "    }\n",
            "  }\n",
            "};\n"
        ]
    },
    "doubling": {
        "prefix": "doubling",
        "body": [
            "class Doubling {\n",
            " public:\n",
            "  Doubling(int n, int64 k) : n_(n), lg_(64 - __builtin_clzll(k)) {\n",
            "    table.assign(lg_, std::vector<int>(n_, -1));\n",
            "  }\n",
            "\n",
            "  void set(int pos, int value) { table[0][pos] = value; }\n",
            "\n",
            "  void build() {\n",
            "    for (int i = 0; i + 1 < lg_; ++i) {\n",
            "      for (int j = 0; j < (int)table[i].size(); ++j) {\n",
            "        table[i + 1][j] = (table[i][j] == -1 ? -1 : table[i][table[i][j]]);\n",
            "      }\n",
            "    }\n",
            "  }\n",
            "\n",
            "  int query(int pos, int64 k) {\n",
            "    for (int i = lg_ - 1; i >= 0; --i) {\n",
            "      if (k & (1LL << i)) {\n",
            "        pos = table[i][pos];\n",
            "      }\n",
            "    }\n",
            "    return pos;\n",
            "  }\n",
            "\n",
            " private:\n",
            "  int n_;\n",
            "  int lg_;\n",
            "  std::vector<std::vector<int>> table;\n",
            "};\n"
        ]
    },
    "fenwick_tree": {
        "prefix": "fenwick_tree",
        "body": [
            "template <class _Tp>\n",
            "class FenwickTree {\n",
            " public:\n",
            "  FenwickTree(const std::vector<_Tp>& data) : n_(data.size() + 1), data_(data) {\n",
            "    initialize();\n",
            "  }\n",
            "\n",
            "  void add(int pos, _Tp value) {\n",
            "    ++pos;\n",
            "    while (pos < n_) {\n",
            "      node_[pos] += value;\n",
            "      pos += pos & -pos;\n",
            "    }\n",
            "  }\n",
            "\n",
            "  // return sum of [0, i]\n",
            "  _Tp get(int pos) {\n",
            "    ++pos;\n",
            "    _Tp sum = 0;\n",
            "    while (pos > 0) {\n",
            "      sum += node_[pos];\n",
            "      pos -= pos & -pos;\n",
            "    }\n",
            "    return sum;\n",
            "  }\n",
            "\n",
            "  // return sum of [l, rihgt]\n",
            "  _Tp get(int l, int r) { return get(r) - get(l - 1); }\n",
            "\n",
            "  // return the first k where sum of [0, k] >= value\n",
            "  // use only when all element in data >= 0\n",
            "  int lower_bound(_Tp value) {\n",
            "    if (value <= 0) return 0;\n",
            "    int pos = 0;\n",
            "    int k = 1;\n",
            "    while (k < n_ - 1) k <<= 1;\n",
            "    while (k > 0) {\n",
            "      if (pos + k <= n_ - 1 && node_[pos + k] < value) {\n",
            "        value -= node_[pos + k];\n",
            "        pos += k;\n",
            "      }\n",
            "      k >>= 1;\n",
            "    }\n",
            "    return pos;\n",
            "  }\n",
            "\n",
            "  // for range add query\n",
            "  class RAQ {\n",
            "   public:\n",
            "    RAQ(const std::vector<_Tp>& data)\n",
            "        : n_(data.size()),\n",
            "          ft1_(FenwickTree<_Tp>(data)),\n",
            "          ft2_(FenwickTree<_Tp>(data)) {}\n",
            "\n",
            "    // add value range [l, r)\n",
            "    void add(int l, int r, _Tp value) {\n",
            "      add(ft1_, l, r, value);\n",
            "      add(ft2_, l, r, -value * static_cast<_Tp>(l - 1));\n",
            "      add(ft2_, r, n_, value * static_cast<_Tp>(r - l));\n",
            "    }\n",
            "\n",
            "    // get sum of [0, i]\n",
            "    _Tp get(int pos) {\n",
            "      return ft1_.get(pos) * static_cast<_Tp>(pos) + ft2_.get(pos);\n",
            "    }\n",
            "\n",
            "    // get sum of [l, r]\n",
            "    _Tp get(int l, int r) { return get(r) - get(l - 1); }\n",
            "\n",
            "   private:\n",
            "    int n_;\n",
            "    FenwickTree<_Tp> ft1_;\n",
            "    FenwickTree<_Tp> ft2_;\n",
            "    void add(FenwickTree<_Tp>& ft, int l, int r, _Tp value) {\n",
            "      ft.add(l, value);\n",
            "      ft.add(r, -value);\n",
            "    }\n",
            "  };\n",
            "\n",
            " private:\n",
            "  int n_;\n",
            "  std::vector<_Tp> data_;\n",
            "  std::vector<_Tp> node_;\n",
            "  void initialize() {\n",
            "    node_.assign(n_ + 1, 0);\n",
            "    for (int i = 0; i < n_ - 1; ++i) add(i, data_[i]);\n",
            "  }\n",
            "};\n"
        ]
    },
    "segment_tree": {
        "prefix": "segment_tree",
        "body": [
            "template <class Monoid, class Function>\n",
            "class SegmentTree {\n",
            " public:\n",
            "  SegmentTree(const std::vector<Monoid>& data, Monoid identity_element,\n",
            "              Function function)\n",
            "      : identity_element_(identity_element), data_(data), function_(function) {\n",
            "    build();\n",
            "  }\n",
            "\n",
            "  void update(int pos, Monoid new_value) {\n",
            "    assert(0 <= pos && pos < n_);\n",
            "    pos += n_;\n",
            "    node_[pos] = new_value;\n",
            "    while (pos > 0) {\n",
            "      pos >>= 1;\n",
            "      node_[pos] = function_(node_[2 * pos], node_[2 * pos + 1]);\n",
            "    }\n",
            "  }\n",
            "\n",
            "  // return function_[l, r)\n",
            "  Monoid query(int l, int r) {\n",
            "    assert(0 <= l && l < n_ && 0 <= r - 1 && r - 1 < n_);\n",
            "    Monoid vl = identity_element_, vr = identity_element_;\n",
            "    for (l += n_, r += n_; l < r; l >>= 1, r >>= 1) {\n",
            "      if (l & 1) vl = function_(vl, node_[l++]);\n",
            "      if (r & 1) vr = function_(node_[--r], vr);\n",
            "    }\n",
            "    return function_(vl, vr);\n",
            "  }\n",
            "\n",
            "  Monoid operator[](int pos) const {\n",
            "    assert(0 <= pos && pos < n_);\n",
            "    return node_[n_ + pos];\n",
            "  }\n",
            "\n",
            " private:\n",
            "  int n_;\n",
            "  Monoid identity_element_;\n",
            "  std::vector<Monoid> data_;\n",
            "  std::vector<Monoid> node_;\n",
            "  Function function_;\n",
            "\n",
            "  void build() {\n",
            "    int SIZE = data_.size();\n",
            "    n_ = 1;\n",
            "    while (n_ < SIZE) {\n",
            "      n_ <<= 1;\n",
            "    }\n",
            "    node_.assign(2 * n_, identity_element_);\n",
            "    for (int i = 0; i < SIZE; ++i) {\n",
            "      node_[i + n_] = data_[i];\n",
            "    }\n",
            "    for (int i = n_ - 1; i > 0; --i) {\n",
            "      node_[i] = function_(node_[2 * i], node_[2 * i + 1]);\n",
            "    }\n",
            "  }\n",
            "};\n"
        ]
    },
    "unionfind_rank": {
        "prefix": "unionfind_rank",
        "body": [
            "class UnionFind {\n",
            " public:\n",
            "  UnionFind(int n) : n_(n) { initialize(); }\n",
            "\n",
            "  int root(int x) {\n",
            "    assert(0 <= x && x < n_);\n",
            "    if (par_[x] == -1)\n",
            "      return x;\n",
            "    else\n",
            "      return par_[x] = root(par_[x]);\n",
            "  }\n",
            "\n",
            "  bool same(int x, int y) {\n",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);\n",
            "    return root(x) == root(y);\n",
            "  }\n",
            "\n",
            "  void unite(int x, int y) {\n",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);\n",
            "    x = root(x);\n",
            "    y = root(y);\n",
            "    if (x == y) return;\n",
            "    if (rank_[x] < rank_[y]) std::swap(x, y);\n",
            "    if (rank_[x] == rank_[y]) ++rank_[x];\n",
            "    par_[y] = x;\n",
            "    return;\n",
            "  }\n",
            "\n",
            " private:\n",
            "  const int n_;\n",
            "  std::vector<int> par_;\n",
            "  std::vector<int> rank_;\n",
            "\n",
            "  void initialize() {\n",
            "    par_.assign(n_, -1);\n",
            "    rank_.assign(n_, 0);\n",
            "  }\n",
            "};\n"
        ]
    },
    "unionfind_size": {
        "prefix": "unionfind_size",
        "body": [
            "class UnionFind {\n",
            " public:\n",
            "  UnionFind(int n) : n_(n) { initialize(); }\n",
            "\n",
            "  int root(int x) {\n",
            "    assert(0 <= x && x < n_);\n",
            "    if (par_[x] < 0)\n",
            "      return x;\n",
            "    else\n",
            "      return par_[x] = root(par_[x]);\n",
            "  }\n",
            "\n",
            "  bool same(int x, int y) {\n",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);\n",
            "    return root(x) == root(y);\n",
            "  }\n",
            "\n",
            "  void unite(int x, int y) {\n",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);\n",
            "    x = root(x);\n",
            "    y = root(y);\n",
            "    if (x == y) return;\n",
            "    if (par_[x] > par_[y]) std::swap(x, y);\n",
            "    par_[x] += par_[y];\n",
            "    par_[y] = x;\n",
            "    return;\n",
            "  }\n",
            "\n",
            "  int size(int x) {\n",
            "    assert(0 <= x && x < n_);\n",
            "    return -par_[root(x)];\n",
            "  }\n",
            "\n",
            " private:\n",
            "  const int n_;\n",
            "  std::vector<int> par_;\n",
            "\n",
            "  void initialize() { par_.assign(n_, -1); }\n",
            "};\n"
        ]
    },
    "fast_input": {
        "prefix": "fast_input",
        "body": [
            "template<class T> void fastin(T &num) {\n",
            "  bool negative = false;\n",
            "  T c;\n",
            "  num = 0;\n",
            "  c = getchar_unlocked();\n",
            "  if (c == '-') {\n",
            "    negative = true;\n",
            "    c = getchar_unlocked();\n",
            "  }\n",
            "  for (; (c > 47 && c < 58); c = getchar_unlocked()) num = (num << 3) + (num << 1) + c - 48;\n",
            "  if (negative) num *= -1;\n",
            "}\n"
        ]
    },
    "modint": {
        "prefix": "modint",
        "body": [
            "template <typename T>\n",
            "class Modular {\n",
            " public:\n",
            "  using Type = typename decay<decltype(T::value)>::type;\n",
            "\n",
            "  constexpr Modular() : value() {}\n",
            "  template <typename U>\n",
            "  Modular(const U& x) {\n",
            "    value = normalize(x);\n",
            "  }\n",
            "\n",
            "  template <typename U>\n",
            "  static Type normalize(const U& x) {\n",
            "    Type v;\n",
            "    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\n",
            "    else v = static_cast<Type>(x % mod());\n",
            "    if (v < 0) v += mod();\n",
            "    return v;\n",
            "  }\n",
            "\n",
            "  const Type& operator()() const { return value; }\n",
            "  template <typename U>\n",
            "  explicit operator U() const { return static_cast<U>(value); }\n",
            "  constexpr static Type mod() { return T::value; }\n",
            "\n",
            "  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\n",
            "  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\n",
            "  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\n",
            "  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\n",
            "  Modular& operator++() { return *this += 1; }\n",
            "  Modular& operator--() { return *this -= 1; }\n",
            "  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\n",
            "  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\n",
            "  Modular operator-() const { return Modular(-value); }\n",
            "\n",
            "  template <typename U = T>\n",
            "  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\n",
            "  #ifdef _WIN32\n",
            "    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\n",
            "    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\n",
            "    asm(\n",
            "      \"divl %4; \\n\\t\"\n",
            "      : \"=a\" (d), \"=d\" (m)\n",
            "      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\n",
            "    );\n",
            "    value = m;\n",
            "  #else\n",
            "    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\n",
            "  #endif\n",
            "    return *this;\n",
            "  }\n",
            "  template <typename U = T>\n",
            "  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\n",
            "    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\n",
            "    value = normalize(value * rhs.value - q * mod());\n",
            "    return *this;\n",
            "  }\n",
            "  template <typename U = T>\n",
            "  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\n",
            "    value = normalize(value * rhs.value);\n",
            "    return *this;\n",
            "  }\n",
            "\n",
            "  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\n",
            "\n",
            "  template <typename U>\n",
            "  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\n",
            "\n",
            "  template <typename U>\n",
            "  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\n",
            "\n",
            "  template <typename U>\n",
            "  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\n",
            "\n",
            "  template <typename U>\n",
            "  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\n",
            "\n",
            " private:\n",
            "  Type value;\n",
            "};\n",
            "\n",
            "template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\n",
            "template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\n",
            "template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\n",
            "\n",
            "template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n",
            "template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\n",
            "template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\n",
            "\n",
            "template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\n",
            "\n",
            "template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n",
            "template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\n",
            "template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\n",
            "\n",
            "template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n",
            "template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\n",
            "template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\n",
            "\n",
            "template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n",
            "template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\n",
            "template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\n",
            "\n",
            "template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n",
            "template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\n",
            "template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\n",
            "\n",
            "template<typename T, typename U>\n",
            "Modular<T> power(const Modular<T>& a, const U& b) {\n",
            "  assert(b >= 0);\n",
            "  Modular<T> x = a, res = 1;\n",
            "  U p = b;\n",
            "  while (p > 0) {\n",
            "    if (p & 1) res *= x;\n",
            "    x *= x;\n",
            "    p >>= 1;\n",
            "  }\n",
            "  return res;\n",
            "}\n",
            "\n",
            "template <typename T>\n",
            "bool IsZero(const Modular<T>& number) {\n",
            "  return number() == 0;\n",
            "}\n",
            " \n",
            "template <typename T>\n",
            "std::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\n",
            "  return stream << number();\n",
            "}\n",
            "\n",
            "template <typename T>\n",
            "std::istream& operator>>(std::istream& stream, Modular<T>& number) {\n",
            "  typename common_type<typename Modular<T>::Type, int64_t>::type x;\n",
            "  stream >> x;\n",
            "  number.value = Modular<T>::normalize(x);\n",
            "  return stream;\n",
            "}\n",
            "\n",
            "/*\n",
            "using ModType = int;\n",
            "\n",
            "struct VarMod { static ModType value; };\n",
            "ModType VarMod::value;\n",
            "ModType& MOD = VarMod::value;\n",
            "using Mint = Modular<VarMod>;\n",
            "*/\n",
            "\n",
            "constexpr int MOD = (int) 1e9 + 7;\n",
            "using Mint = Modular<std::integral_constant<std::decay<decltype(MOD)>::type, MOD>>;\n"
        ]
    },
    "pbds_tree": {
        "prefix": "pbds_tree",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>\n",
            "#include <ext/pb_ds/tree_policy.hpp>\n",
            "#include <ext/pb_ds/tag_and_trait.hpp>\n",
            "\n",
            "template<class T> \n",
            "using pbds_tree = __gnu_pbds::tree<T, __gnu_pbds::null_type, std::less<T>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\n"
        ]
    },
    "template": {
        "prefix": "template",
        "body": [
            "#pragma region kyomukyomupurin\n",
            "\n",
            "/**\n",
            " *    author  : \ud835\udc8c\ud835\udc9a\ud835\udc90\ud835\udc8e\ud835\udc96\ud835\udc8c\ud835\udc9a\ud835\udc90\ud835\udc8e\ud835\udc96\ud835\udc91\ud835\udc96\ud835\udc93\ud835\udc8a\ud835\udc8f\n",
            " *    created : $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND\n",
            " **/\n",
            "\n",
            "#include <algorithm>\n",
            "#include <bitset>\n",
            "#include <cassert>\n",
            "#include <cctype>\n",
            "#include <chrono>\n",
            "#include <cmath>\n",
            "#include <complex>\n",
            "#include <deque>\n",
            "#include <iomanip>\n",
            "#include <iostream>\n",
            "#include <map>\n",
            "#include <numeric>\n",
            "#include <queue>\n",
            "#include <random>\n",
            "#include <set>\n",
            "#include <stack>\n",
            "#include <string>\n",
            "#include <tuple>\n",
            "#include <utility>\n",
            "#include <vector>\n",
            "\n",
            "using namespace std;\n",
            "\n",
            "using int64 = long long;\n",
            "\n",
            "template <class T>\n",
            "using binary_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\n",
            "\n",
            "template <class T, class U>\n",
            "std::ostream& operator<<(std::ostream& os, const std::pair<T, U>& p) {\n",
            "  return os << '(' << p.first << \", \" << p.second << ')';\n",
            "}\n",
            "\n",
            "template <class Ch, class Tr, class Tuple, std::size_t... Is>\n",
            "void tuple_out(std::basic_ostream<Ch, Tr>& os, const Tuple& tp, std::index_sequence<Is...>) {\n",
            "  ((os << (Is ? \", \" : \"(\") << std::get<Is>(tp)), ...) << \")\";\n",
            "}\n",
            "\n",
            "template <class Ch, class Tr, class... Args>\n",
            "auto& operator<<(std::basic_ostream<Ch, Tr>& os, const std::tuple<Args...>& tp) {\n",
            "  tuple_out(os, tp, std::index_sequence_for<Args...>{});\n",
            "  return os;\n",
            "}\n",
            "\n",
            "template <class T>\n",
            "std::ostream& operator<<(std::ostream& os, const std::vector<T>& vec) {\n",
            "  int n = 0;\n",
            "  for (auto e : vec) os << (n++ ? \", \" : \"{\") << e;\n",
            "  return os << (n ? \"}\" : \"{}\");\n",
            "}\n",
            "\n",
            "template <class T, class Compare>\n",
            "std::ostream& operator<<(std::ostream& os, const std::set<T, Compare>& st) {\n",
            "  int n = 0;\n",
            "  for (auto e : st) os << (n++ ? \", \" : \"{\") << e;\n",
            "  return os << (n ? \"}\" : \"{}\");\n",
            "}\n",
            "\n",
            "template <class T, class U, class Compare>\n",
            "std::ostream& operator<<(std::ostream& os, const std::map<T, U, Compare>& mp) {\n",
            "  int n = 0;\n",
            "  for (auto e : mp) os << (n++ ? \", \" : \"{\") << e;\n",
            "  return os << (n ? \"}\" : \"{}\");\n",
            "}\n",
            "\n",
            "template <class T>\n",
            "std::istream& operator>>(std::istream& is, std::vector<T>& vec) {\n",
            "  for (T& e : vec) is >> e;\n",
            "  return is;\n",
            "}\n",
            "\n",
            "#define all(_) begin(_), end(_)\n",
            "#define rall(_) rbegin(_), rend(_)\n",
            "\n",
            "#ifdef LOCAL\n",
            "#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]: \", debug_out(__VA_ARGS__)\n",
            "#else\n",
            "#define debug(...)\n",
            "#endif\n",
            "\n",
            "void debug_out() { std::cerr << '\\n'; }\n",
            "\n",
            "template <class Head, class... Tail>\n",
            "void debug_out(Head&& head, Tail&&... tail) {\n",
            "  std::cerr << head;\n",
            "  if (sizeof...(Tail) != 0) std::cerr << \", \";\n",
            "  debug_out(std::forward<Tail>(tail)...);\n",
            "}\n",
            "\n",
            "#pragma endregion kyomukyomupurin\n",
            "\n",
            "int main() {\n",
            "  ios_base::sync_with_stdio(false);\n",
            "  cin.tie(nullptr);\n",
            "\n",
            "\n",
            "  return 0;\n",
            "}\n"
        ]
    },
    "timer": {
        "prefix": "timer",
        "body": [
            "class Timer {\n",
            " public:\n",
            "  // (second)\n",
            "  double GetElapsedTime() {\n",
            "    return static_cast<double>(GetCycle() - start_) /\n",
            "           static_cast<double>(clock_frequency_);\n",
            "  }\n",
            "\n",
            "  void Start() { start_ = GetCycle(); }\n",
            "\n",
            " private:\n",
            "  int64_t start_;\n",
            "  static constexpr int64_t clock_frequency_ = 2800000000;\n",
            "\n",
            "  int64_t GetCycle() {\n",
            "    uint32_t low, high;\n",
            "    __asm__ volatile(\"rdtsc\" : \"=a\"(low), \"=d\"(high));\n",
            "    return (static_cast<int64_t>(low)) | (static_cast<int64_t>(high) << 32);\n",
            "  }\n",
            "};\n"
        ]
    },
    "xorshift": {
        "prefix": "xorshift",
        "body": [
            "class Xorshift {\n",
            " public:\n",
            "  Xorshift() {\n",
            "    seed0_ = static_cast<uint64_t>(\n",
            "        std::chrono::steady_clock::now().time_since_epoch().count());\n",
            "    seed1_ = static_cast<uint64_t>(\n",
            "        std::chrono::steady_clock::now().time_since_epoch().count());\n",
            "    for (int i = 0; i < 100; ++i) {\n",
            "      GetNext();\n",
            "    }\n",
            "  }\n",
            "  using result_type = uint64_t;\n",
            "  static constexpr uint64_t min() {\n",
            "    return std::numeric_limits<result_type>::min();\n",
            "  }\n",
            "  static constexpr uint64_t max() {\n",
            "    return std::numeric_limits<result_type>::max();\n",
            "  }\n",
            "\n",
            "  uint64_t operator()() { return GetNext(); }\n",
            "\n",
            " private:\n",
            "  uint64_t result_;\n",
            "  uint64_t seed0_;\n",
            "  uint64_t seed1_;\n",
            "\n",
            "  uint64_t GetNext() {\n",
            "    uint64_t s1 = seed0_;\n",
            "    uint64_t s0 = seed1_;\n",
            "    result_ = s0 + s1;\n",
            "    seed0_ = s0;\n",
            "    s1 ^= s1 << 23;\n",
            "    seed1_ = s1 ^ s0 ^ (s1 >> 18) ^ (s0 >> 5);\n",
            "    return result_;\n",
            "  }\n",
            "};\n"
        ]
    },
    "bellman_ford": {
        "prefix": "bellman_ford",
        "body": [
            "template <class _Tp>\n",
            "class BellmanFord {\n",
            " public:\n",
            "  static constexpr _Tp kInfinity =\n",
            "      std::numeric_limits<_Tp>::max() / static_cast<_Tp>(2);\n",
            "\n",
            "  BellmanFord(int node_size) : node_size_(node_size) { initialize(); }\n",
            "\n",
            "  void add(int from, int to, _Tp cost) {\n",
            "    assert(0 <= from && from < node_size_ && 0 <= to && to < node_size_);\n",
            "    es_.emplace_back((edge){from, to, cost});\n",
            "  }\n",
            "\n",
            "  // use after bf.solve(source)\n",
            "  bool find_negative_cycle() const {\n",
            "    for (const edge& e : es_) {\n",
            "      if (distance_[e.from] == kInfinity) continue;\n",
            "      if (distance_[e.from] + e.cost < distance_[e.to]) return true;\n",
            "    }\n",
            "    return false;\n",
            "  }\n",
            "\n",
            "  void solve(int source) {\n",
            "    assert(0 <= source && source < node_size_);\n",
            "    distance_[source] = 0;\n",
            "    for (int i = 0; i < node_size_ - 1; ++i) {\n",
            "      for (const edge& e : es_) {\n",
            "        if (distance_[e.from] == kInfinity) continue;\n",
            "        if (distance_[e.to] > distance_[e.from] + e.cost) {\n",
            "          distance_[e.to] = distance_[e.from] + e.cost;\n",
            "        }\n",
            "      }\n",
            "    }\n",
            "  }\n",
            "\n",
            "  _Tp operator[](int to) const {\n",
            "    assert(0 <= to && to < node_size_);\n",
            "    return distance_[to];\n",
            "  }\n",
            "\n",
            " private:\n",
            "  struct edge {\n",
            "    int from, to;\n",
            "    _Tp cost;\n",
            "  };\n",
            "  int node_size_;\n",
            "  std::vector<_Tp> distance_;\n",
            "  std::vector<edge> es_;\n",
            "\n",
            "  void initialize() { distance_.assign(node_size_, kInfinity); }\n",
            "};\n"
        ]
    },
    "dijkstra": {
        "prefix": "dijkstra",
        "body": [
            "template <class _Tp>\n",
            "class Dijkstra {\n",
            "  template <class _Up>\n",
            "  using binary_heap = std::priority_queue<_Up, std::vector<_Up>, std::greater<_Up>>;\n",
            "\n",
            " public:\n",
            "  static constexpr _Tp kInfinity = std::numeric_limits<_Tp>::max() / static_cast<_Tp>(2);\n",
            "\n",
            "  Dijkstra(int node_size) : node_size_(node_size), graph_(node_size) {}\n",
            "\n",
            "  void add(int from, int to, _Tp cost) {\n",
            "    assert(0 <= from && from < node_size_ && 0 <= to && to < node_size_);\n",
            "    graph_[from].emplace_back((edge){to, cost});\n",
            "  }\n",
            "\n",
            "  void solve(int source) {\n",
            "    assert(0 <= source && source < node_size_);\n",
            "    distance_.assign(node_size_, kInfinity);\n",
            "    binary_heap<std::pair<_Tp, int>> pq;\n",
            "    distance_[source] = 0;\n",
            "    pq.emplace(0, source);\n",
            "\n",
            "    while (!pq.empty()) {\n",
            "      std::pair<_Tp, int> cur = pq.top();\n",
            "      pq.pop();\n",
            "      int v = cur.second;\n",
            "      if (distance_[v] < cur.first) continue;\n",
            "      for (const edge& e : graph_[v]) {\n",
            "        if (distance_[e.to] > distance_[v] + e.cost) {\n",
            "          distance_[e.to] = distance_[v] + e.cost;\n",
            "          pq.emplace(distance_[e.to], e.to);\n",
            "        }\n",
            "      }\n",
            "    }\n",
            "  }\n",
            "\n",
            "  _Tp operator[](int to) const {\n",
            "    assert(0 <= to && to < node_size_);\n",
            "    return distance_[to];\n",
            "  }\n",
            "\n",
            " private:\n",
            "  struct edge {\n",
            "    int to;\n",
            "    _Tp cost;\n",
            "  };\n",
            "  int node_size_;\n",
            "  std::vector<_Tp> distance_;\n",
            "  std::vector<std::vector<edge>> graph_;\n",
            "};\n"
        ]
    },
    "dinic": {
        "prefix": "dinic",
        "body": [
            "template <class _Tp>\n",
            "class Dinic {\n",
            " public:\n",
            "  Dinic(int node_size) : node_size_(node_size) { initialize(); }\n",
            "\n",
            "  void add(int from, int to, _Tp cost) {\n",
            "    assert(0 <= from && from < node_size_ && 0 <= to && to < node_size_);\n",
            "    graph_[from].emplace_back(\n",
            "        (edge){to, cost, static_cast<int>(graph_[to].size())});\n",
            "    graph_[to].emplace_back((edge){from, static_cast<_Tp>(0),\n",
            "                                   static_cast<int>(graph_[from].size()) - 1});\n",
            "  }\n",
            "\n",
            "  _Tp max_flow(int s, int t) {\n",
            "    _Tp flow = 0;\n",
            "    for (;;) {\n",
            "      bfs(s);\n",
            "      if (level_[t] < 0) return flow;\n",
            "      std::fill(iter_.begin(), iter_.end(), 0);\n",
            "      _Tp f;\n",
            "      while ((f = dfs(s, t,\n",
            "                      std::numeric_limits<_Tp>::max() / static_cast<_Tp>(2))) >\n",
            "             0) {\n",
            "        flow += f;\n",
            "      }\n",
            "    }\n",
            "  }\n",
            "\n",
            " private:\n",
            "  struct edge {\n",
            "    int to;\n",
            "    _Tp cap;\n",
            "    int rev;\n",
            "  };\n",
            "  int node_size_;\n",
            "  std::vector<std::vector<edge>> graph_;\n",
            "  std::vector<int> level_;\n",
            "  std::vector<int> iter_;\n",
            "\n",
            "  void initialize() {\n",
            "    graph_.resize(node_size_);\n",
            "    level_.assign(node_size_, 0);\n",
            "    iter_.assign(node_size_, 0);\n",
            "  }\n",
            "\n",
            "  void bfs(int s) {\n",
            "    std::fill(level_.begin(), level_.end(), -1);\n",
            "    std::queue<int> que;\n",
            "    level_[s] = 0;\n",
            "    que.emplace(s);\n",
            "    while (!que.empty()) {\n",
            "      int cur = que.front();\n",
            "      que.pop();\n",
            "      for (const edge& next : graph_[cur]) {\n",
            "        if (next.cap > 0 && level_[next.to] < 0) {\n",
            "          level_[next.to] = level_[cur] + 1;\n",
            "          que.emplace(next.to);\n",
            "        }\n",
            "      }\n",
            "    }\n",
            "  }\n",
            "\n",
            "  _Tp dfs(int v, int t, int f) {\n",
            "    if (v == t) return f;\n",
            "    for (int& i = iter_[v]; i < (int)graph_[v].size(); ++i) {\n",
            "      edge& e = graph_[v][i];\n",
            "      if (e.cap > 0 && level_[v] < level_[e.to]) {\n",
            "        _Tp d = dfs(e.to, t, min(f, e.cap));\n",
            "        if (d > 0) {\n",
            "          e.cap -= d;\n",
            "          graph_[e.to][e.rev].cap += d;\n",
            "          return d;\n",
            "        }\n",
            "      }\n",
            "    }\n",
            "    return 0;\n",
            "  }\n",
            "};\n"
        ]
    },
    "lca": {
        "prefix": "lca",
        "body": [
            "class LCA {\n",
            " public:\n",
            "  LCA(int node_size, int root = 0)\n",
            "      : node_size_(node_size),\n",
            "        log_node_(32 - __builtin_clz(node_size_)),\n",
            "        root_(root) {\n",
            "    initialize();\n",
            "  }\n",
            "\n",
            "  void add(int u, int v) {\n",
            "    assert(0 <= u && u < node_size_ && 0 <= v && v < node_size_);\n",
            "    graph_[u].emplace_back(v);\n",
            "    graph_[v].emplace_back(u);\n",
            "  }\n",
            "\n",
            "  void build() {\n",
            "    dfs(root_, -1, 0);\n",
            "    for (int i = 0; i + 1 < log_node_; ++i) {\n",
            "      for (int j = 0; j < node_size_; ++j) {\n",
            "        if (par_[i][j] < 0) {\n",
            "          par_[i + 1][j] = -1;\n",
            "        } else {\n",
            "          par_[i + 1][j] = par_[i][par_[i][j]];\n",
            "        }\n",
            "      }\n",
            "    }\n",
            "  }\n",
            "\n",
            "  // use after build()\n",
            "  int lca(int u, int v) {\n",
            "    assert(0 <= u && u < node_size_ && 0 <= v && v < node_size_);\n",
            "    if (depth_[u] > depth_[v]) std::swap(u, v);\n",
            "    for (int i = 0; i < log_node_; ++i) {\n",
            "      if ((depth_[v] - depth_[u]) >> i & 1) {\n",
            "        v = par_[i][v];\n",
            "      }\n",
            "    }\n",
            "    if (u == v) return u;\n",
            "    for (int i = log_node_ - 1; i >= 0; --i) {\n",
            "      if (par_[i][u] != par_[i][v]) {\n",
            "        u = par_[i][u];\n",
            "        v = par_[i][v];\n",
            "      }\n",
            "    }\n",
            "    return par_[0][u];\n",
            "  }\n",
            "\n",
            "  int dist(int u, int v) {\n",
            "    assert(0 <= u && u < node_size_ && 0 <= v && v < node_size_);\n",
            "    return depth_[u] + depth_[v] - 2 * depth_[lca(u, v)];\n",
            "  }\n",
            "\n",
            " private:\n",
            "  int node_size_;\n",
            "  int log_node_;\n",
            "  int root_;\n",
            "  std::vector<std::vector<int>> graph_;\n",
            "  std::vector<std::vector<int>> par_;\n",
            "  std::vector<int> depth_;\n",
            "\n",
            "  void dfs(int cur, int prev, int d) {\n",
            "    par_[0][cur] = prev;\n",
            "    depth_[cur] = d;\n",
            "    for (const int& next : graph_[cur]) {\n",
            "      if (next == prev) continue;\n",
            "      dfs(next, cur, d + 1);\n",
            "    }\n",
            "  }\n",
            "\n",
            "  void initialize() {\n",
            "    depth_.resize(node_size_);\n",
            "    graph_.resize(node_size_);\n",
            "    par_.assign(log_node_, std::vector<int>(node_size_, -1));\n",
            "  }\n",
            "};\n"
        ]
    },
    "spfa": {
        "prefix": "spfa",
        "body": [
            "template <class _Tp>\n",
            "class SPFA {\n",
            " public:\n",
            "  static constexpr _Tp kInfinity =\n",
            "      std::numeric_limits<_Tp>::max() / static_cast<_Tp>(2);\n",
            "\n",
            "  SPFA(int node_size) : node_size_(node_size) { initialize(); }\n",
            "\n",
            "  void add(int from, int to, _Tp cost) {\n",
            "    assert(0 <= from && from < node_size_ && 0 <= to && to < node_size_);\n",
            "    graph_[from].emplace_back((edge){to, cost});\n",
            "  }\n",
            "\n",
            "  // use after solve()\n",
            "  bool find_negative_cycle() const noexcept { return distance_.empty(); }\n",
            "\n",
            "  void solve(int source) {\n",
            "    assert(0 <= source && source < node_size_);\n",
            "    std::queue<int> que;\n",
            "    que.emplace(source);\n",
            "    pending_[source] = true;\n",
            "    ++times_[source];\n",
            "    distance_[source] = 0;\n",
            "    while (!que.empty()) {\n",
            "      int cur = que.front();\n",
            "      que.pop();\n",
            "      pending_[cur] = false;\n",
            "      for (const auto& next : graph_[cur]) {\n",
            "        _Tp next_cost = distance_[cur] + next.cost;\n",
            "        if (next_cost >= distance_[next.to]) continue;\n",
            "        distance_[next.to] = next_cost;\n",
            "        if (!pending_[next.to]) {\n",
            "          if (++times_[next.to] >= node_size_) {\n",
            "            distance_.clear();\n",
            "            return;\n",
            "          }\n",
            "          pending_[next.to] = true;\n",
            "          que.emplace(next.to);\n",
            "        }\n",
            "      }\n",
            "    }\n",
            "    return;\n",
            "  }\n",
            "\n",
            "  _Tp operator[](int to) const {\n",
            "    assert(0 <= to && to < node_size_);\n",
            "    return distance_[to];\n",
            "  }\n",
            "\n",
            " private:\n",
            "  struct edge {\n",
            "    int to;\n",
            "    _Tp cost;\n",
            "  };\n",
            "  int node_size_;\n",
            "  std::vector<std::vector<edge>> graph_;\n",
            "  std::vector<_Tp> distance_;\n",
            "  std::vector<int> pending_;\n",
            "  std::vector<int> times_;\n",
            "\n",
            "  void initialize() {\n",
            "    graph_.resize(node_size_);\n",
            "    distance_.assign(node_size_,\n",
            "                     std::numeric_limits<_Tp>::max() / static_cast<_Tp>(2));\n",
            "    pending_.assign(node_size_, 0);\n",
            "    times_.assign(node_size_, 0);\n",
            "  }\n",
            "};\n"
        ]
    },
    "topological_sort": {
        "prefix": "topological_sort",
        "body": [
            "class TopologicalSort {\n",
            " public:\n",
            "  TopologicalSort(int node_size) : node_size_(node_size) { Initialize(); }\n",
            "\n",
            "  void AddEdge(int from, int to) {\n",
            "    graph_[from].emplace_back(to);\n",
            "    ++level_[to];\n",
            "  }\n",
            "\n",
            "  void Sort() {\n",
            "    std::queue<int> que;\n",
            "    for (int i = 0; i < node_size_; ++i) {\n",
            "      if (level_[i] == 0) que.push(i);\n",
            "    }\n",
            "    while (!que.empty()) {\n",
            "      int top = que.front();\n",
            "      que.pop();\n",
            "      result_.emplace_back(top);\n",
            "      for (int next : graph_[top]) {\n",
            "        if (--level_[next] == 0) que.push(next);\n",
            "      }\n",
            "    }\n",
            "  }\n",
            "\n",
            "  // use after Sort()!\n",
            "  bool IsDAG() {\n",
            "    return all_of(level_.begin(), level_.end(), [](int x) { return x == 0; });\n",
            "  }\n",
            "\n",
            "  int operator[](int position) const { return result_[position]; }\n",
            "\n",
            " private:\n",
            "  int node_size_;\n",
            "  std::vector<std::vector<int>> graph_;\n",
            "  std::vector<int> level_;\n",
            "  std::vector<int> result_;\n",
            "\n",
            "  void Initialize() {\n",
            "    graph_.resize(node_size_);\n",
            "    level_.assign(node_size_, 0);\n",
            "  }\n",
            "};\n"
        ]
    },
    "tree_diameter": {
        "prefix": "tree_diameter",
        "body": [
            "template <class _Tp>\n",
            "class TreeDiameter {\n",
            " public:\n",
            "  TreeDiameter(int node_size) : node_size_(node_size), graph_(node_size_) {}\n",
            "\n",
            "  void add(int from, int to, _Tp cost) {\n",
            "    assert(0 <= from && from < node_size_ && 0 <= to && to < node_size_);\n",
            "    graph_[from].emplace_back((edge){cost, to});\n",
            "    graph_[to].emplace_back((edge){cost, from});\n",
            "  }\n",
            "\n",
            "  _Tp get() { return bfs(bfs(0).second).first; }\n",
            "\n",
            " private:\n",
            "  struct edge {\n",
            "    _Tp cost;\n",
            "    int to;\n",
            "  };\n",
            "  int node_size_;\n",
            "  std::vector<std::vector<edge>> graph_;\n",
            "\n",
            "  std::pair<_Tp, int> bfs(int source) {\n",
            "    std::pair<_Tp, int> result = {static_cast<_Tp>(0), 0};\n",
            "    std::queue<int> que;\n",
            "    bool visited[node_size_] = {};\n",
            "    vector<_Tp> dist(node_size_, 0);\n",
            "    visited[source] = true;\n",
            "    que.emplace(source);\n",
            "    while (!que.empty()) {\n",
            "      int cur = que.front();\n",
            "      que.pop();\n",
            "      for (const auto& next : graph_[cur]) {\n",
            "        if (visited[next.to]) continue;\n",
            "        visited[next.to] = true;\n",
            "        dist[next.to] += dist[cur] + next.cost;\n",
            "        que.emplace(next.to);\n",
            "        result = std::max(result, {dist[next.to], next.to});\n",
            "      }\n",
            "    }\n",
            "    return result;\n",
            "  }\n",
            "};\n"
        ]
    },
    "combination": {
        "prefix": "combination",
        "body": [
            "class Combination {\n",
            " public:\n",
            "  static constexpr int mod_ = 1000000007;\n",
            "  static constexpr int n_ = 2000000 + 5;\n",
            "\n",
            "  Combination() { build(); }\n",
            "\n",
            "  std::array<int64, n_> fact_;\n",
            "  std::array<int64, n_> inv_;\n",
            "  std::array<int64, n_> finv_;\n",
            "\n",
            "  // return nCk\n",
            "  int64 get(int n, int k) const noexcept {\n",
            "    if (n < k || n < 0 || k < 0) return 0;\n",
            "    return fact_[n] * (finv_[k] * finv_[n - k] % mod_) % mod_;\n",
            "  }\n",
            "\n",
            " private:\n",
            "  void build() noexcept {\n",
            "    fact_[0] = 1;\n",
            "    fact_[1] = 1;\n",
            "    finv_[0] = 1;\n",
            "    finv_[1] = 1;\n",
            "    inv_[1] = 1;\n",
            "    for (int i = 2; i < n_; ++i) {\n",
            "      fact_[i] = fact_[i - 1] * i % mod_;\n",
            "      inv_[i] = mod_ - inv_[mod_ % i] * (mod_ / i) % mod_;\n",
            "      finv_[i] = finv_[i - 1] * inv_[i] % mod_;\n",
            "    }\n",
            "  }\n",
            "};\n"
        ]
    },
    "divisor": {
        "prefix": "divisor",
        "body": [
            "template<class _Tp> std::vector<_Tp> divisor(_Tp n) {\n",
            "  std::vector<_Tp> res;\n",
            "  for (_Tp i = 1; i * i <= n; ++i) {\n",
            "    if (n % i == 0){\n",
            "      res.emplace_back(i);\n",
            "      if (i * i != n){\n",
            "        res.emplace_back(n / i);\n",
            "      }\n",
            "    }\n",
            "  }\n",
            "  std::sort(res.begin(), res.end());\n",
            "\n",
            "  return res;\n",
            "}\n"
        ]
    },
    "fast_gcd": {
        "prefix": "fast_gcd",
        "body": [
            "unsigned long long fast_gcd(unsigned long long x, unsigned long long y) {\n",
            "  int shift;\n",
            "  if (x == 0) return y;\n",
            "  if (y == 0) return x;\n",
            "  shift = __builtin_ctzll(x | y);\n",
            "  x >>= __builtin_ctzll(x);\n",
            "  do {\n",
            "    y >>= __builtin_ctzll(y);\n",
            "    if (x > y) std::swap(x, y);\n",
            "    y -= x;\n",
            "  } while (y);\n",
            "  return x << shift;\n",
            "}\n"
        ]
    },
    "miller_rabin": {
        "prefix": "miller_rabin",
        "body": [
            "class MillerRabinTest {\n",
            "  using uint64 = uint64_t;\n",
            "  using uint128 = __uint128_t;\n",
            "\n",
            " public:\n",
            "  MillerRabinTest() {}\n",
            "\n",
            "  bool isprime(uint64 n) {\n",
            "    if (n < 2) return false;\n",
            "    int r = 0;\n",
            "    uint64 d = n - 1;\n",
            "    while ((d & 1) == 0) {\n",
            "      d >>= 1;\n",
            "      r++;\n",
            "    }\n",
            "\n",
            "    for (int a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {\n",
            "      if (n == (uint64)a) return true;\n",
            "      if (check(n, a, d, r)) return false;\n",
            "    }\n",
            "    return true;\n",
            "  }\n",
            "\n",
            " private:\n",
            "  uint64 power(uint64 base, uint64 e, uint64 mod) {\n",
            "    uint64 res = 1;\n",
            "    base %= mod;\n",
            "    while (e) {\n",
            "      if (e & 1) res = (uint128)res * base % mod;\n",
            "      base = (uint128)base * base % mod;\n",
            "      e >>= 1;\n",
            "    }\n",
            "    return res;\n",
            "  }\n",
            "\n",
            "  bool check(uint64 n, uint64 a, uint64 d, int s) {\n",
            "    uint64 x = power(a, d, n);\n",
            "    if (x == 1 || x == n - 1) return false;\n",
            "    for (int r = 1; r < s; r++) {\n",
            "      x = (uint128)x * x % n;\n",
            "      if (x == n - 1) return false;\n",
            "    }\n",
            "    return true;\n",
            "  };\n",
            "};\n"
        ]
    },
    "mod_pow": {
        "prefix": "mod_pow",
        "body": [
            "template<class T, class U> T mod_pow(T x, U n, T mod) {\n",
            "  T res = 1;\n",
            "  while (n > 0) {\n",
            "    if (n & 1) (res *= x) %= mod;\n",
            "    (x *= x) %= mod;\n",
            "    n >>= 1;\n",
            "  }\n",
            "  return res;\n",
            "}\n"
        ]
    },
    "prime_factorization": {
        "prefix": "prime_factorization",
        "body": [
            "template<class _Tp>\n",
            "std::map<_Tp, int> prime_fact(_Tp n){\n",
            "  std::map<_Tp, int> result;\n",
            "  for (_Tp i = 2; i * i <= n; ++i){\n",
            "    if (n % i != 0) continue;\n",
            "    int cnt = 0;\n",
            "    while (n % i == 0){\n",
            "      n /= i; ++cnt;\n",
            "    }\n",
            "    result[i] = cnt;\n",
            "  }\n",
            "  if (n != 1) result[n] = 1;\n",
            "  return result;\n",
            "}\n"
        ]
    },
    "totient": {
        "prefix": "totient",
        "body": [
            "template <class _Tp>\n",
            "_Tp Totient(_Tp n) {\n",
            "  _Tp res = n;\n",
            "  for (_Tp i = 2; i * i <= n; ++i) {\n",
            "    if (n % i != 0) continue;\n",
            "    (res /= i) *= (i - 1);\n",
            "    while (n % i == 0) n /= i;\n",
            "  }\n",
            "  if (n != 1) (res /= n) *= (n - 1);\n",
            "  return res;\n",
            "}\n"
        ]
    },
    "levenshtein_distance": {
        "prefix": "levenshtein_distance",
        "body": [
            "int Levenshtein_distance(const std::string& s1, const std::string& s2) {\n",
            "  int n1 = s1.size(), n2 = s2.size();\n",
            "  std::vector<std::vector<int>> dp(n1 + 1, std::vector<int>(n2 + 1, 0));\n",
            "  for (int i = 0; i <= n1; ++i) dp[i][0] = i;\n",
            "  for (int i = 0; i <= n2; ++i) dp[0][i] = i;\n",
            "  for (int i = 0; i < n1; ++i) {\n",
            "    for (int j = 0; j < n2; ++j) {\n",
            "      const int cost = (s1[i] != s2[j]);\n",
            "      dp[i + 1][j + 1] =\n",
            "          std::min({dp[i + 1][j] + 1, dp[i][j + 1] + 1, dp[i][j] + cost});\n",
            "    }\n",
            "  }\n",
            "  return dp[n1][n2];\n",
            "}\n",
            "// snippet-end"
        ]
    },
    "manacher": {
        "prefix": "manacher",
        "body": [
            "std::vector<int> Manacher(const std::string& s) {\n",
            "  int n = s.size();\n",
            "  std::vector<int> res(n);\n",
            "  int i = 0, j = 0;\n",
            "  while (i < n) {\n",
            "    while (i - j >= 0 && i + j < n && s[i - j] == s[i + j]) ++j;\n",
            "    res[i] = j;\n",
            "    int k = 1;\n",
            "    while (i - k >= 0 && k + res[i - k] < j) res[i + k] = res[i - k], ++k;\n",
            "    i += k;\n",
            "    j -= k;\n",
            "  }\n",
            "  return res;\n",
            "}\n"
        ]
    },
    "rolling_hash": {
        "prefix": "rolling_hash",
        "body": [
            "using ull = unsigned long long;\n",
            "\n",
            "class RollingHash {\n",
            " public:\n",
            "  RollingHash(const std::string& s) : s_(s) { build(); }\n",
            "\n",
            "  // get hash value of [l, r)\n",
            "  std::pair<ull, ull> get(int l, int r) {\n",
            "    ull ret0 = (hash0_[r] - hash0_[l] * pow0_[r - l] % mod0_ + mod0_) % mod0_;\n",
            "    ull ret1 = (hash1_[r] - hash1_[l] * pow1_[r - l] % mod1_ + mod1_) % mod1_;\n",
            "    return {ret0, ret1};\n",
            "  }\n",
            "\n",
            " private:\n",
            "  const std::string s_;\n",
            "  static ull base0_;\n",
            "  static ull base1_;\n",
            "  static constexpr ull mod0_ = 2020202077;\n",
            "  static constexpr ull mod1_ = 2020202111;\n",
            "  std::vector<ull> hash0_;\n",
            "  std::vector<ull> hash1_;\n",
            "  static std::vector<ull> pow0_;\n",
            "  static std::vector<ull> pow1_;\n",
            "  static std::mt19937_64 mt_;\n",
            "\n",
            "  void build() {\n",
            "    int n = s_.size();\n",
            "    hash0_.assign(n + 1, 0);\n",
            "    hash1_.assign(n + 1, 0);\n",
            "    for (int i = 0; i < n; ++i) {\n",
            "      hash0_[i + 1] = (hash0_[i] * base0_ + s_[i]) % mod0_;\n",
            "      hash1_[i + 1] = (hash1_[i] * base1_ + s_[i]) % mod1_;\n",
            "    }\n",
            "    for (int i = 0; i < n; ++i) {\n",
            "      pow0_.emplace_back(pow0_.back() * base0_ % mod0_);\n",
            "      pow1_.emplace_back(pow1_.back() * base1_ % mod1_);\n",
            "    }\n",
            "  }\n",
            "};\n",
            "\n",
            "std::mt19937_64 RollingHash::mt_(\n",
            "    std::chrono::steady_clock::now().time_since_epoch().count());\n",
            "ull RollingHash::base0_ = std::uniform_int_distribution<ull>(\n",
            "    2, RollingHash::mod0_ - 1)(RollingHash::mt_);\n",
            "ull RollingHash::base1_ = std::uniform_int_distribution<ull>(\n",
            "    2, RollingHash::mod1_ - 1)(RollingHash::mt_);\n",
            "std::vector<ull> RollingHash::pow0_{1};\n",
            "std::vector<ull> RollingHash::pow1_{1};\n"
        ]
    },
    "z_algorithm": {
        "prefix": "z_algorithm",
        "body": [
            "std::vector<int> Zalgorithm(const std::string s) {\n",
            "  int n = s.size();\n",
            "  std::vector<int> res(n);\n",
            "  res[0] = n;\n",
            "  int i = 1, j = 0;\n",
            "  while (i < n) {\n",
            "    while (i + j < n && s[j] == s[i + j]) ++j;\n",
            "    res[i] = j;\n",
            "    if (j == 0) {\n",
            "      ++i;\n",
            "      continue;\n",
            "    }\n",
            "    int k = 1;\n",
            "    while (i + k < n && k + res[k] < j) res[i + k] = res[k], ++k;\n",
            "    i += k;\n",
            "    j -= k;\n",
            "  }\n",
            "  return res;\n",
            "};\n"
        ]
    }
}