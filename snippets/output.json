{
    "cumulative_sum": {
        "prefix": "cumulative_sum",
        "body": [
            "template <class _Tp>\r",
            "class CumulativeSum {\r",
            " public:\r",
            "  CumulativeSum(const std::vector<_Tp>& vec) : vec_(vec) { build(); }\r",
            "\r",
            "  // return sum of [l, r]\r",
            "  _Tp get(int l, int r) { return sum_[r + 1] - sum_[l]; }\r",
            "\r",
            "  // return the first k where sum of [0, k] >= value\r",
            "  // use only when all element in vec >= 0\r",
            "  int lower_bound(_Tp value) {\r",
            "    return std::distance(sum_.begin() + 1,\r",
            "                         std::lower_bound(sum_.begin() + 1, sum_.end(), value));\r",
            "  }\r",
            "\r",
            "  // return the first k where sum of [0, k] > value\r",
            "  // use only when all element in vec >= 0\r",
            "  int upper_bound(_Tp value) {\r",
            "    return std::distance(sum_.begin() + 1,\r",
            "                         std::upper_bound(sum_.begin() + 1, sum_.end(), value));\r",
            "  }\r",
            "\r",
            " private:\r",
            "  std::vector<_Tp> vec_;\r",
            "  std::vector<_Tp> sum_;\r",
            "\r",
            "  void build() {\r",
            "    sum_.assign(vec_.size() + 1, static_cast<_Tp>(0));\r",
            "    for (size_t i = 0; i < vec_.size(); ++i) {\r",
            "      sum_[i + 1] = sum_[i] + vec_[i];\r",
            "    }\r",
            "  }\r",
            "};\r"
        ]
    },
    "cumulative_sum_2d": {
        "prefix": "cumulative_sum_2d",
        "body": [
            "template <class _Tp>\r",
            "class CumulativeSum2D {\r",
            " public:\r",
            "  CumulativeSum2D(const std::vector<vector<_Tp>>& vec)\r",
            "      : x_(vec.size()), y_(vec[0].size()), vec_(vec) {\r",
            "    build();\r",
            "  }\r",
            "\r",
            "  // return sum of [sx, gx] * [sy, gy]\r",
            "  _Tp get(int sx, int sy, int gx, int gy) {\r",
            "    assert(sx <= gx && sy <= gy);\r",
            "    assert(0 <= sx && sx < x_ && 0 <= gx && gx < x_ && 0 <= sy && sy < y_ &&\r",
            "           0 <= gy && gy < y_);\r",
            "    return sum_[gx + 1][gy + 1] - sum_[gx + 1][sy] - sum_[sx][gy + 1] +\r",
            "           sum_[sx][sy];\r",
            "  }\r",
            "\r",
            " private:\r",
            "  int x_;\r",
            "  int y_;\r",
            "  std::vector<vector<_Tp>> vec_;\r",
            "  std::vector<vector<_Tp>> sum_;\r",
            "\r",
            "  void build() {\r",
            "    sum_.assign(x_ + 1, vector<_Tp>(y_ + 1, static_cast<_Tp>(0)));\r",
            "    for (int i = 0; i < x_; ++i) {\r",
            "      for (int j = 0; j < y_; ++j) {\r",
            "        sum_[i + 1][j + 1] = sum_[i + 1][j] + vec_[i][j];\r",
            "      }\r",
            "    }\r",
            "    for (int i = 0; i < y_; ++i) {\r",
            "      for (int j = 0; j < x_; ++j) {\r",
            "        sum_[j + 1][i + 1] += sum_[j][i + 1];\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "};\r"
        ]
    },
    "doubling": {
        "prefix": "doubling",
        "body": [
            "class Doubling {\r",
            " public:\r",
            "  Doubling(int n, int64 k) : n_(n), lg_(64 - __builtin_clzll(k)) {\r",
            "    table.assign(lg_, std::vector<int>(n_, -1));\r",
            "  }\r",
            "\r",
            "  void set(int pos, int value) { table[0][pos] = value; }\r",
            "\r",
            "  void build() {\r",
            "    for (int i = 0; i + 1 < lg_; ++i) {\r",
            "      for (int j = 0; j < (int)table[i].size(); ++j) {\r",
            "        table[i + 1][j] = (table[i][j] == -1 ? -1 : table[i][table[i][j]]);\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "\r",
            "  int query(int pos, int64 k) {\r",
            "    for (int i = lg_ - 1; i >= 0; --i) {\r",
            "      if (k & (1LL << i)) {\r",
            "        pos = table[i][pos];\r",
            "      }\r",
            "    }\r",
            "    return pos;\r",
            "  }\r",
            "\r",
            " private:\r",
            "  int n_;\r",
            "  int lg_;\r",
            "  std::vector<std::vector<int>> table;\r",
            "};\r"
        ]
    },
    "fenwick_tree": {
        "prefix": "fenwick_tree",
        "body": [
            "template <class _Tp>\r",
            "class FenwickTree {\r",
            " public:\r",
            "  FenwickTree(const std::vector<_Tp>& data) : n_(data.size() + 1), data_(data) {\r",
            "    initialize();\r",
            "  }\r",
            "\r",
            "  void add(int pos, _Tp value) {\r",
            "    ++pos;\r",
            "    while (pos < n_) {\r",
            "      node_[pos] += value;\r",
            "      pos += pos & -pos;\r",
            "    }\r",
            "  }\r",
            "\r",
            "  // return sum of [0, i]\r",
            "  _Tp get(int pos) {\r",
            "    ++pos;\r",
            "    _Tp sum = 0;\r",
            "    while (pos > 0) {\r",
            "      sum += node_[pos];\r",
            "      pos -= pos & -pos;\r",
            "    }\r",
            "    return sum;\r",
            "  }\r",
            "\r",
            "  // return sum of [l, rihgt]\r",
            "  _Tp get(int l, int r) { return get(r) - get(l - 1); }\r",
            "\r",
            "  // return the first k where sum of [0, k] >= value\r",
            "  // use only when all element in data >= 0\r",
            "  int lower_bound(_Tp value) {\r",
            "    if (value <= 0) return 0;\r",
            "    int pos = 0;\r",
            "    int k = 1;\r",
            "    while (k < n_ - 1) k <<= 1;\r",
            "    while (k > 0) {\r",
            "      if (pos + k <= n_ - 1 && node_[pos + k] < value) {\r",
            "        value -= node_[pos + k];\r",
            "        pos += k;\r",
            "      }\r",
            "      k >>= 1;\r",
            "    }\r",
            "    return pos;\r",
            "  }\r",
            "\r",
            "  // for range add query\r",
            "  class RAQ {\r",
            "   public:\r",
            "    RAQ(const std::vector<_Tp>& data)\r",
            "        : n_(data.size()),\r",
            "          ft1_(FenwickTree<_Tp>(data)),\r",
            "          ft2_(FenwickTree<_Tp>(data)) {}\r",
            "\r",
            "    // add value range [l, r)\r",
            "    void add(int l, int r, _Tp value) {\r",
            "      add(ft1_, l, r, value);\r",
            "      add(ft2_, l, r, -value * static_cast<_Tp>(l - 1));\r",
            "      add(ft2_, r, n_, value * static_cast<_Tp>(r - l));\r",
            "    }\r",
            "\r",
            "    // get sum of [0, i]\r",
            "    _Tp get(int pos) {\r",
            "      return ft1_.get(pos) * static_cast<_Tp>(pos) + ft2_.get(pos);\r",
            "    }\r",
            "\r",
            "    // get sum of [l, r]\r",
            "    _Tp get(int l, int r) { return get(r) - get(l - 1); }\r",
            "\r",
            "   private:\r",
            "    int n_;\r",
            "    FenwickTree<_Tp> ft1_;\r",
            "    FenwickTree<_Tp> ft2_;\r",
            "    void add(FenwickTree<_Tp>& ft, int l, int r, _Tp value) {\r",
            "      ft.add(l, value);\r",
            "      ft.add(r, -value);\r",
            "    }\r",
            "  };\r",
            "\r",
            " private:\r",
            "  int n_;\r",
            "  std::vector<_Tp> data_;\r",
            "  std::vector<_Tp> node_;\r",
            "  void initialize() {\r",
            "    node_.assign(n_ + 1, 0);\r",
            "    for (int i = 0; i < n_ - 1; ++i) add(i, data_[i]);\r",
            "  }\r",
            "};\r"
        ]
    },
    "segment_tree": {
        "prefix": "segment_tree",
        "body": [
            "template <class Monoid, class Function>\r",
            "class SegmentTree {\r",
            " public:\r",
            "  SegmentTree(const std::vector<Monoid>& data, Monoid identity_element,\r",
            "              Function function)\r",
            "      : identity_element_(identity_element), data_(data), function_(function) {\r",
            "    build();\r",
            "  }\r",
            "\r",
            "  void update(int pos, Monoid new_value) {\r",
            "    assert(0 <= pos && pos < n_);\r",
            "    pos += n_;\r",
            "    node_[pos] = new_value;\r",
            "    while (pos > 0) {\r",
            "      pos >>= 1;\r",
            "      node_[pos] = function_(node_[2 * pos], node_[2 * pos + 1]);\r",
            "    }\r",
            "  }\r",
            "\r",
            "  // return function_[l, r)\r",
            "  // if l >= r, return identity_element_\r",
            "  Monoid query(int l, int r) {\r",
            "    assert(0 <= l && l < n_ && 0 <= r && r < n_ + 1);\r",
            "    Monoid vl = identity_element_, vr = identity_element_;\r",
            "    for (l += n_, r += n_; l < r; l >>= 1, r >>= 1) {\r",
            "      if (l & 1) vl = function_(vl, node_[l++]);\r",
            "      if (r & 1) vr = function_(node_[--r], vr);\r",
            "    }\r",
            "    return function_(vl, vr);\r",
            "  }\r",
            "\r",
            "  Monoid operator[](int pos) const {\r",
            "    assert(0 <= pos && pos < n_);\r",
            "    return node_[n_ + pos];\r",
            "  }\r",
            "\r",
            " private:\r",
            "  int n_;\r",
            "  Monoid identity_element_;\r",
            "  std::vector<Monoid> data_;\r",
            "  std::vector<Monoid> node_;\r",
            "  Function function_;\r",
            "\r",
            "  void build() {\r",
            "    int SIZE = data_.size();\r",
            "    n_ = 1;\r",
            "    while (n_ < SIZE) {\r",
            "      n_ <<= 1;\r",
            "    }\r",
            "    node_.assign(2 * n_, identity_element_);\r",
            "    for (int i = 0; i < SIZE; ++i) {\r",
            "      node_[i + n_] = data_[i];\r",
            "    }\r",
            "    for (int i = n_ - 1; i > 0; --i) {\r",
            "      node_[i] = function_(node_[2 * i], node_[2 * i + 1]);\r",
            "    }\r",
            "  }\r",
            "};\r"
        ]
    },
    "unionfind_rank": {
        "prefix": "unionfind_rank",
        "body": [
            "class UnionFind {\r",
            " public:\r",
            "  UnionFind(int n) : n_(n) { initialize(); }\r",
            "\r",
            "  int root(int x) {\r",
            "    assert(0 <= x && x < n_);\r",
            "    if (par_[x] == -1)\r",
            "      return x;\r",
            "    else\r",
            "      return par_[x] = root(par_[x]);\r",
            "  }\r",
            "\r",
            "  bool same(int x, int y) {\r",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);\r",
            "    return root(x) == root(y);\r",
            "  }\r",
            "\r",
            "  void unite(int x, int y) {\r",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);\r",
            "    x = root(x);\r",
            "    y = root(y);\r",
            "    if (x == y) return;\r",
            "    if (rank_[x] < rank_[y]) std::swap(x, y);\r",
            "    if (rank_[x] == rank_[y]) ++rank_[x];\r",
            "    par_[y] = x;\r",
            "    return;\r",
            "  }\r",
            "\r",
            " private:\r",
            "  const int n_;\r",
            "  std::vector<int> par_;\r",
            "  std::vector<int> rank_;\r",
            "\r",
            "  void initialize() {\r",
            "    par_.assign(n_, -1);\r",
            "    rank_.assign(n_, 0);\r",
            "  }\r",
            "};\r"
        ]
    },
    "unionfind_size": {
        "prefix": "unionfind_size",
        "body": [
            "class UnionFind {\r",
            " public:\r",
            "  UnionFind(int n) : n_(n) { initialize(); }\r",
            "\r",
            "  int root(int x) {\r",
            "    assert(0 <= x && x < n_);\r",
            "    if (par_[x] < 0)\r",
            "      return x;\r",
            "    else\r",
            "      return par_[x] = root(par_[x]);\r",
            "  }\r",
            "\r",
            "  bool same(int x, int y) {\r",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);\r",
            "    return root(x) == root(y);\r",
            "  }\r",
            "\r",
            "  void unite(int x, int y) {\r",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);\r",
            "    x = root(x);\r",
            "    y = root(y);\r",
            "    if (x == y) return;\r",
            "    if (par_[x] > par_[y]) std::swap(x, y);\r",
            "    par_[x] += par_[y];\r",
            "    par_[y] = x;\r",
            "    return;\r",
            "  }\r",
            "\r",
            "  int size(int x) {\r",
            "    assert(0 <= x && x < n_);\r",
            "    return -par_[root(x)];\r",
            "  }\r",
            "\r",
            " private:\r",
            "  const int n_;\r",
            "  std::vector<int> par_;\r",
            "\r",
            "  void initialize() { par_.assign(n_, -1); }\r",
            "};\r"
        ]
    },
    "unionfind_weighted": {
        "prefix": "unionfind_weighted",
        "body": [
            "class UnionFind {\r",
            " public:\r",
            "  UnionFind(int n, int SUM_UNITY = 0) : n_(n), SUM_UNITY_(SUM_UNITY) {\r",
            "    initialize();\r",
            "  }\r",
            "\r",
            "  int root(int x) {\r",
            "    assert(0 <= x && x < n_);\r",
            "    if (par_[x] == -1) {\r",
            "      return x;\r",
            "    } else {\r",
            "      int r = root(par_[x]);\r",
            "      diff_weight_[x] += diff_weight_[par_[x]];\r",
            "      return par_[x] = r;\r",
            "    }\r",
            "  }\r",
            "\r",
            "  int weight(int x) {\r",
            "    assert(0 <= x && x < n_);\r",
            "    root(x);\r",
            "    return diff_weight_[x];\r",
            "  }\r",
            "\r",
            "  bool same(int x, int y) {\r",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);\r",
            "    return root(x) == root(y);\r",
            "  }\r",
            "\r",
            "  // y is w larger than x\r",
            "  void unite(int x, int y, int w) {\r",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);\r",
            "    w += weight(x);\r",
            "    w -= weight(y);\r",
            "    x = root(x);\r",
            "    y = root(y);\r",
            "    if (x == y) return;\r",
            "    if (rank_[x] < rank_[y]) {\r",
            "      std::swap(x, y);\r",
            "      w = -w;\r",
            "    }\r",
            "    if (rank_[x] == rank_[y]) ++rank_[x];\r",
            "    par_[y] = x;\r",
            "    diff_weight_[y] = w;\r",
            "    return;\r",
            "  }\r",
            "\r",
            "  int diff(int x, int y) {\r",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);\r",
            "    return weight(y) - weight(x);\r",
            "  }\r",
            "\r",
            " private:\r",
            "  const int n_;\r",
            "  const int SUM_UNITY_;\r",
            "  std::vector<int> par_;\r",
            "  std::vector<int> rank_;\r",
            "  std::vector<int> diff_weight_;\r",
            "\r",
            "  void initialize() {\r",
            "    par_.assign(n_, -1);\r",
            "    rank_.assign(n_, 0);\r",
            "    diff_weight_.assign(n_, SUM_UNITY_);\r",
            "  }\r",
            "};\r"
        ]
    },
    "modint": {
        "prefix": "modint",
        "body": [
            "template <typename T>\r",
            "class Modular {\r",
            " public:\r",
            "  using Type = typename decay<decltype(T::value)>::type;\r",
            "\r",
            "  constexpr Modular() : value() {}\r",
            "  template <typename U>\r",
            "  Modular(const U& x) {\r",
            "    value = normalize(x);\r",
            "  }\r",
            "\r",
            "  template <typename U>\r",
            "  static Type normalize(const U& x) {\r",
            "    Type v;\r",
            "    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\r",
            "    else v = static_cast<Type>(x % mod());\r",
            "    if (v < 0) v += mod();\r",
            "    return v;\r",
            "  }\r",
            "\r",
            "  const Type& operator()() const { return value; }\r",
            "  template <typename U>\r",
            "  explicit operator U() const { return static_cast<U>(value); }\r",
            "  constexpr static Type mod() { return T::value; }\r",
            "\r",
            "  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\r",
            "  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\r",
            "  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\r",
            "  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\r",
            "  Modular& operator++() { return *this += 1; }\r",
            "  Modular& operator--() { return *this -= 1; }\r",
            "  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\r",
            "  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\r",
            "  Modular operator-() const { return Modular(-value); }\r",
            "\r",
            "  template <typename U = T>\r",
            "  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\r",
            "  #ifdef _WIN32\r",
            "    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\r",
            "    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\r",
            "    asm(\r",
            "      \"divl %4; \\n\\t\"\r",
            "      : \"=a\" (d), \"=d\" (m)\r",
            "      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\r",
            "    );\r",
            "    value = m;\r",
            "  #else\r",
            "    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\r",
            "  #endif\r",
            "    return *this;\r",
            "  }\r",
            "  template <typename U = T>\r",
            "  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\r",
            "    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\r",
            "    value = normalize(value * rhs.value - q * mod());\r",
            "    return *this;\r",
            "  }\r",
            "  template <typename U = T>\r",
            "  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\r",
            "    value = normalize(value * rhs.value);\r",
            "    return *this;\r",
            "  }\r",
            "\r",
            "  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\r",
            "\r",
            "  template <typename U>\r",
            "  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\r",
            "\r",
            "  template <typename U>\r",
            "  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\r",
            "\r",
            "  template <typename U>\r",
            "  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\r",
            "\r",
            "  template <typename U>\r",
            "  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\r",
            "\r",
            " private:\r",
            "  Type value;\r",
            "};\r",
            "\r",
            "template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\r",
            "template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\r",
            "template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\r",
            "\r",
            "template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\r",
            "template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\r",
            "template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\r",
            "\r",
            "template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\r",
            "\r",
            "template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\r",
            "template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\r",
            "template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\r",
            "\r",
            "template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\r",
            "template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\r",
            "template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\r",
            "\r",
            "template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\r",
            "template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\r",
            "template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\r",
            "\r",
            "template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\r",
            "template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\r",
            "template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\r",
            "\r",
            "template<typename T, typename U>\r",
            "Modular<T> power(const Modular<T>& a, const U& b) {\r",
            "  assert(b >= 0);\r",
            "  Modular<T> x = a, res = 1;\r",
            "  U p = b;\r",
            "  while (p > 0) {\r",
            "    if (p & 1) res *= x;\r",
            "    x *= x;\r",
            "    p >>= 1;\r",
            "  }\r",
            "  return res;\r",
            "}\r",
            "\r",
            "template <typename T>\r",
            "bool IsZero(const Modular<T>& number) {\r",
            "  return number() == 0;\r",
            "}\r",
            " \r",
            "template <typename T>\r",
            "std::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\r",
            "  return stream << number();\r",
            "}\r",
            "\r",
            "template <typename T>\r",
            "std::istream& operator>>(std::istream& stream, Modular<T>& number) {\r",
            "  typename common_type<typename Modular<T>::Type, int64_t>::type x;\r",
            "  stream >> x;\r",
            "  number.value = Modular<T>::normalize(x);\r",
            "  return stream;\r",
            "}\r",
            "\r",
            "/*\r",
            "using ModType = int;\r",
            "\r",
            "struct VarMod { static ModType value; };\r",
            "ModType VarMod::value;\r",
            "ModType& MOD = VarMod::value;\r",
            "using Mint = Modular<VarMod>;\r",
            "*/\r",
            "\r",
            "constexpr int MOD = (int) 1e9 + 7;\r",
            "using Mint = Modular<std::integral_constant<std::decay<decltype(MOD)>::type, MOD>>;\r"
        ]
    },
    "pbds_tree": {
        "prefix": "pbds_tree",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>\r",
            "#include <ext/pb_ds/tree_policy.hpp>\r",
            "#include <ext/pb_ds/tag_and_trait.hpp>\r",
            "\r",
            "template<class T> \r",
            "using pbds_tree = __gnu_pbds::tree<T, __gnu_pbds::null_type, std::less<T>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\r"
        ]
    },
    "scanner": {
        "prefix": "scanner",
        "body": [
            "class Scanner {\r",
            "  static constexpr int buf = (1 << 27);\r",
            "  char in[buf], *rb;\r",
            "\r",
            " public:\r",
            "  Scanner() {\r",
            "    std::fread(in, 1, buf, stdin);\r",
            "    rb = in;\r",
            "  }\r",
            "\r",
            "  template <class T, std::enable_if_t<std::is_same<T, int>::value, int> = 0>\r",
            "  inline void read(T& num) {\r",
            "    bool neg = false;\r",
            "    num = 0;\r",
            "    while (!std::isdigit(*rb) && *rb != '-') ++rb;\r",
            "    if (*rb == '-') neg = true, ++rb;\r",
            "    while (std::isdigit(*rb)) num = (num << 3) + (num << 1) + (*rb - '0'), ++rb;\r",
            "    if (neg) num = -num;\r",
            "  }\r",
            "\r",
            "  template <class T, std::enable_if_t<std::is_same<T, int64>::value, int> = 0>\r",
            "  inline void read(T& num) {\r",
            "    bool neg = false;\r",
            "    num = 0;\r",
            "    while (!std::isdigit(*rb) && *rb != '-') ++rb;\r",
            "    if (*rb == '-') neg = true, ++rb;\r",
            "    while (std::isdigit(*rb)) num = (num << 3) + (num << 1) + (*rb - '0'), ++rb;\r",
            "    if (neg) num = -num;\r",
            "  }\r",
            "\r",
            "  template <class T,\r",
            "            std::enable_if_t<std::is_same<T, std::string>::value, int> = 0>\r",
            "  inline void read(T& str) {\r",
            "    while (std::isspace(*rb)) ++rb;\r",
            "    auto it = rb;\r",
            "    while (!std::isspace(*rb)) ++rb;\r",
            "    str = std::string(it, rb);\r",
            "  }\r",
            "\r",
            "  template <class T, std::enable_if_t<std::is_same<T, char>::value, int> = 0>\r",
            "  inline void read(T& c) {\r",
            "    while (std::isspace(*rb)) ++rb;\r",
            "    c = *rb, ++rb;\r",
            "  }\r",
            "\r",
            "  template <class T, std::enable_if_t<std::is_same<T, double>::value, int> = 0>\r",
            "  inline void read(T& num) {\r",
            "    while (std::isspace(*rb)) ++rb;\r",
            "    auto it = rb;\r",
            "    while (!std::isspace(*rb)) ++rb;\r",
            "    const std::string str = std::string(it, rb);\r",
            "    num = std::stod(str);\r",
            "  }\r",
            "\r",
            "  template <class T,\r",
            "            std::enable_if_t<std::is_same<T, long double>::value, int> = 0>\r",
            "  inline void read(T& num) {\r",
            "    while (std::isspace(*rb)) ++rb;\r",
            "    auto it = rb;\r",
            "    while (!std::isspace(*rb)) ++rb;\r",
            "    const std::string str = std::string(it, rb);\r",
            "    num = std::stold(str);\r",
            "  }\r",
            "\r",
            "  template <class T>\r",
            "  inline void read(std::vector<T>& vec) {\r",
            "    for (T& e : vec) read(e);\r",
            "  }\r",
            "\r",
            "  template <class T, class U>\r",
            "  inline void read(std::pair<T, U>& p) {\r",
            "    read(p.first, p.second);\r",
            "  }\r",
            "\r",
            "  template <class Tuple, std::size_t... Is>\r",
            "  inline void tuple_scan(Tuple& tp, std::index_sequence<Is...>) {\r",
            "    (read(std::get<Is>(tp)), ...);\r",
            "  }\r",
            "\r",
            "  template <class... Args>\r",
            "  inline void read(std::tuple<Args...>& tp) {\r",
            "    tuple_scan(tp, std::index_sequence_for<Args...>{});\r",
            "  }\r",
            "\r",
            "  inline void read() {}\r",
            "\r",
            "  template <class Head, class... Tail>\r",
            "  inline void read(Head&& head, Tail&&... tail) {\r",
            "    read(head);\r",
            "    read(std::forward<Tail>(tail)...);\r",
            "  }\r",
            "\r",
            "  template <class T>\r",
            "  inline Scanner& operator>>(T& val) {\r",
            "    read(val);\r",
            "    return *this;\r",
            "  }\r",
            "};\r"
        ]
    },
    "template": {
        "prefix": "template",
        "body": [
            "#pragma region kyomukyomupurin\r",
            "\r",
            "/**\r",
            " *    author  : \ud835\udc8c\ud835\udc9a\ud835\udc90\ud835\udc8e\ud835\udc96\ud835\udc8c\ud835\udc9a\ud835\udc90\ud835\udc8e\ud835\udc96\ud835\udc91\ud835\udc96\ud835\udc93\ud835\udc8a\ud835\udc8f\r",
            " *    created : $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND\r",
            " **/\r",
            "\r",
            "#include <algorithm>\r",
            "#include <bitset>\r",
            "#include <cassert>\r",
            "#include <cctype>\r",
            "#include <chrono>\r",
            "#include <cmath>\r",
            "#include <complex>\r",
            "#include <deque>\r",
            "#include <iomanip>\r",
            "#include <iostream>\r",
            "#include <map>\r",
            "#include <numeric>\r",
            "#include <queue>\r",
            "#include <random>\r",
            "#include <set>\r",
            "#include <stack>\r",
            "#include <string>\r",
            "#include <tuple>\r",
            "#include <utility>\r",
            "#include <vector>\r",
            "\r",
            "using namespace std;\r",
            "\r",
            "using int64 = long long;\r",
            "\r",
            "template<class T>\r",
            "inline void eraque(std::vector<T>& vec) {\r",
            "  vec.erase(std::unique(vec.begin(), vec.end()), vec.end());\r",
            "  return;\r",
            "}\r",
            "\r",
            "template<class T>\r",
            "inline int lower_position(const std::vector<T>& vec, T value) {\r",
            "  return static_cast<int>(std::distance(vec.begin(), std::lower_bound(vec.begin(), vec.end(), value)));\r",
            "}\r",
            "\r",
            "template<class T>\r",
            "inline int upper_position(const std::vector<T>& vec, T value) {\r",
            "  return static_cast<int>(std::distance(vec.begin(), std::upper_bound(vec.begin(), vec.end(), value)));\r",
            "}\r",
            "\r",
            "template <class T>\r",
            "using binary_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\r",
            "\r",
            "template <class T, class U>\r",
            "std::ostream& operator<<(std::ostream& os, const std::pair<T, U>& p) {\r",
            "  return os << '(' << p.first << \", \" << p.second << ')';\r",
            "}\r",
            "\r",
            "template <class Ch, class Tr, class Tuple, std::size_t... Is>\r",
            "void tuple_out(std::basic_ostream<Ch, Tr>& os, const Tuple& tp, std::index_sequence<Is...>) {\r",
            "  ((os << (Is ? \", \" : \"(\") << std::get<Is>(tp)), ...) << \")\";\r",
            "}\r",
            "\r",
            "template <class Ch, class Tr, class... Args>\r",
            "auto& operator<<(std::basic_ostream<Ch, Tr>& os, const std::tuple<Args...>& tp) {\r",
            "  tuple_out(os, tp, std::index_sequence_for<Args...>{});\r",
            "  return os;\r",
            "}\r",
            "\r",
            "template <class T>\r",
            "std::ostream& operator<<(std::ostream& os, const std::vector<T>& vec) {\r",
            "  int n = 0;\r",
            "  for (auto e : vec) os << (n++ ? \", \" : \"{\") << e;\r",
            "  return os << (n ? \"}\" : \"{}\");\r",
            "}\r",
            "\r",
            "template <class T, class Compare>\r",
            "std::ostream& operator<<(std::ostream& os, const std::set<T, Compare>& st) {\r",
            "  int n = 0;\r",
            "  for (auto e : st) os << (n++ ? \", \" : \"{\") << e;\r",
            "  return os << (n ? \"}\" : \"{}\");\r",
            "}\r",
            "\r",
            "template <class T, class U, class Compare>\r",
            "std::ostream& operator<<(std::ostream& os, const std::map<T, U, Compare>& mp) {\r",
            "  int n = 0;\r",
            "  for (auto e : mp) os << (n++ ? \", \" : \"{\") << e;\r",
            "  return os << (n ? \"}\" : \"{}\");\r",
            "}\r",
            "\r",
            "template <class T>\r",
            "std::istream& operator>>(std::istream& is, std::vector<T>& vec) {\r",
            "  for (T& e : vec) is >> e;\r",
            "  return is;\r",
            "}\r",
            "\r",
            "template <class T, class U>\r",
            "std::istream& operator>>(std::istream& is, std::pair<T, U>& p) {\r",
            "  return is >> p.first >> p.second;\r",
            "}\r",
            "\r",
            "template <class Tuple, std::size_t... Is>\r",
            "void tuple_in(std::istream& is, Tuple& tp, std::index_sequence<Is...>) {\r",
            "  ((is >> std::get<Is>(tp)), ...);\r",
            "}\r",
            "\r",
            "template <class... Args>\r",
            "std::istream& operator>>(std::istream& is, std::tuple<Args...>& tp) {\r",
            "  tuple_in(is, tp, std::index_sequence_for<Args...>{});\r",
            "  return is;\r",
            "}\r",
            "\r",
            "#define all(_) begin(_), end(_)\r",
            "#define rall(_) rbegin(_), rend(_)\r",
            "\r",
            "#ifdef LOCAL\r",
            "#define debug(...) cerr << \"[\" << #__VA_ARGS__ << \"]: \", debug_out(__VA_ARGS__)\r",
            "#else\r",
            "#define debug(...)\r",
            "#endif\r",
            "\r",
            "void debug_out() { std::cerr << '\\n'; }\r",
            "\r",
            "template <class Head, class... Tail>\r",
            "void debug_out(Head&& head, Tail&&... tail) {\r",
            "  std::cerr << head;\r",
            "  if (sizeof...(Tail) != 0) std::cerr << \", \";\r",
            "  debug_out(std::forward<Tail>(tail)...);\r",
            "}\r",
            "\r",
            "#pragma endregion kyomukyomupurin\r",
            "\r",
            "int main() {\r",
            "  ios_base::sync_with_stdio(false);\r",
            "  cin.tie(nullptr);\r",
            "\r",
            "\r",
            "\r",
            "  return 0;\r",
            "}\r"
        ]
    },
    "timer": {
        "prefix": "timer",
        "body": [
            "class Timer {\r",
            " public:\r",
            "  // (second)\r",
            "  double GetElapsedTime() {\r",
            "    return static_cast<double>(GetCycle() - start_) /\r",
            "           static_cast<double>(clock_frequency_);\r",
            "  }\r",
            "\r",
            "  void Start() { start_ = GetCycle(); }\r",
            "\r",
            " private:\r",
            "  int64_t start_;\r",
            "  static constexpr int64_t clock_frequency_ = 2800000000;\r",
            "\r",
            "  int64_t GetCycle() {\r",
            "    uint32_t low, high;\r",
            "    __asm__ volatile(\"rdtsc\" : \"=a\"(low), \"=d\"(high));\r",
            "    return (static_cast<int64_t>(low)) | (static_cast<int64_t>(high) << 32);\r",
            "  }\r",
            "};\r"
        ]
    },
    "xorshift": {
        "prefix": "xorshift",
        "body": [
            "class Xorshift {\r",
            " public:\r",
            "  Xorshift() {\r",
            "    seed0_ = static_cast<uint64_t>(\r",
            "        std::chrono::steady_clock::now().time_since_epoch().count());\r",
            "    seed1_ = static_cast<uint64_t>(\r",
            "        std::chrono::steady_clock::now().time_since_epoch().count());\r",
            "    for (int i = 0; i < 100; ++i) {\r",
            "      GetNext();\r",
            "    }\r",
            "  }\r",
            "  using result_type = uint64_t;\r",
            "  static constexpr uint64_t min() {\r",
            "    return std::numeric_limits<result_type>::min();\r",
            "  }\r",
            "  static constexpr uint64_t max() {\r",
            "    return std::numeric_limits<result_type>::max();\r",
            "  }\r",
            "\r",
            "  uint64_t operator()() { return GetNext(); }\r",
            "\r",
            " private:\r",
            "  uint64_t result_;\r",
            "  uint64_t seed0_;\r",
            "  uint64_t seed1_;\r",
            "\r",
            "  uint64_t GetNext() {\r",
            "    uint64_t s1 = seed0_;\r",
            "    uint64_t s0 = seed1_;\r",
            "    result_ = s0 + s1;\r",
            "    seed0_ = s0;\r",
            "    s1 ^= s1 << 23;\r",
            "    seed1_ = s1 ^ s0 ^ (s1 >> 18) ^ (s0 >> 5);\r",
            "    return result_;\r",
            "  }\r",
            "};\r"
        ]
    },
    "bellman_ford": {
        "prefix": "bellman_ford",
        "body": [
            "template <class _Tp>\r",
            "class BellmanFord {\r",
            " public:\r",
            "  static constexpr _Tp kInfinity =\r",
            "      std::numeric_limits<_Tp>::max() / static_cast<_Tp>(2);\r",
            "\r",
            "  BellmanFord(int node_size) : node_size_(node_size) { initialize(); }\r",
            "\r",
            "  void add(int from, int to, _Tp cost) {\r",
            "    assert(0 <= from && from < node_size_ && 0 <= to && to < node_size_);\r",
            "    es_.emplace_back((edge){from, to, cost});\r",
            "  }\r",
            "\r",
            "  // use after bf.solve(source)\r",
            "  bool find_negative_cycle() const {\r",
            "    for (const edge& e : es_) {\r",
            "      if (distance_[e.from] == kInfinity) continue;\r",
            "      if (distance_[e.from] + e.cost < distance_[e.to]) return true;\r",
            "    }\r",
            "    return false;\r",
            "  }\r",
            "\r",
            "  void solve(int source) {\r",
            "    assert(0 <= source && source < node_size_);\r",
            "    distance_[source] = 0;\r",
            "    for (int i = 0; i < node_size_ - 1; ++i) {\r",
            "      for (const edge& e : es_) {\r",
            "        if (distance_[e.from] == kInfinity) continue;\r",
            "        if (distance_[e.to] > distance_[e.from] + e.cost) {\r",
            "          distance_[e.to] = distance_[e.from] + e.cost;\r",
            "        }\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "\r",
            "  _Tp operator[](int to) const {\r",
            "    assert(0 <= to && to < node_size_);\r",
            "    return distance_[to];\r",
            "  }\r",
            "\r",
            " private:\r",
            "  struct edge {\r",
            "    int from, to;\r",
            "    _Tp cost;\r",
            "  };\r",
            "  int node_size_;\r",
            "  std::vector<_Tp> distance_;\r",
            "  std::vector<edge> es_;\r",
            "\r",
            "  void initialize() { distance_.assign(node_size_, kInfinity); }\r",
            "};\r"
        ]
    },
    "dijkstra": {
        "prefix": "dijkstra",
        "body": [
            "template <class _Tp>\r",
            "class Dijkstra {\r",
            " public:\r",
            "  static constexpr _Tp kInfinity =\r",
            "      std::numeric_limits<_Tp>::max() / static_cast<_Tp>(2);\r",
            "\r",
            "  Dijkstra(int node_size) : node_size_(node_size), graph_(node_size) {}\r",
            "\r",
            "  void add(int from, int to, _Tp cost) {\r",
            "    assert(0 <= from && from < node_size_ && 0 <= to && to < node_size_);\r",
            "    graph_[from].emplace_back((edge){to, cost});\r",
            "  }\r",
            "\r",
            "  void solve(int source) {\r",
            "    assert(0 <= source && source < node_size_);\r",
            "    distance_.assign(node_size_, kInfinity);\r",
            "    binary_heap<std::pair<_Tp, int>> pq;\r",
            "    distance_[source] = 0;\r",
            "    pq.emplace(0, source);\r",
            "\r",
            "    while (!pq.empty()) {\r",
            "      std::pair<_Tp, int> cur = pq.top();\r",
            "      pq.pop();\r",
            "      int v = cur.second;\r",
            "      if (distance_[v] < cur.first) continue;\r",
            "      for (const edge& e : graph_[v]) {\r",
            "        if (distance_[e.to] > distance_[v] + e.cost) {\r",
            "          distance_[e.to] = distance_[v] + e.cost;\r",
            "          pq.emplace(distance_[e.to], e.to);\r",
            "        }\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "\r",
            "  _Tp operator[](int to) const {\r",
            "    assert(0 <= to && to < node_size_);\r",
            "    return distance_[to];\r",
            "  }\r",
            "\r",
            " private:\r",
            "  struct edge {\r",
            "    int to;\r",
            "    _Tp cost;\r",
            "  };\r",
            "  int node_size_;\r",
            "  std::vector<_Tp> distance_;\r",
            "  std::vector<std::vector<edge>> graph_;\r",
            "};\r"
        ]
    },
    "dinic": {
        "prefix": "dinic",
        "body": [
            "template <class _Tp>\r",
            "class Dinic {\r",
            " public:\r",
            "  Dinic(int node_size) : node_size_(node_size) { initialize(); }\r",
            "\r",
            "  void add(int from, int to, _Tp cost) {\r",
            "    assert(0 <= from && from < node_size_ && 0 <= to && to < node_size_);\r",
            "    graph_[from].emplace_back(\r",
            "        (edge){to, cost, static_cast<int>(graph_[to].size())});\r",
            "    graph_[to].emplace_back((edge){from, static_cast<_Tp>(0),\r",
            "                                   static_cast<int>(graph_[from].size()) - 1});\r",
            "  }\r",
            "\r",
            "  _Tp max_flow(int s, int t) {\r",
            "    _Tp flow = 0;\r",
            "    for (;;) {\r",
            "      bfs(s);\r",
            "      if (level_[t] < 0) return flow;\r",
            "      std::fill(iter_.begin(), iter_.end(), 0);\r",
            "      _Tp f;\r",
            "      while ((f = dfs(s, t,\r",
            "                      std::numeric_limits<_Tp>::max() / static_cast<_Tp>(2))) >\r",
            "             0) {\r",
            "        flow += f;\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "\r",
            " private:\r",
            "  struct edge {\r",
            "    int to;\r",
            "    _Tp cap;\r",
            "    int rev;\r",
            "  };\r",
            "  int node_size_;\r",
            "  std::vector<std::vector<edge>> graph_;\r",
            "  std::vector<int> level_;\r",
            "  std::vector<int> iter_;\r",
            "\r",
            "  void initialize() {\r",
            "    graph_.resize(node_size_);\r",
            "    level_.assign(node_size_, 0);\r",
            "    iter_.assign(node_size_, 0);\r",
            "  }\r",
            "\r",
            "  void bfs(int s) {\r",
            "    std::fill(level_.begin(), level_.end(), -1);\r",
            "    std::queue<int> que;\r",
            "    level_[s] = 0;\r",
            "    que.emplace(s);\r",
            "    while (!que.empty()) {\r",
            "      int cur = que.front();\r",
            "      que.pop();\r",
            "      for (const edge& next : graph_[cur]) {\r",
            "        if (next.cap > 0 && level_[next.to] < 0) {\r",
            "          level_[next.to] = level_[cur] + 1;\r",
            "          que.emplace(next.to);\r",
            "        }\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "\r",
            "  _Tp dfs(int v, int t, int f) {\r",
            "    if (v == t) return f;\r",
            "    for (int& i = iter_[v]; i < (int)graph_[v].size(); ++i) {\r",
            "      edge& e = graph_[v][i];\r",
            "      if (e.cap > 0 && level_[v] < level_[e.to]) {\r",
            "        _Tp d = dfs(e.to, t, min(f, e.cap));\r",
            "        if (d > 0) {\r",
            "          e.cap -= d;\r",
            "          graph_[e.to][e.rev].cap += d;\r",
            "          return d;\r",
            "        }\r",
            "      }\r",
            "    }\r",
            "    return 0;\r",
            "  }\r",
            "};\r"
        ]
    },
    "lca": {
        "prefix": "lca",
        "body": [
            "class LCA {\r",
            " public:\r",
            "  LCA(int node_size, int root = 0)\r",
            "      : node_size_(node_size),\r",
            "        log_node_(32 - __builtin_clz(node_size_)),\r",
            "        root_(root) {\r",
            "    initialize();\r",
            "  }\r",
            "\r",
            "  void add(int u, int v) {\r",
            "    assert(0 <= u && u < node_size_ && 0 <= v && v < node_size_);\r",
            "    graph_[u].emplace_back(v);\r",
            "    graph_[v].emplace_back(u);\r",
            "  }\r",
            "\r",
            "  void build() {\r",
            "    dfs(root_, -1, 0);\r",
            "    for (int i = 0; i + 1 < log_node_; ++i) {\r",
            "      for (int j = 0; j < node_size_; ++j) {\r",
            "        if (par_[i][j] < 0) {\r",
            "          par_[i + 1][j] = -1;\r",
            "        } else {\r",
            "          par_[i + 1][j] = par_[i][par_[i][j]];\r",
            "        }\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "\r",
            "  // use after build()\r",
            "  int lca(int u, int v) {\r",
            "    assert(0 <= u && u < node_size_ && 0 <= v && v < node_size_);\r",
            "    if (depth_[u] > depth_[v]) std::swap(u, v);\r",
            "    for (int i = 0; i < log_node_; ++i) {\r",
            "      if ((depth_[v] - depth_[u]) >> i & 1) {\r",
            "        v = par_[i][v];\r",
            "      }\r",
            "    }\r",
            "    if (u == v) return u;\r",
            "    for (int i = log_node_ - 1; i >= 0; --i) {\r",
            "      if (par_[i][u] != par_[i][v]) {\r",
            "        u = par_[i][u];\r",
            "        v = par_[i][v];\r",
            "      }\r",
            "    }\r",
            "    return par_[0][u];\r",
            "  }\r",
            "\r",
            "  int dist(int u, int v) {\r",
            "    assert(0 <= u && u < node_size_ && 0 <= v && v < node_size_);\r",
            "    return depth_[u] + depth_[v] - 2 * depth_[lca(u, v)];\r",
            "  }\r",
            "\r",
            " private:\r",
            "  int node_size_;\r",
            "  int log_node_;\r",
            "  int root_;\r",
            "  std::vector<std::vector<int>> graph_;\r",
            "  std::vector<std::vector<int>> par_;\r",
            "  std::vector<int> depth_;\r",
            "\r",
            "  void dfs(int cur, int prev, int d) {\r",
            "    par_[0][cur] = prev;\r",
            "    depth_[cur] = d;\r",
            "    for (const int& next : graph_[cur]) {\r",
            "      if (next == prev) continue;\r",
            "      dfs(next, cur, d + 1);\r",
            "    }\r",
            "  }\r",
            "\r",
            "  void initialize() {\r",
            "    depth_.resize(node_size_);\r",
            "    graph_.resize(node_size_);\r",
            "    par_.assign(log_node_, std::vector<int>(node_size_, -1));\r",
            "  }\r",
            "};\r"
        ]
    },
    "spfa": {
        "prefix": "spfa",
        "body": [
            "template <class _Tp>\r",
            "class SPFA {\r",
            " public:\r",
            "  static constexpr _Tp kInfinity =\r",
            "      std::numeric_limits<_Tp>::max() / static_cast<_Tp>(2);\r",
            "\r",
            "  SPFA(int node_size) : node_size_(node_size) { initialize(); }\r",
            "\r",
            "  void add(int from, int to, _Tp cost) {\r",
            "    assert(0 <= from && from < node_size_ && 0 <= to && to < node_size_);\r",
            "    graph_[from].emplace_back((edge){to, cost});\r",
            "  }\r",
            "\r",
            "  // use after solve()\r",
            "  bool find_negative_cycle() const noexcept { return distance_.empty(); }\r",
            "\r",
            "  void solve(int source) {\r",
            "    assert(0 <= source && source < node_size_);\r",
            "    std::queue<int> que;\r",
            "    que.emplace(source);\r",
            "    pending_[source] = true;\r",
            "    ++times_[source];\r",
            "    distance_[source] = 0;\r",
            "    while (!que.empty()) {\r",
            "      int cur = que.front();\r",
            "      que.pop();\r",
            "      pending_[cur] = false;\r",
            "      for (const auto& next : graph_[cur]) {\r",
            "        _Tp next_cost = distance_[cur] + next.cost;\r",
            "        if (next_cost >= distance_[next.to]) continue;\r",
            "        distance_[next.to] = next_cost;\r",
            "        if (!pending_[next.to]) {\r",
            "          if (++times_[next.to] >= node_size_) {\r",
            "            distance_.clear();\r",
            "            return;\r",
            "          }\r",
            "          pending_[next.to] = true;\r",
            "          que.emplace(next.to);\r",
            "        }\r",
            "      }\r",
            "    }\r",
            "    return;\r",
            "  }\r",
            "\r",
            "  _Tp operator[](int to) const {\r",
            "    assert(0 <= to && to < node_size_);\r",
            "    return distance_[to];\r",
            "  }\r",
            "\r",
            " private:\r",
            "  struct edge {\r",
            "    int to;\r",
            "    _Tp cost;\r",
            "  };\r",
            "  int node_size_;\r",
            "  std::vector<std::vector<edge>> graph_;\r",
            "  std::vector<_Tp> distance_;\r",
            "  std::vector<int> pending_;\r",
            "  std::vector<int> times_;\r",
            "\r",
            "  void initialize() {\r",
            "    graph_.resize(node_size_);\r",
            "    distance_.assign(node_size_,\r",
            "                     std::numeric_limits<_Tp>::max() / static_cast<_Tp>(2));\r",
            "    pending_.assign(node_size_, 0);\r",
            "    times_.assign(node_size_, 0);\r",
            "  }\r",
            "};\r"
        ]
    },
    "topological_sort": {
        "prefix": "topological_sort",
        "body": [
            "class TopologicalSort {\r",
            " public:\r",
            "  TopologicalSort(int node_size) : node_size_(node_size) { Initialize(); }\r",
            "\r",
            "  void AddEdge(int from, int to) {\r",
            "    graph_[from].emplace_back(to);\r",
            "    ++level_[to];\r",
            "  }\r",
            "\r",
            "  void Sort() {\r",
            "    std::queue<int> que;\r",
            "    for (int i = 0; i < node_size_; ++i) {\r",
            "      if (level_[i] == 0) que.push(i);\r",
            "    }\r",
            "    while (!que.empty()) {\r",
            "      int top = que.front();\r",
            "      que.pop();\r",
            "      result_.emplace_back(top);\r",
            "      for (int next : graph_[top]) {\r",
            "        if (--level_[next] == 0) que.push(next);\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "\r",
            "  // use after Sort()!\r",
            "  bool IsDAG() {\r",
            "    return all_of(level_.begin(), level_.end(), [](int x) { return x == 0; });\r",
            "  }\r",
            "\r",
            "  int operator[](int position) const { return result_[position]; }\r",
            "\r",
            " private:\r",
            "  int node_size_;\r",
            "  std::vector<std::vector<int>> graph_;\r",
            "  std::vector<int> level_;\r",
            "  std::vector<int> result_;\r",
            "\r",
            "  void Initialize() {\r",
            "    graph_.resize(node_size_);\r",
            "    level_.assign(node_size_, 0);\r",
            "  }\r",
            "};\r"
        ]
    },
    "tree_diameter": {
        "prefix": "tree_diameter",
        "body": [
            "template <class _Tp>\r",
            "class TreeDiameter {\r",
            " public:\r",
            "  TreeDiameter(int node_size) : node_size_(node_size), graph_(node_size_) {}\r",
            "\r",
            "  void add(int from, int to, _Tp cost) {\r",
            "    assert(0 <= from && from < node_size_ && 0 <= to && to < node_size_);\r",
            "    graph_[from].emplace_back((edge){cost, to});\r",
            "    graph_[to].emplace_back((edge){cost, from});\r",
            "  }\r",
            "\r",
            "  _Tp get() { return bfs(bfs(0).second).first; }\r",
            "\r",
            " private:\r",
            "  struct edge {\r",
            "    _Tp cost;\r",
            "    int to;\r",
            "  };\r",
            "  int node_size_;\r",
            "  std::vector<std::vector<edge>> graph_;\r",
            "\r",
            "  std::pair<_Tp, int> bfs(int source) {\r",
            "    std::pair<_Tp, int> result = {static_cast<_Tp>(0), 0};\r",
            "    std::queue<int> que;\r",
            "    bool visited[node_size_] = {};\r",
            "    vector<_Tp> dist(node_size_, 0);\r",
            "    visited[source] = true;\r",
            "    que.emplace(source);\r",
            "    while (!que.empty()) {\r",
            "      int cur = que.front();\r",
            "      que.pop();\r",
            "      for (const auto& next : graph_[cur]) {\r",
            "        if (visited[next.to]) continue;\r",
            "        visited[next.to] = true;\r",
            "        dist[next.to] += dist[cur] + next.cost;\r",
            "        que.emplace(next.to);\r",
            "        result = std::max(result, {dist[next.to], next.to});\r",
            "      }\r",
            "    }\r",
            "    return result;\r",
            "  }\r",
            "};\r"
        ]
    },
    "combination": {
        "prefix": "combination",
        "body": [
            "class Combination {\r",
            " public:\r",
            "  static constexpr int mod_ = 1000000007;\r",
            "  static constexpr int n_ = 2000000 + 5;\r",
            "\r",
            "  Combination() { build(); }\r",
            "\r",
            "  std::array<int64, n_> fact_;\r",
            "  std::array<int64, n_> inv_;\r",
            "  std::array<int64, n_> finv_;\r",
            "\r",
            "  // return nCk\r",
            "  int64 get(int n, int k) const noexcept {\r",
            "    if (n < k || n < 0 || k < 0) return 0;\r",
            "    return fact_[n] * (finv_[k] * finv_[n - k] % mod_) % mod_;\r",
            "  }\r",
            "\r",
            " private:\r",
            "  void build() noexcept {\r",
            "    fact_[0] = 1;\r",
            "    fact_[1] = 1;\r",
            "    finv_[0] = 1;\r",
            "    finv_[1] = 1;\r",
            "    inv_[1] = 1;\r",
            "    for (int i = 2; i < n_; ++i) {\r",
            "      fact_[i] = fact_[i - 1] * i % mod_;\r",
            "      inv_[i] = mod_ - inv_[mod_ % i] * (mod_ / i) % mod_;\r",
            "      finv_[i] = finv_[i - 1] * inv_[i] % mod_;\r",
            "    }\r",
            "  }\r",
            "};\r"
        ]
    },
    "divisor": {
        "prefix": "divisor",
        "body": [
            "template<class _Tp> std::vector<_Tp> divisor(_Tp n) {\r",
            "  std::vector<_Tp> res;\r",
            "  for (_Tp i = 1; i * i <= n; ++i) {\r",
            "    if (n % i == 0){\r",
            "      res.emplace_back(i);\r",
            "      if (i * i != n){\r",
            "        res.emplace_back(n / i);\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "  std::sort(res.begin(), res.end());\r",
            "\r",
            "  return res;\r",
            "}\r"
        ]
    },
    "fast_gcd": {
        "prefix": "fast_gcd",
        "body": [
            "unsigned long long fast_gcd(unsigned long long x, unsigned long long y) {\r",
            "  int shift;\r",
            "  if (x == 0) return y;\r",
            "  if (y == 0) return x;\r",
            "  shift = __builtin_ctzll(x | y);\r",
            "  x >>= __builtin_ctzll(x);\r",
            "  do {\r",
            "    y >>= __builtin_ctzll(y);\r",
            "    if (x > y) std::swap(x, y);\r",
            "    y -= x;\r",
            "  } while (y);\r",
            "  return x << shift;\r",
            "}\r"
        ]
    },
    "miller_rabin": {
        "prefix": "miller_rabin",
        "body": [
            "class MillerRabinTest {\r",
            "  using uint64 = uint64_t;\r",
            "  using uint128 = __uint128_t;\r",
            "\r",
            " public:\r",
            "  MillerRabinTest() {}\r",
            "\r",
            "  bool isprime(uint64 n) {\r",
            "    if (n < 2) return false;\r",
            "    int r = 0;\r",
            "    uint64 d = n - 1;\r",
            "    while ((d & 1) == 0) {\r",
            "      d >>= 1;\r",
            "      r++;\r",
            "    }\r",
            "\r",
            "    for (int a : {2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37}) {\r",
            "      if (n == (uint64)a) return true;\r",
            "      if (check(n, a, d, r)) return false;\r",
            "    }\r",
            "    return true;\r",
            "  }\r",
            "\r",
            " private:\r",
            "  uint64 power(uint64 base, uint64 e, uint64 mod) {\r",
            "    uint64 res = 1;\r",
            "    base %= mod;\r",
            "    while (e) {\r",
            "      if (e & 1) res = (uint128)res * base % mod;\r",
            "      base = (uint128)base * base % mod;\r",
            "      e >>= 1;\r",
            "    }\r",
            "    return res;\r",
            "  }\r",
            "\r",
            "  bool check(uint64 n, uint64 a, uint64 d, int s) {\r",
            "    uint64 x = power(a, d, n);\r",
            "    if (x == 1 || x == n - 1) return false;\r",
            "    for (int r = 1; r < s; r++) {\r",
            "      x = (uint128)x * x % n;\r",
            "      if (x == n - 1) return false;\r",
            "    }\r",
            "    return true;\r",
            "  };\r",
            "};\r"
        ]
    },
    "mod_pow": {
        "prefix": "mod_pow",
        "body": [
            "template<class T, class U> T mod_pow(T x, U n, T mod) {\r",
            "  T res = 1;\r",
            "  while (n > 0) {\r",
            "    if (n & 1) (res *= x) %= mod;\r",
            "    (x *= x) %= mod;\r",
            "    n >>= 1;\r",
            "  }\r",
            "  return res;\r",
            "}\r"
        ]
    },
    "prime_factorization": {
        "prefix": "prime_factorization",
        "body": [
            "template<class _Tp>\r",
            "std::map<_Tp, int> prime_fact(_Tp n){\r",
            "  std::map<_Tp, int> result;\r",
            "  for (_Tp i = 2; i * i <= n; ++i){\r",
            "    if (n % i != 0) continue;\r",
            "    int cnt = 0;\r",
            "    while (n % i == 0){\r",
            "      n /= i; ++cnt;\r",
            "    }\r",
            "    result[i] = cnt;\r",
            "  }\r",
            "  if (n != 1) result[n] = 1;\r",
            "  return result;\r",
            "}\r"
        ]
    },
    "sieve": {
        "prefix": "sieve",
        "body": [
            "std::vector<int> LinearTimeSieve() {\r",
            "  constexpr int n = 1000000;\r",
            "  std::array<int, n + 1> lp;\r",
            "  lp.fill(0);\r",
            "  std::vector<int> pr;\r",
            "  for (int i = 2; i <= n; ++i) {\r",
            "    if (!lp[i]) {\r",
            "      lp[i] = i;\r",
            "      pr.emplace_back(i);\r",
            "    }\r",
            "    for (int j = 0; j < (int)pr.size() && pr[j] <= lp[i] && i * pr[j] <= n;\r",
            "         ++j) {\r",
            "      lp[i * pr[j]] = pr[j];\r",
            "    }\r",
            "  }\r",
            "  return pr;\r",
            "}\r"
        ]
    },
    "totient": {
        "prefix": "totient",
        "body": [
            "template <class _Tp>\r",
            "_Tp Totient(_Tp n) {\r",
            "  _Tp res = n;\r",
            "  for (_Tp i = 2; i * i <= n; ++i) {\r",
            "    if (n % i != 0) continue;\r",
            "    (res /= i) *= (i - 1);\r",
            "    while (n % i == 0) n /= i;\r",
            "  }\r",
            "  if (n != 1) (res /= n) *= (n - 1);\r",
            "  return res;\r",
            "}\r"
        ]
    },
    "lcs": {
        "prefix": "lcs",
        "body": [
            "std::string LCS(const std::string& str1, const std::string& str2) {\r",
            "  int n1 = str1.size(), n2 = str2.size();\r",
            "  std::vector<std::vector<int>> dp(n1 + 1, std::vector<int>(n2 + 1, 0));\r",
            "  for (int i = 0; i < n1; ++i) {\r",
            "    for (int j = 0; j < n2; ++j) {\r",
            "      if (str1[i] == str2[j]) {\r",
            "        dp[i + 1][j + 1] = dp[i][j] + 1;\r",
            "      } else {\r",
            "        dp[i + 1][j + 1] = std::max(dp[i + 1][j], dp[i][j + 1]);\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "  int c1 = n1, c2 = n2;\r",
            "  std::string ret = \"\";\r",
            "  while (c1 > 0 && c2 > 0) {\r",
            "    if (str1[c1 - 1] == str2[c2 - 1]) {\r",
            "      ret += str1[c1 - 1];\r",
            "      --c1;\r",
            "      --c2;\r",
            "    } else {\r",
            "      if (dp[c1][c2] == dp[c1][c2 - 1]) {\r",
            "        --c2;\r",
            "      } else {\r",
            "        --c1;\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "  std::reverse(ret.begin(), ret.end());\r",
            "  return ret;\r",
            "}\r"
        ]
    },
    "levenshtein_distance": {
        "prefix": "levenshtein_distance",
        "body": [
            "int Levenshtein_distance(const std::string& str1, const std::string& str2) {\r",
            "  int n1 = str1.size(), n2 = str2.size();\r",
            "  std::vector<std::vector<int>> dp(n1 + 1, std::vector<int>(n2 + 1, 0));\r",
            "  for (int i = 0; i <= n1; ++i) dp[i][0] = i;\r",
            "  for (int i = 0; i <= n2; ++i) dp[0][i] = i;\r",
            "  for (int i = 0; i < n1; ++i) {\r",
            "    for (int j = 0; j < n2; ++j) {\r",
            "      const int cost = (str1[i] != str2[j]);\r",
            "      dp[i + 1][j + 1] =\r",
            "          std::min({dp[i + 1][j] + 1, dp[i][j + 1] + 1, dp[i][j] + cost});\r",
            "    }\r",
            "  }\r",
            "  return dp[n1][n2];\r",
            "}\r",
            "// snippet-end"
        ]
    },
    "manacher": {
        "prefix": "manacher",
        "body": [
            "std::vector<int> Manacher(const std::string& str) {\r",
            "  int n = str.size();\r",
            "  std::vector<int> res(n);\r",
            "  int i = 0, j = 0;\r",
            "  while (i < n) {\r",
            "    while (i - j >= 0 && i + j < n && str[i - j] == str[i + j]) ++j;\r",
            "    res[i] = j;\r",
            "    int k = 1;\r",
            "    while (i - k >= 0 && k + res[i - k] < j) res[i + k] = res[i - k], ++k;\r",
            "    i += k;\r",
            "    j -= k;\r",
            "  }\r",
            "  return res;\r",
            "}\r"
        ]
    },
    "nextchar": {
        "prefix": "nextchar",
        "body": [
            "class NextChar {\r",
            " public:\r",
            "  NextChar(const std::string& str) : str_(str) { build(); }\r",
            "\r",
            "  // returns the first position in str[pos:n_) that c appears\r",
            "  // if c is not in str[pos:n_), returns n_\r",
            "  int find(int pos, char c) const {\r",
            "    assert(0 <= pos && pos < n_);\r",
            "    return table_[c - 'a'][pos];\r",
            "  }\r",
            "\r",
            "  // returns whether str contains c or not\r",
            "  bool contain(char c) const { return find(0, c) != n_; }\r",
            "\r",
            " private:\r",
            "  int n_;\r",
            "  std::string str_;\r",
            "  std::vector<std::vector<int>> table_;\r",
            "\r",
            "  void build() {\r",
            "    n_ = str_.size();\r",
            "    table_.resize(26, std::vector<int>(n_));\r",
            "    for (char c = 'a'; c <= 'z'; ++c) {\r",
            "      int nxt = n_;\r",
            "      for (int i = n_ - 1; i >= 0; --i) {\r",
            "        if (str_[i] == c) nxt = i;\r",
            "        table_[c - 'a'][i] = nxt;\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "};\r"
        ]
    },
    "rolling_hash": {
        "prefix": "rolling_hash",
        "body": [
            "using ull = unsigned long long;\r",
            "\r",
            "class RollingHash {\r",
            " public:\r",
            "  RollingHash(const std::string& str) : str_(str) { build(); }\r",
            "\r",
            "  // get hash value of [l, r)\r",
            "  std::pair<ull, ull> get(int l, int r) {\r",
            "    ull ret0 = (hash0_[r] - hash0_[l] * pow0_[r - l] % mod0_ + mod0_) % mod0_;\r",
            "    ull ret1 = (hash1_[r] - hash1_[l] * pow1_[r - l] % mod1_ + mod1_) % mod1_;\r",
            "    return {ret0, ret1};\r",
            "  }\r",
            "\r",
            " private:\r",
            "  const std::string str_;\r",
            "  static ull base0_;\r",
            "  static ull base1_;\r",
            "  static constexpr ull mod0_ = 2020202077;\r",
            "  static constexpr ull mod1_ = 2020202111;\r",
            "  std::vector<ull> hash0_;\r",
            "  std::vector<ull> hash1_;\r",
            "  static std::vector<ull> pow0_;\r",
            "  static std::vector<ull> pow1_;\r",
            "  static std::mt19937_64 mt_;\r",
            "\r",
            "  void build() {\r",
            "    int n = str_.size();\r",
            "    hash0_.assign(n + 1, 0);\r",
            "    hash1_.assign(n + 1, 0);\r",
            "    for (int i = 0; i < n; ++i) {\r",
            "      hash0_[i + 1] = (hash0_[i] * base0_ + str_[i]) % mod0_;\r",
            "      hash1_[i + 1] = (hash1_[i] * base1_ + str_[i]) % mod1_;\r",
            "    }\r",
            "    for (int i = 0; i < n; ++i) {\r",
            "      pow0_.emplace_back(pow0_.back() * base0_ % mod0_);\r",
            "      pow1_.emplace_back(pow1_.back() * base1_ % mod1_);\r",
            "    }\r",
            "  }\r",
            "};\r",
            "\r",
            "std::mt19937_64 RollingHash::mt_(\r",
            "    std::chrono::steady_clock::now().time_since_epoch().count());\r",
            "ull RollingHash::base0_ = std::uniform_int_distribution<ull>(\r",
            "    2, RollingHash::mod0_ - 1)(RollingHash::mt_);\r",
            "ull RollingHash::base1_ = std::uniform_int_distribution<ull>(\r",
            "    2, RollingHash::mod1_ - 1)(RollingHash::mt_);\r",
            "std::vector<ull> RollingHash::pow0_{1};\r",
            "std::vector<ull> RollingHash::pow1_{1};\r"
        ]
    },
    "z_algorithm": {
        "prefix": "z_algorithm",
        "body": [
            "std::vector<int> Zalgorithm(const std::string str) {\r",
            "  int n = str.size();\r",
            "  std::vector<int> res(n);\r",
            "  res[0] = n;\r",
            "  int i = 1, j = 0;\r",
            "  while (i < n) {\r",
            "    while (i + j < n && str[j] == str[i + j]) ++j;\r",
            "    res[i] = j;\r",
            "    if (j == 0) {\r",
            "      ++i;\r",
            "      continue;\r",
            "    }\r",
            "    int k = 1;\r",
            "    while (i + k < n && k + res[k] < j) res[i + k] = res[k], ++k;\r",
            "    i += k;\r",
            "    j -= k;\r",
            "  }\r",
            "  return res;\r",
            "};\r"
        ]
    }
}