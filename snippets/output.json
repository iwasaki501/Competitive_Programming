{
    "cumulative_sum": {
        "prefix": "cumulative_sum",
        "body": [
            "template <class T>\r",
            "class CumulativeSum {\r",
            " public:\r",
            "  CumulativeSum(const std::vector<T>& vec) : vec_(vec) { build(); }\r",
            "\r",
            "  // return sum of [l, r]\r",
            "  T get(int l, int r) { return sum_[r + 1] - sum_[l]; }\r",
            "\r",
            "  // return the first k where sum of [0, k] >= value\r",
            "  // use only when all element in vec >= 0\r",
            "  int lower_bound(T val) {\r",
            "    return std::distance(sum_.begin() + 1,\r",
            "                         std::lower_bound(sum_.begin() + 1, sum_.end(), val));\r",
            "  }\r",
            "\r",
            "  // return the first k where sum of [0, k] > value\r",
            "  // use only when all element in vec >= 0\r",
            "  int upper_bound(T val) {\r",
            "    return std::distance(sum_.begin() + 1,\r",
            "                         std::upper_bound(sum_.begin() + 1, sum_.end(), val));\r",
            "  }\r",
            "\r",
            " private:\r",
            "  std::vector<T> vec_;\r",
            "  std::vector<T> sum_;\r",
            "\r",
            "  void build() {\r",
            "    sum_.resize(vec_.size() + 1);\r",
            "    sum_[0] = 0;\r",
            "    std::partial_sum(vec_.begin(), vec_.end(), sum_.begin() + 1);\r",
            "  }\r",
            "};\r"
        ]
    },
    "cumulative_sum_2d": {
        "prefix": "cumulative_sum_2d",
        "body": [
            "template <class T>\r",
            "class CumulativeSum2D {\r",
            " public:\r",
            "  CumulativeSum2D(const std::vector<vector<T>>& vec)\r",
            "      : x_((int)vec.size()), y_((int)vec[0].size()), vec_(vec) {\r",
            "    build();\r",
            "  }\r",
            "\r",
            "  // return sum of [sx, gx] * [sy, gy]\r",
            "  T get(int sx, int sy, int gx, int gy) {\r",
            "    assert(sx <= gx && sy <= gy);\r",
            "    assert(0 <= sx && sx < x_ && 0 <= gx && gx < x_ && 0 <= sy && sy < y_ &&\r",
            "           0 <= gy && gy < y_);\r",
            "    return sum_[gx + 1][gy + 1] - sum_[gx + 1][sy] - sum_[sx][gy + 1] +\r",
            "           sum_[sx][sy];\r",
            "  }\r",
            "\r",
            " private:\r",
            "  int x_;\r",
            "  int y_;\r",
            "  std::vector<vector<T>> vec_;\r",
            "  std::vector<vector<T>> sum_;\r",
            "\r",
            "  void build() {\r",
            "    sum_.assign(x_ + 1, std::vector<T>(y_ + 1, 0));\r",
            "    for (int i = 0; i < x_; ++i) {\r",
            "      std::partial_sum(vec_[i].begin(), vec_[i].end(), sum_[i + 1].begin() + 1);\r",
            "    }\r",
            "    for (int i = 0; i < y_; ++i) {\r",
            "      for (int j = 0; j < x_; ++j) {\r",
            "        sum_[j + 1][i + 1] += sum_[j][i + 1];\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "};\r"
        ]
    },
    "doubling": {
        "prefix": "doubling",
        "body": [
            "class Doubling {\r",
            " public:\r",
            "  Doubling(int n, int64 k) : n_(n), lg_(64 - __builtin_clzll(k)) {\r",
            "    table.assign(lg_, std::vector<int>(n_, -1));\r",
            "  }\r",
            "\r",
            "  void set(int pos, int val) { table[0][pos] = val; }\r",
            "\r",
            "  void build() {\r",
            "    for (int i = 0; i + 1 < lg_; ++i) {\r",
            "      for (int j = 0; j < (int)table[i].size(); ++j) {\r",
            "        table[i + 1][j] = (table[i][j] == -1 ? -1 : table[i][table[i][j]]);\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "\r",
            "  int query(int pos, int64 k) {\r",
            "    for (int i = lg_ - 1; i >= 0; --i) {\r",
            "      if (k & (1LL << i)) {\r",
            "        pos = table[i][pos];\r",
            "      }\r",
            "    }\r",
            "    return pos;\r",
            "  }\r",
            "\r",
            " private:\r",
            "  int n_;\r",
            "  int lg_;\r",
            "  std::vector<std::vector<int>> table;\r",
            "};\r"
        ]
    },
    "golden_section_search": {
        "prefix": "golden_section_search",
        "body": [
            "template <class F>\r",
            "std::pair<double, double> GoldenSectionSearch(double low, double high, F f, bool find_min = true) {\r",
            "  constexpr double phi = (1 + std::sqrt(5)) / 2;\r",
            "  double c1 = (phi * low + high) / (1 + phi);\r",
            "  double c2 = (low + phi * high) / (1 + phi);\r",
            "  double cache_f1 = f(c1), cache_f2 = f(c2);\r",
            "\r",
            "  for (int i = 0; i < 150; ++i) {\r",
            "    if ((find_min && cache_f1 > cache_f2) ||\r",
            "        (!find_min && cache_f1 < cache_f2)) {\r",
            "      low = c1;\r",
            "      cache_f1 = cache_f2;\r",
            "      c1 = c2;\r",
            "      c2 = (low + phi * high) / (1 + phi);\r",
            "      cache_f2 = f(c2);\r",
            "    } else {\r",
            "      high = c2;\r",
            "      cache_f2 = cache_f1;\r",
            "      c2 = c1;\r",
            "      c1 = (phi * low + high) / (1 + phi);\r",
            "      cache_f1 = f(c1);\r",
            "    }\r",
            "  }\r",
            "\r",
            "  return {low, cache_f1};\r",
            "}\r"
        ]
    },
    "run_length_encoding": {
        "prefix": "run_length_encoding",
        "body": [
            "std::vector<std::pair<char, int>> RunLengthEncoding(const std::string& str) {\r",
            "  std::vector<std::pair<char, int>> ret;\r",
            "  int sz = str.size();\r",
            "  int beg = 0;\r",
            "  while (beg < sz) {\r",
            "    int ed = beg;\r",
            "    while (ed + 1 < sz && str[beg] == str[ed + 1]) ++ed;\r",
            "    int len = ed - beg + 1;\r",
            "    ret.emplace_back(str[beg], len);\r",
            "    beg = ed + 1;\r",
            "  }\r",
            "  return ret;\r",
            "};\r",
            "\r",
            "template <class T>\r",
            "std::vector<std::pair<T, int>> RunLengthEncoding(const std::vector<T>& vec) {\r",
            "  std::vector<std::pair<T, int>> ret;\r",
            "  int sz = vec.size();\r",
            "  int beg = 0;\r",
            "  while (beg < sz) {\r",
            "    int ed = beg;\r",
            "    while (ed + 1 < sz && vec[beg] == vec[ed + 1]) ++ed;\r",
            "    int len = ed - beg + 1;\r",
            "    ret.emplace_back(vec[beg], len);\r",
            "    beg = ed + 1;\r",
            "  }\r",
            "  return ret;\r",
            "};\r"
        ]
    },
    "disjoint_sparse_table": {
        "prefix": "disjoint_sparse_table",
        "body": [
            "template <class T, class F>\r",
            "class DisjointSparseTable {\r",
            " public:\r",
            "  DisjointSparseTable(const std::vector<T>& data, F f)\r",
            "      : n_((int)data.size()), f_(f), data_(data) {\r",
            "    build();\r",
            "  }\r",
            "\r",
            "  // reutrn f_[l, r)\r",
            "  T get(int l, int r) {\r",
            "    if (l >= --r) return tab_[0][l];\r",
            "    int p = lookup_[l ^ r];\r",
            "    return f_(tab_[p][l], tab_[p][r]);\r",
            "  }\r",
            "\r",
            " private:\r",
            "  int n_;\r",
            "  F f_;\r",
            "  std::vector<T> data_;\r",
            "  std::vector<std::vector<T>> tab_;\r",
            "  std::vector<int> lookup_;\r",
            "\r",
            "  void build() {\r",
            "    int sz = 0;\r",
            "    while ((1 << sz) <= n_) ++sz;\r",
            "    tab_.assign(sz, std::vector<T>(n_, T{}));\r",
            "    for (int i = 0; i < n_; ++i) tab_[0][i] = data_[i];\r",
            "    for (int i = 1; i < sz; ++i) {\r",
            "      int shift = 1 << i;\r",
            "      for (int j = 0; j < n_; j += shift << 1) {\r",
            "        int t = std::min(j + shift, n_);\r",
            "        tab_[i][t - 1] = data_[t - 1];\r",
            "        for (int k = t - 2; k >= j; k--)\r",
            "          tab_[i][k] = f_(data_[k], tab_[i][k + 1]);\r",
            "        if (n_ <= t) break;\r",
            "        tab_[i][t] = data_[t];\r",
            "        int r = std::min(t + shift, n_);\r",
            "        for (int k = t + 1; k < r; k++)\r",
            "          tab_[i][k] = f_(tab_[i][k - 1], data_[k]);\r",
            "      }\r",
            "    }\r",
            "    lookup_.resize(1 << sz);\r",
            "    for (int i = 2; i < (int)lookup_.size(); ++i) {\r",
            "      lookup_[i] = lookup_[i >> 1] + 1;\r",
            "    }\r",
            "  }\r",
            "};\r"
        ]
    },
    "dual_segment_tree": {
        "prefix": "dual_segment_tree",
        "body": [
            "template <class OM, class F>\r",
            "class DualSegmentTree {\r",
            " public:\r",
            "  DualSegmentTree(const std::vector<OM>& data, OM oie, F f)\r",
            "      : oie_(oie), data_(data), f_(f) {\r",
            "    build();\r",
            "  }\r",
            "\r",
            "  // modify data_[l, r) -> f_(data_[l], val), ... , f_(data[r - 1], val)\r",
            "  void modify(int l, int r, OM val) {\r",
            "    thrust(l + n_);\r",
            "    thrust(r + n_ - 1);\r",
            "    for (l += n_, r += n_; l < r; l >>= 1, r >>= 1) {\r",
            "      if (l & 1) lazy_[l] = f_(lazy_[l], val), ++l;\r",
            "      if (r & 1) --r, lazy_[r] = f_(lazy_[r], val);\r",
            "    }\r",
            "  }\r",
            "\r",
            "  OM operator[](int pos) {\r",
            "    pos += n_;\r",
            "    thrust(pos);\r",
            "    return f_(data_[pos - n_], lazy_[pos]);\r",
            "  }\r",
            "\r",
            " private:\r",
            "  int n_, h_;\r",
            "  std::vector<OM> data_;\r",
            "  std::vector<OM> lazy_;\r",
            "  F f_;\r",
            "  OM oie_;\r",
            "\r",
            "  void build() {\r",
            "    int sz = data_.size();\r",
            "    n_ = 1;\r",
            "    h_ = 0;\r",
            "    while (n_ < sz) n_ <<= 1, ++h_;\r",
            "    lazy_.assign(2 * n_, oie_);\r",
            "  }\r",
            "\r",
            "  inline void propagate(int pos) {\r",
            "    if (lazy_[pos] != oie_) {\r",
            "      lazy_[2 * pos + 0] = f_(lazy_[2 * pos + 0], lazy_[pos]);\r",
            "      lazy_[2 * pos + 1] = f_(lazy_[2 * pos + 1], lazy_[pos]);\r",
            "      lazy_[pos] = oie_;\r",
            "    }\r",
            "  }\r",
            "\r",
            "  inline void thrust(int pos) {\r",
            "    for (int i = h_; i > 0; --i) propagate(pos >> i);\r",
            "  }\r",
            "};\r"
        ]
    },
    "fenwick_tree": {
        "prefix": "fenwick_tree",
        "body": [
            "template <class T>\r",
            "class FenwickTree {\r",
            " public:\r",
            "  FenwickTree(const std::vector<T>& data) : n_(data.size() + 1), data_(data) {\r",
            "    init();\r",
            "  }\r",
            "\r",
            "  void add(int pos, T val) {\r",
            "    ++pos;\r",
            "    while (pos < n_) {\r",
            "      node_[pos] += val;\r",
            "      pos += pos & -pos;\r",
            "    }\r",
            "  }\r",
            "\r",
            "  // return sum of [0, i]\r",
            "  T get(int pos) {\r",
            "    ++pos;\r",
            "    T sum = 0;\r",
            "    while (pos > 0) {\r",
            "      sum += node_[pos];\r",
            "      pos -= pos & -pos;\r",
            "    }\r",
            "    return sum;\r",
            "  }\r",
            "\r",
            "/*\r",
            "  // this code works faster\r",
            "  // return sum of [l, r)\r",
            "  T get(int l, int r) {\r",
            "    T sum = 0;\r",
            "    while (l < r) {\r",
            "      sum += node_[r];\r",
            "      r -= r & -r;\r",
            "    }\r",
            "    while (r < l) {\r",
            "      sum -= node_[l];\r",
            "      l -= l & -l;\r",
            "    }\r",
            "    return sum;\r",
            "  }\r",
            "*/\r",
            "\r",
            "  // return sum of [l, r]\r",
            "  T get(int l, int r) { return get(r) - get(l - 1); }\r",
            "\r",
            "  // return the first k where sum of [0, k] >= val\r",
            "  // use only when all element in data >= 0\r",
            "  int lower_bound(T val) {\r",
            "    if (val <= 0) return 0;\r",
            "    int pos = 0;\r",
            "    int k = 1;\r",
            "    while (k < n_ - 1) k <<= 1;\r",
            "    while (k > 0) {\r",
            "      if (pos + k <= n_ - 1 && node_[pos + k] < val) {\r",
            "        val -= node_[pos + k];\r",
            "        pos += k;\r",
            "      }\r",
            "      k >>= 1;\r",
            "    }\r",
            "    return pos;\r",
            "  }\r",
            "\r",
            " private:\r",
            "  int n_;\r",
            "  std::vector<T> data_;\r",
            "  std::vector<T> node_;\r",
            "  void init() {\r",
            "    node_.assign(n_ + 1, 0);\r",
            "    for (int i = 0; i < n_ - 1; ++i) add(i, data_[i]);\r",
            "  }\r",
            "};\r"
        ]
    },
    "fenwick_tree_2d": {
        "prefix": "fenwick_tree_2d",
        "body": [
            "template <class T>\r",
            "class FenwickTree2D {\r",
            " public:\r",
            "  FenwickTree2D(const std::vector<std::vector<T>>& vec)\r",
            "      : x_((int)vec.size()), y_((int)vec[0].size()), vec_(vec) {\r",
            "    build();\r",
            "  }\r",
            "\r",
            "  // add val to (x, y)\r",
            "  void add(int x, int y, T val) {\r",
            "    for (int i = x + 1; i < x_ + 1; i += i & -i) {\r",
            "      for (int j = y + 1; j < y_ + 1; j += j & -j) {\r",
            "        node_[i][j] += val;\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "\r",
            "  // return sum of [0, x] * [0, y]\r",
            "  T get(int x, int y) {\r",
            "    T sum = 0;\r",
            "    for (int i = x + 1; i > 0; i -= i & -i) {\r",
            "      for (int j = y + 1; j > 0; j -= j & -j) {\r",
            "        sum += node_[i][j];\r",
            "      }\r",
            "    }\r",
            "    return sum;\r",
            "  }\r",
            "\r",
            "  // return sum of [sx, gx] * [sy, gy] \r",
            "  T get(int sx, int sy, int gx, int gy) {\r",
            "    return get(gx, gy) - get(sx - 1, gy) - get(gx, sy - 1) +\r",
            "           get(sx - 1, sy - 1);\r",
            "  }\r",
            "\r",
            " private:\r",
            "  int x_;\r",
            "  int y_;\r",
            "  std::vector<std::vector<T>> vec_;\r",
            "  std::vector<std::vector<T>> node_;\r",
            "\r",
            "  void build() {\r",
            "    node_.assign(x_ + 1, std::vector<T>(y_ + 1, 0));\r",
            "    for (int i = 0; i < x_; ++i) {\r",
            "      for (int j = 0; j < y_; ++j) {\r",
            "        add(i, j, vec_[i][j]);\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "};\r"
        ]
    },
    "fenwick_tree_raq": {
        "prefix": "fenwick_tree_raq",
        "body": [
            "template <class T>\r",
            "class FenwickTreeRAQ {\r",
            " public:\r",
            "  FenwickTreeRAQ(const std::vector<T>& data)\r",
            "      : n_(data.size()),\r",
            "        ft1_(FenwickTree<T>(data)),\r",
            "        ft2_(FenwickTree<T>(data)) {}\r",
            "\r",
            "  // add val range [l, r)\r",
            "  void add(int l, int r, T val) {\r",
            "    add(ft1_, l, r, val);\r",
            "    add(ft2_, l, r, -val * (l - 1));\r",
            "    add(ft2_, r, n_, val * (r - l));\r",
            "  }\r",
            "\r",
            "  // get sum of [0, i]\r",
            "  T get(int pos) { return ft1_.get(pos) * pos + ft2_.get(pos); }\r",
            "\r",
            "  // get sum of [l, r]\r",
            "  T get(int l, int r) { return get(r) - get(l - 1); }\r",
            "\r",
            " private:\r",
            "  int n_;\r",
            "  FenwickTree<T> ft1_;\r",
            "  FenwickTree<T> ft2_;\r",
            "  void add(FenwickTree<T>& ft, int l, int r, T val) {\r",
            "    ft.add(l, val);\r",
            "    ft.add(r, -val);\r",
            "  }\r",
            "};\r"
        ]
    },
    "lazy_segment_tree": {
        "prefix": "lazy_segment_tree",
        "body": [
            "template <class M, class OM, class F1, class F2, class F3>\r",
            "class LazySegmentTree {\r",
            " public:\r",
            "  LazySegmentTree(const std::vector<M>& data, M ie, OM oie, F1 f1, F2 f2, F3 f3)\r",
            "      : ie_(ie), oie_(oie), data_(data), f1_(f1), f2_(f2), f3_(f3) {\r",
            "    build();\r",
            "  }\r",
            "\r",
            "  // modify data_[l, r) -> f3_(data_[l], val), ... , f3_(data[r - 1], val)\r",
            "  void modify(int l, int r, OM val) {\r",
            "    if (l >= r) return;\r",
            "    thrust(l += n_);\r",
            "    thrust(r += n_ - 1);\r",
            "    for (int cl = l, cr = r + 1; cl < cr; cl >>= 1, cr >>= 1) {\r",
            "      if (cl & 1) lazy_[cl] = f3_(lazy_[cl], val), ++cl;\r",
            "      if (cr & 1) --cr, lazy_[cr] = f3_(lazy_[cr], val);\r",
            "    }\r",
            "    recalc(l);\r",
            "    recalc(r);\r",
            "  }\r",
            "\r",
            "  // return f1_[l, r)\r",
            "  M get(int l, int r) {\r",
            "    if (l >= r) return ie_;\r",
            "    thrust(l + n_);\r",
            "    thrust(r + n_ - 1);\r",
            "    M vl = ie_, vr = ie_;\r",
            "    for (l += n_, r += n_; l < r; l >>= 1, r >>= 1) {\r",
            "      if (l & 1) vl = f1_(vl, apply(l++));\r",
            "      if (r & 1) vr = f1_(apply(--r), vr);\r",
            "    }\r",
            "    return f1_(vl, vr);\r",
            "  }\r",
            "\r",
            " private:\r",
            "  int n_, h_;\r",
            "  std::vector<M> data_;\r",
            "  std::vector<M> node_;\r",
            "  std::vector<OM> lazy_;\r",
            "  M ie_;\r",
            "  OM oie_;\r",
            "  F1 f1_;\r",
            "  F2 f2_;\r",
            "  F3 f3_;\r",
            "\r",
            "  void build() {\r",
            "    int sz = data_.size();\r",
            "    n_ = 1, h_ = 0;\r",
            "    while (n_ < sz) n_ <<= 1, ++h_;\r",
            "    node_.assign(2 * n_, ie_);\r",
            "    lazy_.assign(2 * n_, oie_);\r",
            "    for (int i = 0; i < sz; ++i) node_[i + n_] = data_[i];\r",
            "    for (int i = n_ - 1; i > 0; --i) node_[i] = f1_(node_[2 * i], node_[2 * i + 1]);\r",
            "  }\r",
            "\r",
            "  inline void propagate(int pos) {\r",
            "    if (lazy_[pos] != oie_) {\r",
            "      lazy_[2 * pos] = f3_(lazy_[2 * pos], lazy_[pos]);\r",
            "      lazy_[2 * pos + 1] = f3_(lazy_[2 * pos + 1], lazy_[pos]);\r",
            "      node_[pos] = apply(pos);\r",
            "      lazy_[pos] = oie_;\r",
            "    }\r",
            "  }\r",
            "\r",
            "  inline M apply(int pos) {\r",
            "    if (lazy_[pos] == oie_) {\r",
            "      return node_[pos];\r",
            "    } else {\r",
            "      return f2_(node_[pos], lazy_[pos]);\r",
            "    }\r",
            "  }\r",
            "\r",
            "  inline void recalc(int pos) {\r",
            "    while (pos >>= 1) node_[pos] = f1_(apply(2 * pos), apply(2 * pos + 1));\r",
            "  }\r",
            "\r",
            "  inline void thrust(int pos) {\r",
            "    for (int i = h_; i > 0; --i) propagate(pos >> i);\r",
            "  }\r",
            "};\r"
        ]
    },
    "segment_tree": {
        "prefix": "segment_tree",
        "body": [
            "template <class M, class F>\r",
            "class SegmentTree {\r",
            " public:\r",
            "  SegmentTree(const std::vector<M>& data, M ie, F f)\r",
            "      : ie_(ie), data_(data), f_(f) {\r",
            "    build();\r",
            "  }\r",
            "\r",
            "  void update(int pos, M val) {\r",
            "    assert(0 <= pos && pos < n_);\r",
            "    pos += n_;\r",
            "    node_[pos] = val;\r",
            "    while (pos > 0) {\r",
            "      pos >>= 1;\r",
            "      node_[pos] = f_(node_[2 * pos], node_[2 * pos + 1]);\r",
            "    }\r",
            "  }\r",
            "\r",
            "  // return f_[l, r)\r",
            "  // if l >= r, return ie_\r",
            "  M get(int l, int r) {\r",
            "    assert(0 <= l && l < n_ && 0 <= r && r < n_ + 1);\r",
            "    M vl = ie_, vr = ie_;\r",
            "    for (l += n_, r += n_; l < r; l >>= 1, r >>= 1) {\r",
            "      if (l & 1) vl = f_(vl, node_[l++]);\r",
            "      if (r & 1) vr = f_(node_[--r], vr);\r",
            "    }\r",
            "    return f_(vl, vr);\r",
            "  }\r",
            "\r",
            "  M operator[](int pos) const {\r",
            "    assert(0 <= pos && pos < n_);\r",
            "    return node_[n_ + pos];\r",
            "  }\r",
            "\r",
            "  // return f_[0, sz_)\r",
            "  M get_all() { return node_[1]; }\r",
            "\r",
            "  // return the maximum i that satisfies cond(i) == true, where i >= l\r",
            "  // if there is no such i, return sz_\r",
            "  template <class Condition>\r",
            "  int max_right(int l, Condition cond) {\r",
            "    assert(0 <= l && l <= sz_);\r",
            "    assert(cond(ie_));\r",
            "    if (l == sz_) return sz_;\r",
            "    l += n_;\r",
            "    M sm = ie_;\r",
            "\r",
            "    do {\r",
            "      while (~l & 1) l >>= 1;\r",
            "      if (!cond(f_(sm, node_[l]))) {\r",
            "        while (l < n_) {\r",
            "          l <<= 1;\r",
            "          if (cond(f_(sm, node_[l]))) {\r",
            "            sm = f_(sm, node_[l]);\r",
            "            ++l;\r",
            "          }\r",
            "        }\r",
            "        return l - n_;\r",
            "      }\r",
            "      sm = f_(sm, node_[l]);\r",
            "      ++l;\r",
            "    } while ((l & -l) != l);\r",
            "\r",
            "    return sz_;\r",
            "  }\r",
            "\r",
            "  // return the minimum i that satisfies cond(i) == true, where i <= r\r",
            "  // if there is no such i, return 0\r",
            "  // NOT VERIFIED!!\r",
            "  template <class Condition>\r",
            "  int min_left(int r, Condition cond) {\r",
            "    assert(0 <= r && r <= sz_);\r",
            "    assert(cond(ie_));\r",
            "    if (r == 0) return 0;\r",
            "    r += n_;\r",
            "    M sm = ie_;\r",
            "\r",
            "    do {\r",
            "      --r;\r",
            "      while (r > 1 && (r & 1)) r >>= 1;\r",
            "      if (!cond(f_(node_[r], sm))) {\r",
            "        while (r < n_) {\r",
            "          r = (2 * r + 1);\r",
            "          if (cond(f_(node_[r], sm))) {\r",
            "            sm = f_(node_[r], sm);\r",
            "            --r;\r",
            "          }\r",
            "        }\r",
            "        return r + 1 - n_;\r",
            "      }\r",
            "      sm = f_(node_[r], sm);\r",
            "    } while ((r & -r) != r);\r",
            "\r",
            "    return 0;\r",
            "  }\r",
            "\r",
            " private:\r",
            "  int n_;\r",
            "  int sz_;\r",
            "  M ie_;\r",
            "  std::vector<M> data_;\r",
            "  std::vector<M> node_;\r",
            "  F f_;\r",
            "\r",
            "  void build() {\r",
            "    sz_ = data_.size();\r",
            "    n_ = 1;\r",
            "    while (n_ < sz_) n_ <<= 1;\r",
            "    node_.assign(2 * n_, ie_);\r",
            "    for (int i = 0; i < sz_; ++i) node_[i + n_] = data_[i];\r",
            "    for (int i = n_ - 1; i > 0; --i) node_[i] = f_(node_[2 * i], node_[2 * i + 1]);\r",
            "  }\r",
            "};\r"
        ]
    },
    "sparse_table": {
        "prefix": "sparse_table",
        "body": [
            "template <class T, class F>\r",
            "class SparseTable {\r",
            "  // F must be idempotent function!\r",
            " public:\r",
            "  SparseTable(const std::vector<T>& data, F f)\r",
            "      : n_((int)data.size()), lg_(32 - __builtin_clz(n_)), f_(f), data_(data) {\r",
            "    build();\r",
            "  }\r",
            "\r",
            "  // return f_[l, r]\r",
            "  T get(int l, int r) {\r",
            "    assert(0 <= l && l <= r && r < n_);\r",
            "    int lg = 32 - __builtin_clz(r - l + 1) - 1;\r",
            "    return f_(tab_[lg][l], tab_[lg][r - (1 << lg) + 1]);\r",
            "  }\r",
            "\r",
            " private:\r",
            "  int n_;\r",
            "  int lg_;\r",
            "  F f_;\r",
            "  std::vector<T> data_;\r",
            "  std::vector<std::vector<T>> tab_;\r",
            "\r",
            "  void build() {\r",
            "    tab_.resize(lg_);\r",
            "    tab_[0] = data_;\r",
            "    for (int j = 1; j < lg_; ++j) {\r",
            "      tab_[j].resize(n_ - (1 << j) + 1);\r",
            "      for (int i = 0; i <= n_ - (1 << j); ++i) {\r",
            "        tab_[j][i] = f_(tab_[j - 1][i], tab_[j - 1][i + (1 << (j - 1))]);\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "};\r"
        ]
    },
    "unionfind_rank": {
        "prefix": "unionfind_rank",
        "body": [
            "class UnionFind {\r",
            " public:\r",
            "  UnionFind(int n) : n_(n) { init(); }\r",
            "\r",
            "  int root(int x) {\r",
            "    assert(0 <= x && x < n_);\r",
            "    if (par_[x] == -1)\r",
            "      return x;\r",
            "    else\r",
            "      return par_[x] = root(par_[x]);\r",
            "  }\r",
            "\r",
            "  bool same(int x, int y) {\r",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);\r",
            "    return root(x) == root(y);\r",
            "  }\r",
            "\r",
            "  void unite(int x, int y) {\r",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);\r",
            "    x = root(x);\r",
            "    y = root(y);\r",
            "    if (x == y) return;\r",
            "    if (rank_[x] < rank_[y]) std::swap(x, y);\r",
            "    if (rank_[x] == rank_[y]) ++rank_[x];\r",
            "    par_[y] = x;\r",
            "    return;\r",
            "  }\r",
            "\r",
            " private:\r",
            "  const int n_;\r",
            "  std::vector<int> par_;\r",
            "  std::vector<int> rank_;\r",
            "\r",
            "  void init() {\r",
            "    par_.assign(n_, -1);\r",
            "    rank_.assign(n_, 0);\r",
            "  }\r",
            "};\r"
        ]
    },
    "unionfind_size": {
        "prefix": "unionfind_size",
        "body": [
            "class UnionFind {\r",
            " public:\r",
            "  UnionFind(int n) : n_(n) { init(); }\r",
            "\r",
            "  int root(int x) {\r",
            "    assert(0 <= x && x < n_);\r",
            "    if (par_[x] < 0)\r",
            "      return x;\r",
            "    else\r",
            "      return par_[x] = root(par_[x]);\r",
            "  }\r",
            "\r",
            "  bool same(int x, int y) {\r",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);\r",
            "    return root(x) == root(y);\r",
            "  }\r",
            "\r",
            "  void unite(int x, int y) {\r",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);\r",
            "    x = root(x);\r",
            "    y = root(y);\r",
            "    if (x == y) return;\r",
            "    if (par_[x] > par_[y]) std::swap(x, y);\r",
            "    par_[x] += par_[y];\r",
            "    par_[y] = x;\r",
            "    return;\r",
            "  }\r",
            "\r",
            "  int size(int x) {\r",
            "    assert(0 <= x && x < n_);\r",
            "    return -par_[root(x)];\r",
            "  }\r",
            "\r",
            " private:\r",
            "  const int n_;\r",
            "  std::vector<int> par_;\r",
            "\r",
            "  void init() { par_.assign(n_, -1); }\r",
            "};\r"
        ]
    },
    "unionfind_weighted": {
        "prefix": "unionfind_weighted",
        "body": [
            "class UnionFind {\r",
            " public:\r",
            "  UnionFind(int n, int SUM_UNITY = 0) : n_(n), SUM_UNITY_(SUM_UNITY) {\r",
            "    init();\r",
            "  }\r",
            "\r",
            "  int root(int x) {\r",
            "    assert(0 <= x && x < n_);\r",
            "    if (par_[x] == -1) {\r",
            "      return x;\r",
            "    } else {\r",
            "      int r = root(par_[x]);\r",
            "      diff_weight_[x] += diff_weight_[par_[x]];\r",
            "      return par_[x] = r;\r",
            "    }\r",
            "  }\r",
            "\r",
            "  int weight(int x) {\r",
            "    assert(0 <= x && x < n_);\r",
            "    root(x);\r",
            "    return diff_weight_[x];\r",
            "  }\r",
            "\r",
            "  bool same(int x, int y) {\r",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);\r",
            "    return root(x) == root(y);\r",
            "  }\r",
            "\r",
            "  // y is w larger than x\r",
            "  void unite(int x, int y, int w) {\r",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);\r",
            "    w += weight(x);\r",
            "    w -= weight(y);\r",
            "    x = root(x);\r",
            "    y = root(y);\r",
            "    if (x == y) return;\r",
            "    if (rank_[x] < rank_[y]) {\r",
            "      std::swap(x, y);\r",
            "      w = -w;\r",
            "    }\r",
            "    if (rank_[x] == rank_[y]) ++rank_[x];\r",
            "    par_[y] = x;\r",
            "    diff_weight_[y] = w;\r",
            "    return;\r",
            "  }\r",
            "\r",
            "  int diff(int x, int y) {\r",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);\r",
            "    return weight(y) - weight(x);\r",
            "  }\r",
            "\r",
            " private:\r",
            "  const int n_;\r",
            "  const int SUM_UNITY_;\r",
            "  std::vector<int> par_;\r",
            "  std::vector<int> rank_;\r",
            "  std::vector<int> diff_weight_;\r",
            "\r",
            "  void init() {\r",
            "    par_.assign(n_, -1);\r",
            "    rank_.assign(n_, 0);\r",
            "    diff_weight_.assign(n_, SUM_UNITY_);\r",
            "  }\r",
            "};\r"
        ]
    },
    "debug": {
        "prefix": "debug",
        "body": [
            "template <class T, class U>\r",
            "std::ostream& operator<<(std::ostream& os, const std::pair<T, U>& p) {\r",
            "  return os << '(' << p.first << \", \" << p.second << ')';\r",
            "}\r",
            "\r",
            "template <class Tuple, std::size_t... Is>\r",
            "void tuple_out(std::ostream& os, const Tuple& tp, std::index_sequence<Is...>) {\r",
            "  ((os << (Is ? \", \" : \"(\") << std::get<Is>(tp)), ...) << \")\";\r",
            "}\r",
            "\r",
            "template <class... Args>\r",
            "std::ostream& operator<<(std::ostream& os, const std::tuple<Args...>& tp) {\r",
            "  tuple_out(os, tp, std::index_sequence_for<Args...>{});\r",
            "  return os;\r",
            "}\r",
            "\r",
            "template <class T>\r",
            "std::ostream& operator<<(std::ostream& os, const std::vector<T>& vec) {\r",
            "  int n = 0;\r",
            "  for (auto e : vec) os << (n++ ? \", \" : \"{\") << e;\r",
            "  return os << (n ? \"}\" : \"{}\");\r",
            "}\r",
            "\r",
            "template <class T, class Compare>\r",
            "std::ostream& operator<<(std::ostream& os, const std::set<T, Compare>& st) {\r",
            "  int n = 0;\r",
            "  for (auto e : st) os << (n++ ? \", \" : \"{\") << e;\r",
            "  return os << (n ? \"}\" : \"{}\");\r",
            "}\r",
            "\r",
            "template <class T, class U, class Compare>\r",
            "std::ostream& operator<<(std::ostream& os, const std::map<T, U, Compare>& mp) {\r",
            "  int n = 0;\r",
            "  for (auto e : mp) os << (n++ ? \", \" : \"{\") << e;\r",
            "  return os << (n ? \"}\" : \"{}\");\r",
            "}\r",
            "\r",
            "#ifdef LOCAL\r",
            "#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]: \", debug_out(__VA_ARGS__)\r",
            "#else\r",
            "#define debug(...) void(0)\r",
            "#endif\r",
            "\r",
            "void debug_out() { std::cerr << '\\n'; }\r",
            "\r",
            "template <class Head, class... Tail>\r",
            "void debug_out(Head&& head, Tail&&... tail) {\r",
            "  std::cerr << head;\r",
            "  if (sizeof...(Tail) != 0) std::cerr << \", \";\r",
            "  debug_out(std::forward<Tail>(tail)...);\r",
            "}\r"
        ]
    },
    "fastio": {
        "prefix": "fastio",
        "body": [
            "namespace FastIO {\r",
            "class Scanner {\r",
            "  static constexpr int buf_size = (1 << 18);\r",
            "  static constexpr int integer_size = 20;\r",
            "  static constexpr int string_size = 1000; // the maximum possible size of input string\r",
            "  char buf[buf_size] = {};\r",
            "  char *cur = buf, *ed = buf;\r",
            "\r",
            " public:\r",
            "  Scanner() {}\r",
            "\r",
            "  template <class T>\r",
            "  inline Scanner& operator>>(T& val) {\r",
            "    read(val);\r",
            "    return *this;\r",
            "  }\r",
            "\r",
            " private:\r",
            "\r",
            "  // TO DO : memmove -> memcpy\r",
            "  inline void reload() {\r",
            "    size_t len = ed - cur;\r",
            "    memmove(buf, cur, len);\r",
            "    char* tmp = buf + len;\r",
            "    ed = tmp + fread(tmp, 1, buf_size - len, stdin);\r",
            "    *ed = 0;\r",
            "    cur = buf;\r",
            "  }\r",
            "\r",
            "  inline void skip_space() {\r",
            "    while (true) {\r",
            "      if (cur == ed) reload();\r",
            "      while (*cur == ' ' || *cur == '\\n') ++cur;\r",
            "      if (__builtin_expect(cur != ed, 1)) return;\r",
            "    }\r",
            "  }\r",
            "\r",
            "  template <class T, std::enable_if_t<std::is_same<T, int>::value, int> = 0>\r",
            "  inline void read(T& num) {\r",
            "    skip_space();\r",
            "    if (cur + integer_size >= ed) reload();\r",
            "    bool neg = false;\r",
            "    num = 0;\r",
            "    if (*cur == '-') neg = true, ++cur;\r",
            "    while (*cur >= '0') num = num * 10 + (*cur & 15), ++cur;\r",
            "    if (neg) num = -num;\r",
            "  }\r",
            "\r",
            "  template <class T, std::enable_if_t<std::is_same<T, int64>::value, int> = 0>\r",
            "  inline void read(T& num) {\r",
            "    skip_space();\r",
            "    if (cur + integer_size >= ed) reload();\r",
            "    bool neg = false;\r",
            "    num = 0;\r",
            "    if (*cur == '-') neg = true, ++cur;\r",
            "    while (*cur >= '0') num = num * 10 + (*cur & 15), ++cur;\r",
            "    if (neg) num = -num;\r",
            "  }\r",
            "\r",
            "  template <class T,\r",
            "            std::enable_if_t<std::is_same<T, std::string>::value, int> = 0>\r",
            "  inline void read(T& str) {\r",
            "    skip_space();\r",
            "    if (cur + str.size() >= ed) reload();\r",
            "    auto it = cur;\r",
            "    while (!(*cur == ' ' || *cur == '\\n')) ++cur;\r",
            "    str = std::string(it, cur);\r",
            "  }\r",
            "\r",
            "  template <class T, std::enable_if_t<std::is_same<T, char>::value, int> = 0>\r",
            "  inline void read(T& c) {\r",
            "    skip_space();\r",
            "    if (cur + 1 >= ed) reload();\r",
            "    c = *cur, ++cur;\r",
            "  }\r",
            "\r",
            "  template <class T, std::enable_if_t<std::is_same<T, double>::value, int> = 0>\r",
            "  inline void read(T& num) {\r",
            "    skip_space();\r",
            "    if (cur + integer_size >= ed) reload();\r",
            "    bool neg = false;\r",
            "    num = 0;\r",
            "    if (*cur == '-') neg = true, ++cur;\r",
            "    while (*cur >= '0' && *cur <= '9') num = num * 10 + (*cur & 15), ++cur;\r",
            "    if (*cur != '.') return;\r",
            "    ++cur;\r",
            "    T base = 0.1;\r",
            "    while (*cur >= '0' && *cur <= '9') {\r",
            "      num += base * (*cur ^ 48);\r",
            "      ++cur;\r",
            "      base *= 0.1;\r",
            "    }\r",
            "    if (neg) num = -num;\r",
            "  }\r",
            "\r",
            "  template <class T,\r",
            "            std::enable_if_t<std::is_same<T, long double>::value, int> = 0>\r",
            "  inline void read(T& num) {\r",
            "    skip_space();\r",
            "    if (cur + integer_size >= ed) reload();\r",
            "    bool neg = false;\r",
            "    num = 0;\r",
            "    if (*cur == '-') neg = true, ++cur;\r",
            "    while (*cur >= '0' && *cur <= '9') num = num * 10 + (*cur & 15), ++cur;\r",
            "    if (*cur != '.') return;\r",
            "    ++cur;\r",
            "    T base = 0.1;\r",
            "    while (*cur >= '0' && *cur <= '9') {\r",
            "      num += base * (*cur ^ 48);\r",
            "      ++cur;\r",
            "      base *= 0.1;\r",
            "    }\r",
            "    if (neg) num = -num;\r",
            "  }\r",
            "\r",
            "  template <class T>\r",
            "  inline void read(std::vector<T>& vec) {\r",
            "    for (T& e : vec) read(e);\r",
            "  }\r",
            "\r",
            "  template <class T, class U>\r",
            "  inline void read(std::pair<T, U>& p) {\r",
            "    read(p.first, p.second);\r",
            "  }\r",
            "\r",
            "  template <class Tuple, std::size_t... Is>\r",
            "  inline void tuple_scan(Tuple& tp, std::index_sequence<Is...>) {\r",
            "    (read(std::get<Is>(tp)), ...);\r",
            "  }\r",
            "\r",
            "  template <class... Args>\r",
            "  inline void read(std::tuple<Args...>& tp) {\r",
            "    tuple_scan(tp, std::index_sequence_for<Args...>{});\r",
            "  }\r",
            "\r",
            "  inline void read() {}\r",
            "\r",
            "  template <class Head, class... Tail>\r",
            "  inline void read(Head&& head, Tail&&... tail) {\r",
            "    read(head);\r",
            "    read(std::forward<Tail>(tail)...);\r",
            "  }\r",
            "};\r",
            "\r",
            "class Printer {\r",
            "  static constexpr int buf_size = (1 << 18);\r",
            "  static constexpr int integer_size = 20;\r",
            "  static constexpr int string_size = (1 << 6);\r",
            "  static constexpr int margin = 1;\r",
            "  static constexpr int n = 10000;\r",
            "  char buf[buf_size + margin] = {};\r",
            "  char table[n * 4] = {};\r",
            "  char* cur = buf;\r",
            "\r",
            " public:\r",
            "  Printer() { build(); }\r",
            "\r",
            "  ~Printer() { flush(); }\r",
            "\r",
            "  template <class T>\r",
            "  inline Printer& operator<<(T val) {\r",
            "    write(val);\r",
            "    return *this;\r",
            "  }\r",
            "\r",
            "  template<class T>\r",
            "  inline void println(T val) {\r",
            "    write(val);\r",
            "    write('\\n');\r",
            "  }\r",
            "\r",
            " private:\r",
            "  void build() {\r",
            "    constexpr int base = 10;\r",
            "    for (int i = 0; i < n; ++i) {\r",
            "      int tmp = i;\r",
            "      for (int j = 3; j >= 0; --j) {\r",
            "        table[i * 4 + j] = tmp % base | 48;\r",
            "        tmp /= base;\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "\r",
            "  inline void flush() {\r",
            "    fwrite(buf, 1, cur - buf, stdout);\r",
            "    cur = buf;\r",
            "  }\r",
            "\r",
            "  template <class T, std::enable_if_t<std::is_same<T, int>::value, int> = 0>\r",
            "  inline int get_digit(T n) {\r",
            "    if (n >= (int)1e5) {\r",
            "      if (n >= (int)1e8) return 9;\r",
            "      if (n >= (int)1e7) return 8;\r",
            "      if (n >= (int)1e6) return 7;\r",
            "      return 6;\r",
            "    } else {\r",
            "      if (n >= (int)1e4) return 5;\r",
            "      if (n >= (int)1e3) return 4;\r",
            "      if (n >= (int)1e2) return 3;\r",
            "      if (n >= (int)1e1) return 2;\r",
            "      return 1;\r",
            "    }\r",
            "  }\r",
            "\r",
            "  template <class T, std::enable_if_t<std::is_same<T, int64>::value, int> = 0>\r",
            "  inline int get_digit(T n) {\r",
            "    if (n >= (int64)1e10) {\r",
            "      if (n >= (int64)1e14) {\r",
            "        if (n >= (int64)1e18) return 19;\r",
            "        if (n >= (int64)1e17) return 18;\r",
            "        if (n >= (int64)1e16) return 17;\r",
            "        if (n >= (int64)1e15) return 16;\r",
            "        return 15;\r",
            "      } else {\r",
            "        if (n >= (int64)1e14) return 15;\r",
            "        if (n >= (int64)1e13) return 14;\r",
            "        if (n >= (int64)1e12) return 13;\r",
            "        if (n >= (int64)1e11) return 12;\r",
            "        return 11;\r",
            "      }\r",
            "    } else {\r",
            "      if (n >= (int64)1e5) {\r",
            "        if (n >= (int64)1e9) return 10;\r",
            "        if (n >= (int64)1e8) return 9;\r",
            "        if (n >= (int64)1e7) return 8;\r",
            "        if (n >= (int64)1e6) return 7;\r",
            "        return 6;\r",
            "      } else {\r",
            "        if (n >= (int64)1e4) return 5;\r",
            "        if (n >= (int64)1e3) return 4;\r",
            "        if (n >= (int64)1e2) return 3;\r",
            "        if (n >= (int64)1e1) return 2;\r",
            "        return 1;\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "\r",
            "  template <class T, std::enable_if_t<std::is_same<T, int>::value, int> = 0>\r",
            "  inline void write(T num) {\r",
            "    if (__builtin_expect(cur + integer_size >= buf + buf_size, 0)) flush();\r",
            "    if (num == 0) {\r",
            "      write('0');\r",
            "      return;\r",
            "    }\r",
            "    if (num < 0) {\r",
            "      write('-');\r",
            "      num = -num;\r",
            "    }\r",
            "    int len = get_digit(num);\r",
            "    int digits = len;\r",
            "    while (num >= n) {\r",
            "      memcpy(cur + len - 4, table + (num % n) * 4, 4);\r",
            "      num /= n;\r",
            "      len -= 4;\r",
            "    }\r",
            "    memcpy(cur, table + num * 4 + (4 - len), len);\r",
            "    cur += digits;\r",
            "  }\r",
            "\r",
            "  template <class T, std::enable_if_t<std::is_same<T, int64>::value, int> = 0>\r",
            "  inline void write(T num) {\r",
            "    if (__builtin_expect(cur + integer_size >= buf + buf_size, 0)) flush();\r",
            "    if (num == 0) {\r",
            "      write('0');\r",
            "      return;\r",
            "    }\r",
            "    if (num < 0) {\r",
            "      write('-');\r",
            "      num = -num;\r",
            "    }\r",
            "    int len = get_digit(num);\r",
            "    int digits = len;\r",
            "    while (num >= n) {\r",
            "      memcpy(cur + len - 4, table + (num % n) * 4, 4);\r",
            "      num /= n;\r",
            "      len -= 4;\r",
            "    }\r",
            "    memcpy(cur, table + num * 4 + (4 - len), len);\r",
            "    cur += digits;\r",
            "  }\r",
            "\r",
            "  template <class T, std::enable_if_t<std::is_same<T, char>::value, int> = 0>\r",
            "  inline void write(T c) {\r",
            "    if (__builtin_expect(cur + 1 >= buf + buf_size, 0)) flush();\r",
            "    *cur = c;\r",
            "    ++cur;\r",
            "  }\r",
            "\r",
            "  template <class T,\r",
            "            std::enable_if_t<std::is_same<T, std::string>::value, int> = 0>\r",
            "  inline void write(T str) {\r",
            "    if (__builtin_expect(cur + str.size() >= buf + buf_size, 0)) flush();\r",
            "    for (char c : str) write(c);\r",
            "  }\r",
            "\r",
            "  template <class T,\r",
            "            std::enable_if_t<std::is_same<T, const char*>::value, int> = 0>\r",
            "  inline void write(T str) {\r",
            "    if (__builtin_expect(cur + string_size >= buf + buf_size, 0)) flush();\r",
            "    for (int i = 0; str[i]; ++i) write(str[i]);\r",
            "  }\r",
            "};\r",
            "}  // namespace FastIO\r",
            "\r",
            "FastIO::Scanner fin;\r",
            "FastIO::Printer fout;\r"
        ]
    },
    "int128": {
        "prefix": "int128",
        "body": [
            "using int128 = __int128_t;\r",
            "\r",
            "std::istream& operator>>(std::istream& is, int128& val) {\r",
            "  std::string str;\r",
            "  is >> str;\r",
            "  val = 0;\r",
            "  bool neg = false;\r",
            "  int sz = str.size();\r",
            "  for (int i = 0; i < sz; ++i) {\r",
            "    if (!i && str[i] == '-') {\r",
            "      neg = true;\r",
            "    } else {\r",
            "      val = val * 10 + (str[i] & 15);\r",
            "    }\r",
            "  }\r",
            "  if (neg) val = -val;\r",
            "  return is;\r",
            "}\r",
            "\r",
            "std::ostream& operator<<(std::ostream& os, const int128& val) {\r",
            "  if (!val) return os << '0';\r",
            "  int128 t = val;\r",
            "  if (val < 0) {\r",
            "    os << '-';\r",
            "    t = -t;\r",
            "  }\r",
            "  std::string str = \"\";\r",
            "  while (t) {\r",
            "    str += (char)(t % 10 | 48);\r",
            "    t /= 10;\r",
            "  }\r",
            "  std::reverse(str.begin(), str.end());\r",
            "  return os << str;\r",
            "}\r",
            "\r",
            "int128 to_int128(const std::string& str) {\r",
            "  int sz = str.size();\r",
            "  int128 val = 0;\r",
            "  bool neg = false;\r",
            "  for (int i = 0; i < sz; ++i) {\r",
            "    if (!i && str[i] == '-') {\r",
            "      neg = true;\r",
            "    } else {\r",
            "      val = val * 10 + (str[i] & 15);\r",
            "    }\r",
            "  }\r",
            "  if (neg) val = -val;\r",
            "  return val;\r",
            "}\r",
            "\r",
            "int128 to_int128(const char* str) {\r",
            "  int128 val = 0;\r",
            "  bool neg = false;\r",
            "  for (int i = 0; str[i]; ++i) {\r",
            "    if (!i && str[i] == '-') {\r",
            "      neg = true;\r",
            "    } else {\r",
            "      val = val * 10 + (str[i] & 15);\r",
            "    }\r",
            "  }\r",
            "  if (neg) val = -val;\r",
            "  return val;\r",
            "}\r",
            "\r",
            "std::string to_string(const int128& val) {\r",
            "  std::string str = \"\";\r",
            "  int128 t = val;\r",
            "  bool neg = false;\r",
            "  if (t < 0) {\r",
            "    neg = true;\r",
            "    t = -t;\r",
            "  }\r",
            "  while (t) {\r",
            "    str += (char)(t % 10 | 48);\r",
            "    t /= 10;\r",
            "  }\r",
            "  if (neg) str += '-';\r",
            "  std::reverse(str.begin(), str.end());\r",
            "  return str;\r",
            "}\r"
        ]
    },
    "kyomukyomuio": {
        "prefix": "kyomukyomuio",
        "body": [
            "namespace kyomukyomuIO {\r",
            "class Scanner {\r",
            "  static constexpr int sz = 1 << 18;\r",
            "  char buf[sz];\r",
            "  char* cur = buf;\r",
            "\r",
            " public:\r",
            "  Scanner() { fread(buf, 1, sz, stdin); }\r",
            "  template <class T>\r",
            "  inline Scanner& operator>>(T& val) {\r",
            "    read(val);\r",
            "    return *this;\r",
            "  }\r",
            "\r",
            " private:\r",
            "  inline void reload() {\r",
            "    int res = sz - (cur - buf);\r",
            "    memcpy(buf, cur, res);\r",
            "    fread(buf + res, 1, sz - res, stdin);\r",
            "    cur = buf;\r",
            "  }\r",
            "\r",
            "  inline void skip() {\r",
            "    while (*cur == ' ' || *cur == '\\n') ++cur;\r",
            "  }\r",
            "\r",
            "  inline void read(int& num) {\r",
            "    skip();\r",
            "    if (cur + 20 >= buf + sz) reload();\r",
            "    cur = const_cast<char*>(std::from_chars(cur, cur + 20, num).ptr);\r",
            "  }\r",
            "\r",
            "  inline void read(int64& num) {\r",
            "    skip();\r",
            "    if (cur + 20 >= buf + sz) reload();\r",
            "    cur = const_cast<char*>(std::from_chars(cur, cur + 20, num).ptr);\r",
            "  }\r",
            "};\r",
            "\r",
            "class Printer {\r",
            "  static constexpr int sz = 1 << 18;\r",
            "  char buf[sz];\r",
            "  char* cur = buf;\r",
            "\r",
            " public:\r",
            "  Printer() {}\r",
            "\r",
            "  ~Printer() { flush(); }\r",
            "\r",
            "  void flush() {\r",
            "    fwrite(buf, 1, cur - buf, stdout);\r",
            "    cur = buf;\r",
            "  }\r",
            "\r",
            "  template <class T>\r",
            "  inline Printer& operator<<(T val) {\r",
            "    write(val);\r",
            "    return *this;\r",
            "  }\r",
            "\r",
            "  template <class T>\r",
            "  inline void println(T val) {\r",
            "    write(val);\r",
            "    write('\\n');\r",
            "  }\r",
            "\r",
            " private:\r",
            "  inline void write(int num) {\r",
            "    if (cur + 20 >= buf + sz) flush();\r",
            "    cur = std::to_chars(cur, cur + 20, num).ptr;\r",
            "  }\r",
            "\r",
            "  inline void write(int64 num) {\r",
            "    if (cur + 20 >= buf + sz) flush();\r",
            "    cur = std::to_chars(cur, cur + 20, num).ptr;\r",
            "  }\r",
            "\r",
            "  inline void write(char c) {\r",
            "    if (cur + 1 >= buf + sz) flush();\r",
            "    *cur = c;\r",
            "    ++cur;\r",
            "  }\r",
            "\r",
            "  inline void write(std::string str) {\r",
            "    if (cur + str.size() >= buf + sz) flush();\r",
            "    for (char c : str) *cur = c, ++cur;\r",
            "  }\r",
            "\r",
            "  inline void write(const char* str) {\r",
            "    if (cur + strlen(str) >= buf + sz) flush();\r",
            "    for (int i = 0; str[i]; ++i) *cur = str[i], ++cur;\r",
            "  }\r",
            "};\r",
            "}  // namespace kyomukyomuIO\r",
            "\r",
            "kyomukyomuIO::Scanner kin;\r",
            "kyomukyomuIO::Printer kout;\r"
        ]
    },
    "modint": {
        "prefix": "modint",
        "body": [
            "template <typename T>\r",
            "class Modular {\r",
            " public:\r",
            "  using Type = typename decay<decltype(T::value)>::type;\r",
            "\r",
            "  constexpr Modular() : value() {}\r",
            "  template <typename U>\r",
            "  Modular(const U& x) {\r",
            "    value = normalize(x);\r",
            "  }\r",
            "\r",
            "  template <typename U>\r",
            "  static Type normalize(const U& x) {\r",
            "    Type v;\r",
            "    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);\r",
            "    else v = static_cast<Type>(x % mod());\r",
            "    if (v < 0) v += mod();\r",
            "    return v;\r",
            "  }\r",
            "\r",
            "  const Type& operator()() const { return value; }\r",
            "  template <typename U>\r",
            "  explicit operator U() const { return static_cast<U>(value); }\r",
            "  constexpr static Type mod() { return T::value; }\r",
            "\r",
            "  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }\r",
            "  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }\r",
            "  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }\r",
            "  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }\r",
            "  Modular& operator++() { return *this += 1; }\r",
            "  Modular& operator--() { return *this -= 1; }\r",
            "  Modular operator++(int) { Modular result(*this); *this += 1; return result; }\r",
            "  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }\r",
            "  Modular operator-() const { return Modular(-value); }\r",
            "\r",
            "  template <typename U = T>\r",
            "  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {\r",
            "  #ifdef _WIN32\r",
            "    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);\r",
            "    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;\r",
            "    asm(\r",
            "      \"divl %4; \\n\\t\"\r",
            "      : \"=a\" (d), \"=d\" (m)\r",
            "      : \"d\" (xh), \"a\" (xl), \"r\" (mod())\r",
            "    );\r",
            "    value = m;\r",
            "  #else\r",
            "    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));\r",
            "  #endif\r",
            "    return *this;\r",
            "  }\r",
            "  template <typename U = T>\r",
            "  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {\r",
            "    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());\r",
            "    value = normalize(value * rhs.value - q * mod());\r",
            "    return *this;\r",
            "  }\r",
            "  template <typename U = T>\r",
            "  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {\r",
            "    value = normalize(value * rhs.value);\r",
            "    return *this;\r",
            "  }\r",
            "\r",
            "  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }\r",
            "\r",
            "  template <typename U>\r",
            "  friend const Modular<U>& abs(const Modular<U>& v) { return v; }\r",
            "\r",
            "  template <typename U>\r",
            "  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);\r",
            "\r",
            "  template <typename U>\r",
            "  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);\r",
            "\r",
            "  template <typename U>\r",
            "  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);\r",
            "\r",
            " private:\r",
            "  Type value;\r",
            "};\r",
            "\r",
            "template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }\r",
            "template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }\r",
            "template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }\r",
            "\r",
            "template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\r",
            "template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }\r",
            "template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }\r",
            "\r",
            "template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }\r",
            "\r",
            "template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\r",
            "template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }\r",
            "template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }\r",
            "\r",
            "template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\r",
            "template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }\r",
            "template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }\r",
            "\r",
            "template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\r",
            "template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }\r",
            "template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }\r",
            "\r",
            "template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\r",
            "template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }\r",
            "template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }\r",
            "\r",
            "template<typename T, typename U>\r",
            "Modular<T> power(const Modular<T>& a, const U& b) {\r",
            "  assert(b >= 0);\r",
            "  Modular<T> x = a, res = 1;\r",
            "  U p = b;\r",
            "  while (p > 0) {\r",
            "    if (p & 1) res *= x;\r",
            "    x *= x;\r",
            "    p >>= 1;\r",
            "  }\r",
            "  return res;\r",
            "}\r",
            "\r",
            "template <typename T>\r",
            "bool IsZero(const Modular<T>& number) {\r",
            "  return number() == 0;\r",
            "}\r",
            " \r",
            "template <typename T>\r",
            "std::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {\r",
            "  return stream << number();\r",
            "}\r",
            "\r",
            "template <typename T>\r",
            "std::istream& operator>>(std::istream& stream, Modular<T>& number) {\r",
            "  typename common_type<typename Modular<T>::Type, int64_t>::type x;\r",
            "  stream >> x;\r",
            "  number.value = Modular<T>::normalize(x);\r",
            "  return stream;\r",
            "}\r",
            "\r",
            "/*\r",
            "using ModType = int;\r",
            "\r",
            "struct VarMod { static ModType value; };\r",
            "ModType VarMod::value;\r",
            "ModType& MOD = VarMod::value;\r",
            "using Mint = Modular<VarMod>;\r",
            "*/\r",
            "\r",
            "constexpr int MOD = (int) 1e9 + 7;\r",
            "using Mint = Modular<std::integral_constant<std::decay<decltype(MOD)>::type, MOD>>;\r"
        ]
    },
    "pbds_tree": {
        "prefix": "pbds_tree",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>\r",
            "#include <ext/pb_ds/tree_policy.hpp>\r",
            "#include <ext/pb_ds/tag_and_trait.hpp>\r",
            "\r",
            "template<class T> \r",
            "using pbds_tree = __gnu_pbds::tree<T, __gnu_pbds::null_type, std::less<T>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;\r"
        ]
    },
    "template": {
        "prefix": "template",
        "body": [
            "#pragma region kyomukyomupurin\r",
            "\r",
            "/**\r",
            " *    author  : \ud835\udc8c\ud835\udc9a\ud835\udc90\ud835\udc8e\ud835\udc96\ud835\udc8c\ud835\udc9a\ud835\udc90\ud835\udc8e\ud835\udc96\ud835\udc91\ud835\udc96\ud835\udc93\ud835\udc8a\ud835\udc8f\r",
            " *    created : $CURRENT_YEAR-$CURRENT_MONTH-$CURRENT_DATE $CURRENT_HOUR:$CURRENT_MINUTE:$CURRENT_SECOND\r",
            " **/\r",
            "\r",
            "#include <algorithm>\r",
            "#include <bitset>\r",
            "#include <cassert>\r",
            "#include <cctype>\r",
            "#include <charconv>\r",
            "#include <chrono>\r",
            "#include <cmath>\r",
            "#include <complex>\r",
            "#include <cstring>\r",
            "#include <deque>\r",
            "#include <iomanip>\r",
            "#include <iostream>\r",
            "#include <map>\r",
            "#include <numeric>\r",
            "#include <queue>\r",
            "#include <random>\r",
            "#include <set>\r",
            "#include <stack>\r",
            "#include <string>\r",
            "#include <tuple>\r",
            "#include <utility>\r",
            "#include <vector>\r",
            "\r",
            "using namespace std;\r",
            "\r",
            "using int64 = long long;\r",
            "\r",
            "template <class T>\r",
            "inline int lower_position(const std::vector<T>& vec, T val) {\r",
            "  return std::distance(vec.begin(),\r",
            "                       std::lower_bound(vec.begin(), vec.end(), val));\r",
            "}\r",
            "\r",
            "template <class T>\r",
            "inline int upper_position(const std::vector<T>& vec, T val) {\r",
            "  return std::distance(vec.begin(),\r",
            "                       std::upper_bound(vec.begin(), vec.end(), val));\r",
            "}\r",
            "\r",
            "template <class T>\r",
            "inline std::vector<int> compressed(const std::vector<T>& vec) {\r",
            "  std::vector<T> t = vec;\r",
            "  std::sort(t.begin(), t.end());\r",
            "  t.erase(std::unique(t.begin(), t.end()), t.end());\r",
            "  std::vector<int> compressed(vec.size());\r",
            "  for (size_t i = 0; i < vec.size(); ++i)\r",
            "    compressed[i] =\r",
            "        std::distance(t.begin(), std::lower_bound(t.begin(), t.end(), vec[i]));\r",
            "  return compressed;\r",
            "}\r",
            "\r",
            "template <class T>\r",
            "inline std::string to_binary(T n) {\r",
            "  assert(n > 0);\r",
            "  std::string ret = \"\";\r",
            "  while (n) ret += (n & 1) ? '1' : '0', n >>= 1;\r",
            "  std::reverse(ret.begin(), ret.end());\r",
            "  return ret;\r",
            "}\r",
            "\r",
            "template <class T>\r",
            "inline void println(T val) {\r",
            "  std::cout << val << '\\n';\r",
            "}\r",
            "\r",
            "inline void println(double val) {\r",
            "  std::cout << std::fixed << std::setprecision(17) << val << '\\n';\r",
            "}\r",
            "\r",
            "inline void println(long double val) {\r",
            "  std::cout << std::fixed << std::setprecision(17) << val << '\\n';\r",
            "}\r",
            "\r",
            "template <class T>\r",
            "inline void println(const std::vector<T>& vec, const char del = ' ') {\r",
            "  bool first = true;\r",
            "  for (T e : vec) {\r",
            "    if (!first) std::cout << del;\r",
            "    first = false;\r",
            "    std::cout << e;\r",
            "  } \r",
            "  std::cout << '\\n';\r",
            "}\r",
            "\r",
            "inline void Yes(bool cond) {\r",
            "  println(cond ? \"Yes\" : \"No\");\r",
            "}\r",
            "\r",
            "inline void YES(bool cond) {\r",
            "  println(cond ? \"YES\" : \"NO\");\r",
            "}\r",
            "\r",
            "template <class T>\r",
            "using binary_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\r",
            "\r",
            "template <class T>\r",
            "std::istream& operator>>(std::istream& is, std::vector<T>& vec) {\r",
            "  for (T& e : vec) is >> e;\r",
            "  return is;\r",
            "}\r",
            "\r",
            "template <class T, class U>\r",
            "std::istream& operator>>(std::istream& is, std::pair<T, U>& p) {\r",
            "  return is >> p.first >> p.second;\r",
            "}\r",
            "\r",
            "template <class Tuple, std::size_t... Is>\r",
            "void tuple_in(std::istream& is, Tuple& tp, std::index_sequence<Is...>) {\r",
            "  ((is >> std::get<Is>(tp)), ...);\r",
            "}\r",
            "\r",
            "template <class... Args>\r",
            "std::istream& operator>>(std::istream& is, std::tuple<Args...>& tp) {\r",
            "  tuple_in(is, tp, std::index_sequence_for<Args...>{});\r",
            "  return is;\r",
            "}\r",
            "\r",
            "template <class T, class U>\r",
            "std::ostream& operator<<(std::ostream& os, const std::pair<T, U>& p) {\r",
            "  return os << '(' << p.first << \", \" << p.second << ')';\r",
            "}\r",
            "\r",
            "template <class Tuple, std::size_t... Is>\r",
            "void tuple_out(std::ostream& os, const Tuple& tp, std::index_sequence<Is...>) {\r",
            "  ((os << (Is ? \", \" : \"(\") << std::get<Is>(tp)), ...) << \")\";\r",
            "}\r",
            "\r",
            "template <class... Args>\r",
            "std::ostream& operator<<(std::ostream& os, const std::tuple<Args...>& tp) {\r",
            "  tuple_out(os, tp, std::index_sequence_for<Args...>{});\r",
            "  return os;\r",
            "}\r",
            "\r",
            "template <class T>\r",
            "std::ostream& operator<<(std::ostream& os, const std::vector<T>& vec) {\r",
            "  int n = 0;\r",
            "  for (auto e : vec) os << (n++ ? \", \" : \"{\") << e;\r",
            "  return os << (n ? \"}\" : \"{}\");\r",
            "}\r",
            "\r",
            "template <class T, class Compare>\r",
            "std::ostream& operator<<(std::ostream& os, const std::set<T, Compare>& st) {\r",
            "  int n = 0;\r",
            "  for (auto e : st) os << (n++ ? \", \" : \"{\") << e;\r",
            "  return os << (n ? \"}\" : \"{}\");\r",
            "}\r",
            "\r",
            "template <class T, class U, class Compare>\r",
            "std::ostream& operator<<(std::ostream& os, const std::map<T, U, Compare>& mp) {\r",
            "  int n = 0;\r",
            "  for (auto e : mp) os << (n++ ? \", \" : \"{\") << e;\r",
            "  return os << (n ? \"}\" : \"{}\");\r",
            "}\r",
            "\r",
            "#ifdef LOCAL\r",
            "#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]: \", debug_out(__VA_ARGS__)\r",
            "#else\r",
            "#define debug(...) void(0)\r",
            "#endif\r",
            "\r",
            "void debug_out() { std::cerr << '\\n'; }\r",
            "\r",
            "template <class Head, class... Tail>\r",
            "void debug_out(Head&& head, Tail&&... tail) {\r",
            "  std::cerr << head;\r",
            "  if (sizeof...(Tail) != 0) std::cerr << \", \";\r",
            "  debug_out(std::forward<Tail>(tail)...);\r",
            "}\r",
            "\r",
            "#pragma endregion kyomukyomupurin\r",
            "\r",
            "int main() {\r",
            "  ios_base::sync_with_stdio(false);\r",
            "  cin.tie(nullptr);\r",
            "\r",
            "\r",
            "\r",
            "  return 0;\r",
            "}\r"
        ]
    },
    "template_codeforces": {
        "prefix": "template_codeforces",
        "body": [
            "#include <algorithm>\r",
            "#include <bitset>\r",
            "#include <cassert>\r",
            "#include <cctype>\r",
            "#include <charconv>\r",
            "#include <chrono>\r",
            "#include <cmath>\r",
            "#include <complex>\r",
            "#include <cstring>\r",
            "#include <deque>\r",
            "#include <iomanip>\r",
            "#include <iostream>\r",
            "#include <map>\r",
            "#include <numeric>\r",
            "#include <queue>\r",
            "#include <random>\r",
            "#include <set>\r",
            "#include <stack>\r",
            "#include <string>\r",
            "#include <tuple>\r",
            "#include <utility>\r",
            "#include <vector>\r",
            "\r",
            "using namespace std;\r",
            "\r",
            "using int64 = long long;\r",
            "\r",
            "#define all($) std::begin($), std::end($)\r",
            "#define rall($) std::rbegin($), std::rend($)\r",
            "\r",
            "int main() {\r",
            "  std::ios_base::sync_with_stdio(false);\r",
            "  std::cin.tie(nullptr);\r",
            "\r",
            "  int t; cin >> t;\r",
            "\r",
            "  auto Solve = []() -> void {\r",
            "\r",
            "  };\r",
            "\r",
            "  while (t--) Solve();\r",
            "\r",
            "  return 0;\r",
            "}\r"
        ]
    },
    "template_simple": {
        "prefix": "template_simple",
        "body": [
            "#include <algorithm>\r",
            "#include <bitset>\r",
            "#include <cassert>\r",
            "#include <cctype>\r",
            "#include <charconv>\r",
            "#include <chrono>\r",
            "#include <cmath>\r",
            "#include <complex>\r",
            "#include <cstring>\r",
            "#include <deque>\r",
            "#include <iomanip>\r",
            "#include <iostream>\r",
            "#include <map>\r",
            "#include <numeric>\r",
            "#include <queue>\r",
            "#include <random>\r",
            "#include <set>\r",
            "#include <stack>\r",
            "#include <string>\r",
            "#include <tuple>\r",
            "#include <utility>\r",
            "#include <vector>\r",
            "\r",
            "using namespace std;\r",
            "\r",
            "using int64 = long long;\r",
            "\r",
            "#define all($) std::begin($), std::end($)\r",
            "#define rall($) std::rbegin($), std::rend($)\r",
            "\r",
            "int main() {\r",
            "  std::ios_base::sync_with_stdio(false);\r",
            "  std::cin.tie(nullptr);\r",
            "\r",
            "\r",
            "  return 0;\r",
            "}\r"
        ]
    },
    "timer": {
        "prefix": "timer",
        "body": [
            "class Timer {\r",
            " public:\r",
            "  // (second)\r",
            "  double get_elapsed_time() {\r",
            "    return static_cast<double>(get_cycle() - start_) /\r",
            "           static_cast<double>(clock_frequency_);\r",
            "  }\r",
            "\r",
            "  void start() { start_ = get_cycle(); }\r",
            "\r",
            " private:\r",
            "  int64_t start_;\r",
            "  static constexpr int64_t clock_frequency_ = 1800000000; // Local\r",
            "  //static constexpr int64_t clock_frequency_ = 3000000000; // AtCoder\r",
            "  //static constexpr int64_t clock_frequency_ = 3600000000; // Codeforces\r",
            "  //static constexpr int64_t clock_frequency_ = 2300000000; // yukicoder\r",
            "\r",
            "  int64_t get_cycle() {\r",
            "    uint32_t low, high;\r",
            "    __asm__ volatile(\"rdtsc\" : \"=a\"(low), \"=d\"(high));\r",
            "    return (static_cast<int64_t>(low)) | (static_cast<int64_t>(high) << 32);\r",
            "  }\r",
            "};\r"
        ]
    },
    "utils": {
        "prefix": "utils",
        "body": [
            "template <class T>\r",
            "inline int lower_position(const std::vector<T>& vec, T val) {\r",
            "  return std::distance(vec.begin(),\r",
            "                       std::lower_bound(vec.begin(), vec.end(), val));\r",
            "}\r",
            "\r",
            "template <class T>\r",
            "inline int upper_position(const std::vector<T>& vec, T val) {\r",
            "  return std::distance(vec.begin(),\r",
            "                       std::upper_bound(vec.begin(), vec.end(), val));\r",
            "}\r",
            "\r",
            "template <class T>\r",
            "inline std::vector<int> compressed(const std::vector<T>& vec) {\r",
            "  std::vector<T> t = vec;\r",
            "  std::sort(t.begin(), t.end());\r",
            "  int n = vec.size();\r",
            "  int w = 0;\r",
            "  for (int i = 0; i < n; ++i) {\r",
            "    if (!(w > 0 && t[w - 1] == t[i])) {\r",
            "      std::swap(t[w], t[i]);\r",
            "      ++w;\r",
            "    }\r",
            "  }\r",
            "  t.resize(w);\r",
            "  std::vector<int> compressed(n);\r",
            "  for (int i = 0; i < n; ++i)\r",
            "    compressed[i] =\r",
            "        std::distance(t.begin(), std::lower_bound(t.begin(), t.end(), vec[i]));\r",
            "  return compressed;\r",
            "}\r",
            "\r",
            "template <class T>\r",
            "inline std::string to_binary(T n) {\r",
            "  assert(n > 0);\r",
            "  std::string ret = \"\";\r",
            "  while (n) ret += (n & 1) ? '1' : '0', n >>= 1;\r",
            "  std::reverse(ret.begin(), ret.end());\r",
            "  return ret;\r",
            "}\r",
            "\r",
            "template <class T>\r",
            "inline void println(T val) {\r",
            "  std::cout << val << '\\n';\r",
            "}\r",
            "\r",
            "inline void println(double val) {\r",
            "  std::cout << std::fixed << std::setprecision(17) << val << '\\n';\r",
            "}\r",
            "\r",
            "inline void println(long double val) {\r",
            "  std::cout << std::fixed << std::setprecision(17) << val << '\\n';\r",
            "}\r",
            "\r",
            "template <class T>\r",
            "inline void println(const std::vector<T>& vec, const char del = ' ') {\r",
            "  bool first = true;\r",
            "  for (T e : vec) {\r",
            "    if (!first) std::cout << del;\r",
            "    first = false;\r",
            "    std::cout << e;\r",
            "  } \r",
            "  std::cout << '\\n';\r",
            "}\r",
            "\r",
            "inline void Yes(bool cond) {\r",
            "  println(cond ? \"Yes\" : \"No\");\r",
            "}\r",
            "\r",
            "inline void YES(bool cond) {\r",
            "  println(cond ? \"YES\" : \"NO\");\r",
            "}\r",
            "\r",
            "template <class T>\r",
            "using binary_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;\r",
            "\r",
            "template <class T>\r",
            "std::istream& operator>>(std::istream& is, std::vector<T>& vec) {\r",
            "  for (T& e : vec) is >> e;\r",
            "  return is;\r",
            "}\r",
            "\r",
            "template <class T, class U>\r",
            "std::istream& operator>>(std::istream& is, std::pair<T, U>& p) {\r",
            "  return is >> p.first >> p.second;\r",
            "}\r",
            "\r",
            "template <class Tuple, std::size_t... Is>\r",
            "void tuple_in(std::istream& is, Tuple& tp, std::index_sequence<Is...>) {\r",
            "  ((is >> std::get<Is>(tp)), ...);\r",
            "}\r",
            "\r",
            "template <class... Args>\r",
            "std::istream& operator>>(std::istream& is, std::tuple<Args...>& tp) {\r",
            "  tuple_in(is, tp, std::index_sequence_for<Args...>{});\r",
            "  return is;\r",
            "}\r"
        ]
    },
    "xoroshiro": {
        "prefix": "xoroshiro",
        "body": [
            "// This is xoroshiro128+ 1.0\r",
            "// Reference : http://prng.di.unimi.it/xoroshiro128plus.c\r",
            "class Xoroshiro {\r",
            " public:\r",
            "  Xoroshiro() {\r",
            "    s[0] = static_cast<uint64_t>(std::chrono::steady_clock::now().time_since_epoch().count());\r",
            "    s[1] = s[0] ^ 0xffffffffful;\r",
            "    for (int i = 0; i < (1 << 6); ++i) next();\r",
            "  }\r",
            "\r",
            "  using result_type = uint64_t;\r",
            "  static constexpr uint64_t min() { return std::numeric_limits<result_type>::min(); }\r",
            "  static constexpr uint64_t max() { return std::numeric_limits<result_type>::max(); }\r",
            "\r",
            "  uint64_t operator()() { return next(); }\r",
            "\r",
            " private:\r",
            "  uint64_t s[2];\r",
            "\r",
            "  static inline uint64_t rotl(const uint64_t x, int k) {\r",
            "    return (x << k) | (x >> (64 - k));\r",
            "  }\r",
            "\r",
            "  uint64_t next() {\r",
            "    const uint64_t s0 = s[0];\r",
            "    uint64_t s1 = s[1];\r",
            "    const uint64_t result = s0 + s1;\r",
            "    s1 ^= s0;\r",
            "    s[0] = rotl(s0, 24) ^ s1 ^ (s1 << 16);\r",
            "    s[1] = rotl(s1, 37);\r",
            "\r",
            "    return result;\r",
            "  }\r",
            "};\r"
        ]
    },
    "bellman_ford": {
        "prefix": "bellman_ford",
        "body": [
            "template <class T>\r",
            "std::vector<T> bellmanford(const graph<T>& g, int s) {\r",
            "  assert(0 <= s && s < g.n_);\r",
            "  constexpr T kInfinity = std::numeric_limits<T>::max();\r",
            "  std::vector<T> dist(g.n_, kInfinity);\r",
            "  dist[s] = 0;\r",
            "  for (int i = 0; i < g.n_; ++i) {\r",
            "    for (const auto& [from, to, cost] : g.edges_) {\r",
            "      if (dist[from] == kInfinity) continue;\r",
            "      if (dist[to] > dist[from] + cost) {\r",
            "        dist[to] = dist[from] + cost;\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "  for (const auto& [from, to, cost] : g.edges_) {\r",
            "    if (dist[from] == kInfinity) continue;\r",
            "    if (dist[to] > dist[from] + cost) return {};\r",
            "  }\r",
            "  return dist;\r",
            "}\r"
        ]
    },
    "bfs": {
        "prefix": "bfs",
        "body": [
            "template <class T>\r",
            "std::vector<T> bfs(const graph<T>& g, int s) {\r",
            "  std::vector<T> dist(g.n_, -1);\r",
            "  dist[s] = 0;\r",
            "  std::queue<int> que;\r",
            "  que.emplace(s);\r",
            "  while (!que.empty()) {\r",
            "    int cur = que.front();\r",
            "    que.pop();\r",
            "    for (int id : g.data_[cur]) {\r",
            "      const auto& [from, to, cost] = g.edges_[id];\r",
            "      int nxt = from ^ to ^ cur;\r",
            "      if (dist[nxt] != -1) continue;\r",
            "      dist[nxt] = dist[cur] + cost;\r",
            "      que.emplace(nxt);\r",
            "    }\r",
            "  }\r",
            "  return dist;\r",
            "}\r"
        ]
    },
    "dijkstra": {
        "prefix": "dijkstra",
        "body": [
            "template <class T>\r",
            "std::vector<T> dijkstra(const graph<T>& g, int s) {\r",
            "  assert(0 <= s && s < g.n_);\r",
            "  std::vector<T> dist(g.n_, std::numeric_limits<T>::max());\r",
            "  using Pair = std::pair<T, int>;\r",
            "  std::priority_queue<Pair, std::vector<Pair>, std::greater<Pair>> pq;\r",
            "  dist[s] = 0;\r",
            "  pq.emplace(0, s);\r",
            "  while (!pq.empty()) {\r",
            "    auto [d, v] = pq.top();\r",
            "    pq.pop();\r",
            "    if (dist[v] < d) continue;\r",
            "    for (int id : g.data_[v]) {\r",
            "      const auto& [from, to, cost] = g.edges_[id];\r",
            "      int nxt = from ^ to ^ v;\r",
            "      if (dist[nxt] > dist[v] + cost) {\r",
            "        dist[nxt] = dist[v] + cost;\r",
            "        pq.emplace(dist[nxt], nxt);\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "  return dist;\r",
            "}\r"
        ]
    },
    "dinic": {
        "prefix": "dinic",
        "body": [
            "template <class T>\r",
            "class Dinic {\r",
            " public:\r",
            "  Dinic(int node_size) : node_size_(node_size) { init(); }\r",
            "\r",
            "  void add(int from, int to, T cost) {\r",
            "    assert(0 <= from && from < node_size_ && 0 <= to && to < node_size_);\r",
            "    graph_[from].emplace_back(\r",
            "        (edge){to, cost, static_cast<int>(graph_[to].size())});\r",
            "    graph_[to].emplace_back((edge){from, static_cast<T>(0),\r",
            "                                   static_cast<int>(graph_[from].size()) - 1});\r",
            "  }\r",
            "\r",
            "  T max_flow(int s, int t) {\r",
            "    T flow = 0;\r",
            "    for (;;) {\r",
            "      bfs(s);\r",
            "      if (level_[t] < 0) return flow;\r",
            "      std::fill(iter_.begin(), iter_.end(), 0);\r",
            "      T f;\r",
            "      while ((f = dfs(s, t,\r",
            "                      std::numeric_limits<T>::max() / static_cast<T>(2))) >\r",
            "             0) {\r",
            "        flow += f;\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "\r",
            " private:\r",
            "  struct edge {\r",
            "    int to;\r",
            "    T cap;\r",
            "    int rev;\r",
            "  };\r",
            "  int node_size_;\r",
            "  std::vector<std::vector<edge>> graph_;\r",
            "  std::vector<int> level_;\r",
            "  std::vector<int> iter_;\r",
            "\r",
            "  void init() {\r",
            "    graph_.resize(node_size_);\r",
            "    level_.assign(node_size_, 0);\r",
            "    iter_.assign(node_size_, 0);\r",
            "  }\r",
            "\r",
            "  void bfs(int s) {\r",
            "    std::fill(level_.begin(), level_.end(), -1);\r",
            "    std::queue<int> que;\r",
            "    level_[s] = 0;\r",
            "    que.emplace(s);\r",
            "    while (!que.empty()) {\r",
            "      int cur = que.front();\r",
            "      que.pop();\r",
            "      for (const edge& next : graph_[cur]) {\r",
            "        if (next.cap > 0 && level_[next.to] < 0) {\r",
            "          level_[next.to] = level_[cur] + 1;\r",
            "          que.emplace(next.to);\r",
            "        }\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "\r",
            "  T dfs(int v, int t, int f) {\r",
            "    if (v == t) return f;\r",
            "    for (int& i = iter_[v]; i < (int)graph_[v].size(); ++i) {\r",
            "      edge& e = graph_[v][i];\r",
            "      if (e.cap > 0 && level_[v] < level_[e.to]) {\r",
            "        T d = dfs(e.to, t, min(f, e.cap));\r",
            "        if (d > 0) {\r",
            "          e.cap -= d;\r",
            "          graph_[e.to][e.rev].cap += d;\r",
            "          return d;\r",
            "        }\r",
            "      }\r",
            "    }\r",
            "    return 0;\r",
            "  }\r",
            "};\r"
        ]
    },
    "graph": {
        "prefix": "graph",
        "body": [
            "template <class T>\r",
            "class graph {\r",
            " public:\r",
            "  graph(int n) : n_(n) { data_.resize(n_); }\r",
            "  struct edge {\r",
            "    int from, to;\r",
            "    T cost;\r",
            "\r",
            "    edge(int from_, int to_, T cost_) : from(from_), to(to_), cost(cost_) {}\r",
            "  };\r",
            "  int n_;\r",
            "  std::vector<std::vector<int>> data_;\r",
            "  std::vector<edge> edges_;\r",
            "\r",
            "  virtual void add(int from, int to, T cost) = 0;\r",
            "};\r",
            "\r",
            "template <class T>\r",
            "class forest : public graph<T> {\r",
            " public:\r",
            "  using graph<T>::n_;\r",
            "  using graph<T>::data_;\r",
            "  using graph<T>::edges_;\r",
            "\r",
            "  forest(int n) : graph<T>(n) {}\r",
            "\r",
            "  void add(int from, int to, T cost = 1) {\r",
            "    assert(0 <= from && from < n_ && 0 <= to && to < n_);\r",
            "    int id = edges_.size();\r",
            "    assert(id < n_ - 1);\r",
            "    data_[from].emplace_back(id);\r",
            "    data_[to].emplace_back(id);\r",
            "    edges_.emplace_back(from, to, cost);\r",
            "  }\r",
            "};\r",
            "\r",
            "template <class T>\r",
            "class digraph : public graph<T> {\r",
            " public:\r",
            "  using graph<T>::n_;\r",
            "  using graph<T>::data_;\r",
            "  using graph<T>::edges_;\r",
            "\r",
            "  digraph(int n) : graph<T>(n) {}\r",
            "\r",
            "  void add(int from, int to, T cost = 1) {\r",
            "    assert(0 <= from && from < n_ && 0 <= to && to < n_);\r",
            "    int id = edges_.size();\r",
            "    data_[from].emplace_back(id);\r",
            "    edges_.emplace_back(from, to, cost);\r",
            "  }\r",
            "\r",
            "  digraph<T> reverse() const {\r",
            "    digraph<T> rev(n_);\r",
            "    for (const auto& [from, to, cost] : edges_) {\r",
            "      rev.add(to, from, cost);\r",
            "    }\r",
            "    return rev;\r",
            "  }\r",
            "};\r",
            "\r",
            "template <class T>\r",
            "class undigraph : public graph<T> {\r",
            " public:\r",
            "  using graph<T>::n_;\r",
            "  using graph<T>::data_;\r",
            "  using graph<T>::edges_;\r",
            "\r",
            "  undigraph(int n) : graph<T>(n) {}\r",
            "\r",
            "  void add(int from, int to, T cost = 1) {\r",
            "    assert(0 <= from && from < n_ && 0 <= to && to < n_);\r",
            "    int id = edges_.size();\r",
            "    data_[from].emplace_back(id);\r",
            "    data_[to].emplace_back(id);\r",
            "    edges_.emplace_back(from, to, cost);\r",
            "  }\r",
            "};\r"
        ]
    },
    "grid_to_digraph": {
        "prefix": "grid_to_digraph",
        "body": [
            "digraph<int> grid_to_digraph(const std::vector<std::string>& sv) {\r",
            "  int h = sv.size(), w = sv[0].size();\r",
            "  digraph<int> g(h * w);\r",
            "  constexpr int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};\r",
            "  auto Out = [&](int x, int y) { return (x < 0 || x >= h || y < 0 || y >= w); };\r",
            "  auto Compress = [&](int x, int y) { return x * w + y; };\r",
            "  for (int i = 0; i < h; ++i) {\r",
            "    for (int j = 0; j < w; ++j) {\r",
            "      for (int k = 0; k < 4; ++k) {\r",
            "        int nx = i + dx[k], ny = j + dy[k];\r",
            "        if (Out(nx, ny)) continue;\r",
            "        if (...) {\r",
            "          g.add(Compress(i, j), Compress(nx, ny));\r",
            "        }\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "  return g;\r",
            "}\r"
        ]
    },
    "lca": {
        "prefix": "lca",
        "body": [
            "template <class T>\r",
            "class lca_forest : public forest<T> {\r",
            " public:\r",
            "  using forest<T>::n_;\r",
            "  using forest<T>::data_;\r",
            "  using forest<T>::edges_;\r",
            "\r",
            "  lca_forest(int n) : forest<T>(n), lg_(32 - __builtin_clz(n)) { init(); }\r",
            "\r",
            "  void build(int r = 0) {\r",
            "    dfs(r, -1, 0);\r",
            "    for (int i = 0; i + 1 < lg_; ++i) {\r",
            "      for (int j = 0; j < n_; ++j) {\r",
            "        if (par_[i][j] < 0) {\r",
            "          par_[i + 1][j] = -1;\r",
            "        } else {\r",
            "          par_[i + 1][j] = par_[i][par_[i][j]];\r",
            "        }\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "\r",
            "  // use after build()\r",
            "  int lca(int u, int v) {\r",
            "    assert(0 <= u && u < n_ && 0 <= v && v < n_);\r",
            "    if (dep_[u] > dep_[v]) std::swap(u, v);\r",
            "    for (int i = 0; i < lg_; ++i) {\r",
            "      if ((dep_[v] - dep_[u]) >> i & 1) {\r",
            "        v = par_[i][v];\r",
            "      }\r",
            "    }\r",
            "    if (u == v) return u;\r",
            "    for (int i = lg_ - 1; i >= 0; --i) {\r",
            "      if (par_[i][u] != par_[i][v]) {\r",
            "        u = par_[i][u];\r",
            "        v = par_[i][v];\r",
            "      }\r",
            "    }\r",
            "    return par_[0][u];\r",
            "  }\r",
            "\r",
            "  int dist(int u, int v) {\r",
            "    assert(0 <= u && u < n_ && 0 <= v && v < n_);\r",
            "    return dep_[u] + dep_[v] - 2 * dep_[lca(u, v)];\r",
            "  }\r",
            "\r",
            " private:\r",
            "  int lg_;\r",
            "  std::vector<std::vector<int>> par_;\r",
            "  std::vector<int> dep_;\r",
            "\r",
            "  void dfs(int cur, int pre, int d) {\r",
            "    par_[0][cur] = pre;\r",
            "    dep_[cur] = d;\r",
            "    for (int id : data_[cur]) {\r",
            "      const auto& [from, to, cost] = edges_[id];\r",
            "      int nxt = from ^ to ^ cur;\r",
            "      if (nxt == pre) continue;\r",
            "      dfs(nxt, cur, d + 1);\r",
            "    }\r",
            "  }\r",
            "\r",
            "  void init() {\r",
            "    dep_.resize(n_);\r",
            "    par_.assign(lg_, std::vector<int>(n_, -1));\r",
            "  }\r",
            "};\r"
        ]
    },
    "spfa": {
        "prefix": "spfa",
        "body": [
            "template <class T>\r",
            "std::vector<T> SPFA(const graph<T>& g, int s) {\r",
            "  assert(0 <= s && s < g.n_);\r",
            "  std::vector<T> dist(g.n_, std::numeric_limits<T>::max());\r",
            "  std::vector<int> pend(g.n_, 0);\r",
            "  std::vector<int> times(g.n_, 0);\r",
            "  std::queue<int> que;\r",
            "  que.emplace(s);\r",
            "  pend[s] = true;\r",
            "  ++times[s];\r",
            "  dist[s] = 0;\r",
            "  while (!que.empty()) {\r",
            "    int cur = que.front(); que.pop();\r",
            "    pend[cur] = false;\r",
            "    for (int id : g.data_[cur]) {\r",
            "      const auto& [from, to, cost] = g.edges_[id];\r",
            "      int nxt = from ^ to ^ cur;\r",
            "      T ncost = dist[cur] + cost;\r",
            "      if (ncost >= dist[nxt]) continue;\r",
            "      dist[nxt] = ncost;\r",
            "      if (!pend[nxt]) {\r",
            "        if (++times[nxt] >= g.n_) {\r",
            "          return {};\r",
            "        }\r",
            "        pend[nxt] = true;\r",
            "        que.emplace(nxt);\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "  return dist;\r",
            "}\r"
        ]
    },
    "topological_sort": {
        "prefix": "topological_sort",
        "body": [
            "template <class T>\r",
            "std::vector<int> topological_sort(const digraph<T>& g) {\r",
            "  std::vector<int> lev(g.n_, 0);\r",
            "  std::vector<int> res;\r",
            "  for (auto e : g.edges_) ++lev[e.to];\r",
            "  std::queue<int> que;\r",
            "  for (int i = 0; i < g.n_; ++i) {\r",
            "    if (lev[i] == 0) que.emplace(i);\r",
            "  }\r",
            "  while (!que.empty()) {\r",
            "    int cur = que.front(); que.pop();\r",
            "    res.emplace_back(cur);\r",
            "    for (int id : g.data_[cur]) {\r",
            "      const auto& [from, to, cost] = g.edges_[id];\r",
            "      int nxt = from ^ to ^ cur;\r",
            "      if (--lev[nxt] == 0) que.emplace(nxt);\r",
            "    }\r",
            "  }\r",
            "  if (std::all_of(lev.begin(), lev.end(), [](int e){ return e == 0; })) {\r",
            "    return res;\r",
            "  } else {\r",
            "    return {};\r",
            "  }\r",
            "}\r"
        ]
    },
    "tree_diameter": {
        "prefix": "tree_diameter",
        "body": [
            "template <class T>\r",
            "T tree_diameter(const forest<T>& g) {\r",
            "  std::vector<T> d1 = bfs(g, 0);\r",
            "  std::vector<T> d2 = bfs(g, std::distance(d1.begin(), std::max_element(d1.begin(), d1.end())));\r",
            "  return *std::max_element(d2.begin(), d2.end());\r",
            "}\r"
        ]
    },
    "binary_gcd": {
        "prefix": "binary_gcd",
        "body": [
            "template <class T>\r",
            "T binary_gcd(T x, T y) {\r",
            "  assert(x >= 0 && y >= 0);\r",
            "  unsigned long long tx = x, ty = y;\r",
            "  if (!tx || !ty) return tx ^ ty ^ 0;\r",
            "  int s = __builtin_ctzll(tx | ty);\r",
            "  tx >>= __builtin_ctzll(tx);\r",
            "  do {\r",
            "    ty >>= __builtin_ctzll(ty);\r",
            "    if (tx > ty) std::swap(tx, ty);\r",
            "    ty -= tx;\r",
            "  } while (ty);\r",
            "  return static_cast<T>(tx << s);\r",
            "}\r"
        ]
    },
    "combination": {
        "prefix": "combination",
        "body": [
            "class Combination {\r",
            " public:\r",
            "  static constexpr int mod_ = 1000000007;\r",
            "  static constexpr int n_ = 2000000 + 5;\r",
            "\r",
            "  Combination() { build(); }\r",
            "\r",
            "  int64 fact_[n_];\r",
            "  int64 inv_[n_];\r",
            "  int64 finv_[n_];\r",
            "\r",
            "  // return nCk\r",
            "  int64 get(int n, int k) const noexcept {\r",
            "    if (n < k || n < 0 || k < 0) return 0;\r",
            "    return fact_[n] * (finv_[k] * finv_[n - k] % mod_) % mod_;\r",
            "  }\r",
            "\r",
            " private:\r",
            "  void build() noexcept {\r",
            "    fact_[0] = 1;\r",
            "    fact_[1] = 1;\r",
            "    finv_[0] = 1;\r",
            "    finv_[1] = 1;\r",
            "    inv_[1] = 1;\r",
            "    for (int i = 2; i < n_; ++i) {\r",
            "      fact_[i] = fact_[i - 1] * i % mod_;\r",
            "      inv_[i] = mod_ - inv_[mod_ % i] * (mod_ / i) % mod_;\r",
            "      finv_[i] = finv_[i - 1] * inv_[i] % mod_;\r",
            "    }\r",
            "  }\r",
            "};\r"
        ]
    },
    "divisor": {
        "prefix": "divisor",
        "body": [
            "template<class T>\r",
            "std::vector<T> divisor(T n) {\r",
            "  std::vector<T> res;\r",
            "  for (T i = 1; i * i <= n; ++i) {\r",
            "    if (n % i == 0){\r",
            "      res.emplace_back(i);\r",
            "      if (i * i != n){\r",
            "        res.emplace_back(n / i);\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "  std::sort(res.begin(), res.end());\r",
            "\r",
            "  return res;\r",
            "}\r"
        ]
    },
    "extgcd": {
        "prefix": "extgcd",
        "body": [
            "// find x, y such that a * x + b * y = gcd(a, b)\r",
            "template <class T>\r",
            "T extgcd(T a, T b, T& x, T& y) {\r",
            "  T d = a;\r",
            "  if (b) {\r",
            "    d = extgcd(b, a % b, y, x);\r",
            "    y -= (a / b) * x;\r",
            "  } else {\r",
            "    x = 1, y = 0;\r",
            "  }\r",
            "  return d;\r",
            "}\r"
        ]
    },
    "factor": {
        "prefix": "factor",
        "body": [
            "template <class T>\r",
            "inline std::vector<T> connect(const std::vector<T> &a,\r",
            "                              const std::vector<T> &b) {\r",
            "  std::vector<T> c(a.size() + b.size());\r",
            "  std::merge(a.begin(), a.end(), b.begin(), b.end(), c.begin());\r",
            "  return c;\r",
            "}\r",
            "\r",
            "template <class T>\r",
            "std::vector<T> factor(T n) {\r",
            "  if (n <= 1) return {};\r",
            "  if (is_prime(n)) return {n};\r",
            "  if (~n & 1) return connect({2}, factor(n >> 1));\r",
            "  for (T c = 1;; ++c) {\r",
            "    T x = 2, y = 2, d;\r",
            "    do {\r",
            "      x = ((int128)x * x + c) % n;\r",
            "      y = ((int128)y * y + c) % n;\r",
            "      y = ((int128)y * y + c) % n;\r",
            "      d = binary_gcd(x - y, n);\r",
            "    } while (d == 1);\r",
            "    if (d < n) return connect(factor(d), factor(n / d));\r",
            "  }\r",
            "}\r"
        ]
    },
    "fast_divisor": {
        "prefix": "fast_divisor",
        "body": [
            "template <class T>\r",
            "std::vector<T> divisor(T n) {\r",
            "  std::vector<T> v1 = factor(n);\r",
            "  auto v2 = RunLengthEncoding(v1);\r",
            "  std::vector<T> div;\r",
            "  int sz = v2.size();\r",
            "  auto dfs = [&](auto&& self, T val, int d) -> void {\r",
            "    if (d == sz) {\r",
            "      div.emplace_back(val);\r",
            "      return;\r",
            "    }\r",
            "    T cur = 1;\r",
            "    auto [pr, cnt] = v2[d];\r",
            "    for (int i = 0; i < cnt + 1; ++i, cur *= pr) {\r",
            "      self(self, val * cur, d + 1);\r",
            "    }\r",
            "  };\r",
            "  dfs(dfs, 1, 0);\r",
            "  std::sort(div.begin(), div.end());\r",
            "\r",
            "  return div;\r",
            "}\r"
        ]
    },
    "miller_rabin": {
        "prefix": "miller_rabin",
        "body": [
            "using int128 = __int128_t;\r",
            "\r",
            "int128 power(int128 base, int128 e, int128 mod) {\r",
            "  int128 res = 1;\r",
            "  base %= mod;\r",
            "  while (e) {\r",
            "    if (e & 1) (res *= base) %= mod;\r",
            "    (base *= base) %= mod;\r",
            "    e >>= 1;\r",
            "  }\r",
            "  return res;\r",
            "}\r",
            "\r",
            "bool is_prime(int64 n) {\r",
            "  if (n < 2 || ~n & 1) return n == 2;\r",
            "  int s = __builtin_ctzll(n - 1);\r",
            "  int64 d = (n - 1) >> s;\r",
            "  for (int64 base : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) {\r",
            "    int128 x = base % n;\r",
            "    if (!x) continue;\r",
            "    x = power(x, d, n);\r",
            "    if (x == 1 || x == n - 1) continue;\r",
            "    bool ok = false;\r",
            "    for (int i = 0; i < s - 1; ++i) {\r",
            "      (x *= x) %= n;\r",
            "      if (x == n - 1) {\r",
            "        ok = true; break;\r",
            "      }\r",
            "    }\r",
            "    if (!ok) return false;\r",
            "  }\r",
            "  return true;\r",
            "}\r"
        ]
    },
    "mod_pow": {
        "prefix": "mod_pow",
        "body": [
            "template<class T, class U> T mod_pow(T x, U n, T mod) {\r",
            "  T res = 1;\r",
            "  while (n > 0) {\r",
            "    if (n & 1) (res *= x) %= mod;\r",
            "    (x *= x) %= mod;\r",
            "    n >>= 1;\r",
            "  }\r",
            "  return res;\r",
            "}\r"
        ]
    },
    "osa_k": {
        "prefix": "osa_k",
        "body": [
            "class osa_k {\r",
            "  static constexpr int n_ = 1000000 + 5;\r",
            "\r",
            " public:\r",
            "  osa_k() { build(); }\r",
            "\r",
            "  std::vector<std::pair<int, int>> prime_factor(int n) {\r",
            "    std::vector<std::pair<int, int>> res;\r",
            "    while (n != 1) {\r",
            "      int p = min_factor[n];\r",
            "      int cnt = 0;\r",
            "      while (min_factor[n] == p) ++cnt, n /= p;\r",
            "      res.emplace_back(p, cnt);\r",
            "    }\r",
            "    return res;\r",
            "  }\r",
            "\r",
            " private:\r",
            "  int min_factor[n_ + 1];\r",
            "\r",
            "  void build() {\r",
            "    std::fill(min_factor, min_factor + n_ + 1, 0);\r",
            "    std::vector<int> pr;\r",
            "    for (int i = 2; i <= n_; ++i) {\r",
            "      if (!min_factor[i]) {\r",
            "        min_factor[i] = i;\r",
            "        pr.emplace_back(i);\r",
            "      }\r",
            "      for (int j = 0; j < (int)pr.size() && pr[j] <= min_factor[i] && i * pr[j] <= n_; ++j) {\r",
            "        min_factor[i * pr[j]] = pr[j];\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "};\r"
        ]
    },
    "prime_factorization": {
        "prefix": "prime_factorization",
        "body": [
            "template<class T>\r",
            "std::map<T, int> prime_fact(T n){\r",
            "  std::map<T, int> result;\r",
            "  for (T i = 2; i * i <= n; ++i){\r",
            "    if (n % i != 0) continue;\r",
            "    int cnt = 0;\r",
            "    while (n % i == 0){\r",
            "      n /= i; ++cnt;\r",
            "    }\r",
            "    result[i] = cnt;\r",
            "  }\r",
            "  if (n != 1) result[n] = 1;\r",
            "  return result;\r",
            "}\r"
        ]
    },
    "sieve": {
        "prefix": "sieve",
        "body": [
            "std::vector<int> LinearTimeSieve() {\r",
            "  constexpr int n = 1000000;\r",
            "  int lp[n + 1];\r",
            "  std::fill(lp, lp + n + 1, 0);\r",
            "  std::vector<int> pr;\r",
            "  for (int i = 2; i <= n; ++i) {\r",
            "    if (!lp[i]) {\r",
            "      lp[i] = i;\r",
            "      pr.emplace_back(i);\r",
            "    }\r",
            "    for (int j = 0; j < (int)pr.size() && pr[j] <= lp[i] && i * pr[j] <= n;\r",
            "         ++j) {\r",
            "      lp[i * pr[j]] = pr[j];\r",
            "    }\r",
            "  }\r",
            "  return pr;\r",
            "}\r"
        ]
    },
    "totient": {
        "prefix": "totient",
        "body": [
            "template <class T>\r",
            "T Totient(T n) {\r",
            "  T res = n;\r",
            "  for (T i = 2; i * i <= n; ++i) {\r",
            "    if (n % i != 0) continue;\r",
            "    (res /= i) *= (i - 1);\r",
            "    while (n % i == 0) n /= i;\r",
            "  }\r",
            "  if (n != 1) (res /= n) *= (n - 1);\r",
            "  return res;\r",
            "}\r"
        ]
    },
    "lcs": {
        "prefix": "lcs",
        "body": [
            "std::string LCS(const std::string& str1, const std::string& str2) {\r",
            "  int n1 = str1.size(), n2 = str2.size();\r",
            "  std::vector<std::vector<int>> dp(n1 + 1, std::vector<int>(n2 + 1, 0));\r",
            "  for (int i = 0; i < n1; ++i) {\r",
            "    for (int j = 0; j < n2; ++j) {\r",
            "      if (str1[i] == str2[j]) {\r",
            "        dp[i + 1][j + 1] = dp[i][j] + 1;\r",
            "      } else {\r",
            "        dp[i + 1][j + 1] = std::max(dp[i + 1][j], dp[i][j + 1]);\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "  int c1 = n1, c2 = n2;\r",
            "  std::string ret = \"\";\r",
            "  while (c1 > 0 && c2 > 0) {\r",
            "    if (str1[c1 - 1] == str2[c2 - 1]) {\r",
            "      ret += str1[c1 - 1];\r",
            "      --c1;\r",
            "      --c2;\r",
            "    } else {\r",
            "      if (dp[c1][c2] == dp[c1][c2 - 1]) {\r",
            "        --c2;\r",
            "      } else {\r",
            "        --c1;\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "  std::reverse(ret.begin(), ret.end());\r",
            "  return ret;\r",
            "}\r"
        ]
    },
    "levenshtein_distance": {
        "prefix": "levenshtein_distance",
        "body": [
            "int Levenshtein_distance(const std::string& str1, const std::string& str2) {\r",
            "  int n1 = str1.size(), n2 = str2.size();\r",
            "  std::vector<std::vector<int>> dp(n1 + 1, std::vector<int>(n2 + 1, 0));\r",
            "  for (int i = 0; i <= n1; ++i) dp[i][0] = i;\r",
            "  for (int i = 0; i <= n2; ++i) dp[0][i] = i;\r",
            "  for (int i = 0; i < n1; ++i) {\r",
            "    for (int j = 0; j < n2; ++j) {\r",
            "      const int cost = (str1[i] != str2[j]);\r",
            "      dp[i + 1][j + 1] =\r",
            "          std::min({dp[i + 1][j] + 1, dp[i][j + 1] + 1, dp[i][j] + cost});\r",
            "    }\r",
            "  }\r",
            "  return dp[n1][n2];\r",
            "}\r"
        ]
    },
    "manacher": {
        "prefix": "manacher",
        "body": [
            "std::vector<int> Manacher(const std::string& str) {\r",
            "  int n = str.size();\r",
            "  std::vector<int> res(n);\r",
            "  int i = 0, j = 0;\r",
            "  while (i < n) {\r",
            "    while (i - j >= 0 && i + j < n && str[i - j] == str[i + j]) ++j;\r",
            "    res[i] = j;\r",
            "    int k = 1;\r",
            "    while (i - k >= 0 && k + res[i - k] < j) res[i + k] = res[i - k], ++k;\r",
            "    i += k;\r",
            "    j -= k;\r",
            "  }\r",
            "  return res;\r",
            "}\r"
        ]
    },
    "nextchar": {
        "prefix": "nextchar",
        "body": [
            "class NextChar {\r",
            " public:\r",
            "  NextChar(const std::string& str) : str_(str) { build(); }\r",
            "\r",
            "  // returns the first position in str[pos:n_) that c appears\r",
            "  // if c is not in str[pos:n_), returns n_\r",
            "  int find(int pos, char c) const {\r",
            "    assert(0 <= pos && pos < n_);\r",
            "    return table_[c - 'a'][pos];\r",
            "  }\r",
            "\r",
            "  // returns whether str contains c or not\r",
            "  bool contain(char c) const { return find(0, c) != n_; }\r",
            "\r",
            " private:\r",
            "  int n_;\r",
            "  std::string str_;\r",
            "  std::vector<std::vector<int>> table_;\r",
            "\r",
            "  void build() {\r",
            "    n_ = str_.size();\r",
            "    table_.resize(26, std::vector<int>(n_));\r",
            "    for (char c = 'a'; c <= 'z'; ++c) {\r",
            "      int nxt = n_;\r",
            "      for (int i = n_ - 1; i >= 0; --i) {\r",
            "        if (str_[i] == c) nxt = i;\r",
            "        table_[c - 'a'][i] = nxt;\r",
            "      }\r",
            "    }\r",
            "  }\r",
            "};\r"
        ]
    },
    "rolling_hash": {
        "prefix": "rolling_hash",
        "body": [
            "using ull = unsigned long long;\r",
            "\r",
            "class RollingHash {\r",
            " public:\r",
            "  RollingHash(const std::string& str) : str_(str) { build(); }\r",
            "\r",
            "  // get hash value of [l, r)\r",
            "  std::pair<ull, ull> get(int l, int r) {\r",
            "    ull ret0 = (hash0_[r] - hash0_[l] * pow0_[r - l] % mod0_ + mod0_) % mod0_;\r",
            "    ull ret1 = (hash1_[r] - hash1_[l] * pow1_[r - l] % mod1_ + mod1_) % mod1_;\r",
            "    return {ret0, ret1};\r",
            "  }\r",
            "\r",
            " private:\r",
            "  const std::string str_;\r",
            "  static ull base0_;\r",
            "  static ull base1_;\r",
            "  static constexpr ull mod0_ = 2020202077;\r",
            "  static constexpr ull mod1_ = 2020202111;\r",
            "  std::vector<ull> hash0_;\r",
            "  std::vector<ull> hash1_;\r",
            "  static std::vector<ull> pow0_;\r",
            "  static std::vector<ull> pow1_;\r",
            "  static std::mt19937_64 mt_;\r",
            "\r",
            "  void build() {\r",
            "    int n = str_.size();\r",
            "    hash0_.assign(n + 1, 0);\r",
            "    hash1_.assign(n + 1, 0);\r",
            "    for (int i = 0; i < n; ++i) {\r",
            "      hash0_[i + 1] = (hash0_[i] * base0_ + str_[i]) % mod0_;\r",
            "      hash1_[i + 1] = (hash1_[i] * base1_ + str_[i]) % mod1_;\r",
            "    }\r",
            "    for (int i = 0; i < n; ++i) {\r",
            "      pow0_.emplace_back(pow0_.back() * base0_ % mod0_);\r",
            "      pow1_.emplace_back(pow1_.back() * base1_ % mod1_);\r",
            "    }\r",
            "  }\r",
            "};\r",
            "\r",
            "std::mt19937_64 RollingHash::mt_(\r",
            "    std::chrono::steady_clock::now().time_since_epoch().count());\r",
            "ull RollingHash::base0_ = std::uniform_int_distribution<ull>(\r",
            "    2, RollingHash::mod0_ - 1)(RollingHash::mt_);\r",
            "ull RollingHash::base1_ = std::uniform_int_distribution<ull>(\r",
            "    2, RollingHash::mod1_ - 1)(RollingHash::mt_);\r",
            "std::vector<ull> RollingHash::pow0_{1};\r",
            "std::vector<ull> RollingHash::pow1_{1};\r"
        ]
    },
    "z_algorithm": {
        "prefix": "z_algorithm",
        "body": [
            "std::vector<int> Zalgorithm(const std::string str) {\r",
            "  int n = str.size();\r",
            "  std::vector<int> res(n);\r",
            "  res[0] = n;\r",
            "  int i = 1, j = 0;\r",
            "  while (i < n) {\r",
            "    while (i + j < n && str[j] == str[i + j]) ++j;\r",
            "    res[i] = j;\r",
            "    if (j == 0) {\r",
            "      ++i;\r",
            "      continue;\r",
            "    }\r",
            "    int k = 1;\r",
            "    while (i + k < n && k + res[k] < j) res[i + k] = res[k], ++k;\r",
            "    i += k;\r",
            "    j -= k;\r",
            "  }\r",
            "  return res;\r",
            "};\r"
        ]
    }
}