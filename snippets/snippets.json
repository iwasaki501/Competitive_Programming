{
    "coodinate_compress": {
        "prefix": "coodinate_compress",
        "body": [
            "template <class T>",
            "class CoodinateCompression {",
            " public:",
            "  CoodinateCompression(const std::vector<T>& data) : data_(data) {",
            "    assert(!data.empty());",
            "    std::sort(data_.begin(), data_.end());",
            "    data_.erase(std::unique(data_.begin(), data_.end()), data_.end());",
            "    n_ = data_.size();",
            "  }",
            "",
            "  T find_by_order(int ord) const noexcept {",
            "    assert(0 <= ord && ord < n_);",
            "    return data_[ord];",
            "  }",
            "",
            "  int find_by_value(T val) const noexcept {",
            "    auto it = std::lower_bound(data_.begin(), data_.end(), val);",
            "    assert(it != data_.end());",
            "    return std::distance(data_.begin(), it);",
            "  }",
            "",
            "  int size() const noexcept { return n_; }",
            "",
            " private:",
            "  int n_;",
            "  std::vector<T> data_;",
            "};"
        ]
    },
    "cumulative_sum": {
        "prefix": "cumulative_sum",
        "body": [
            "template <class T>",
            "class CumulativeSum {",
            " public:",
            "  CumulativeSum(const std::vector<T>& vec) {",
            "    sum_.resize(vec.size() + 1);",
            "    sum_[0] = 0;",
            "    std::partial_sum(vec.begin(), vec.end(), sum_.begin() + 1);",
            "  }",
            "",
            "  // return sum of [l, r]",
            "  T get(int l, int r) const { return sum_[r + 1] - sum_[l]; }",
            "",
            "  // return the first k where sum of [0, k] >= value",
            "  // use only when all element in vec >= 0",
            "  int lower_bound(T val) const {",
            "    return std::distance(sum_.begin() + 1,",
            "                         std::lower_bound(sum_.begin() + 1, sum_.end(), val));",
            "  }",
            "",
            "  // return the first k where sum of [0, k] > value",
            "  // use only when all element in vec >= 0",
            "  int upper_bound(T val) const {",
            "    return std::distance(sum_.begin() + 1,",
            "                         std::upper_bound(sum_.begin() + 1, sum_.end(), val));",
            "  }",
            "",
            " private:",
            "  std::vector<T> sum_;",
            "};"
        ]
    },
    "cumulative_sum_2d": {
        "prefix": "cumulative_sum_2d",
        "body": [
            "template <class T>",
            "class CumulativeSum2D {",
            " public:",
            "  CumulativeSum2D(const std::vector<vector<T>>& vec)",
            "      : x_(int(vec.size())), y_(int(vec[0].size())), vec_(vec) {",
            "    build();",
            "  }",
            "",
            "  // return sum of [sx, gx] * [sy, gy]",
            "  T get(int sx, int sy, int gx, int gy) {",
            "    assert(sx <= gx && sy <= gy);",
            "    assert(0 <= sx && sx < x_ && 0 <= gx && gx < x_);",
            "    assert(0 <= sy && sy < y_ && 0 <= gy && gy < y_);",
            "    return sum_[gx + 1][gy + 1] - sum_[gx + 1][sy] - sum_[sx][gy + 1] +",
            "           sum_[sx][sy];",
            "  }",
            "",
            " private:",
            "  int x_;",
            "  int y_;",
            "  std::vector<vector<T>> vec_;",
            "  std::vector<vector<T>> sum_;",
            "",
            "  void build() {",
            "    sum_.assign(x_ + 1, std::vector<T>(y_ + 1, 0));",
            "    for (int i = 0; i < x_; ++i) {",
            "      std::partial_sum(vec_[i].begin(), vec_[i].end(), sum_[i + 1].begin() + 1);",
            "    }",
            "    for (int i = 0; i < y_; ++i) {",
            "      for (int j = 0; j < x_; ++j) {",
            "        sum_[j + 1][i + 1] += sum_[j][i + 1];",
            "      }",
            "    }",
            "  }",
            "};"
        ]
    },
    "doubling": {
        "prefix": "doubling",
        "body": [
            "class Doubling {",
            " public:",
            "  Doubling(int n, int64 k) : n_(n), lg_(64 - __builtin_clzll(k)) {",
            "    table.assign(lg_, std::vector<int>(n_, -1));",
            "  }",
            "",
            "  void set(int pos, int val) { table[0][pos] = val; }",
            "",
            "  void build() {",
            "    for (int i = 0; i + 1 < lg_; ++i) {",
            "      for (int j = 0; j < int(table[i].size()); ++j) {",
            "        table[i + 1][j] = (table[i][j] == -1 ? -1 : table[i][table[i][j]]);",
            "      }",
            "    }",
            "  }",
            "",
            "  int query(int pos, int64 k) {",
            "    for (int i = lg_ - 1; i >= 0; --i) {",
            "      if (k & (1LL << i)) {",
            "        pos = table[i][pos];",
            "      }",
            "    }",
            "    return pos;",
            "  }",
            "",
            " private:",
            "  int n_;",
            "  int lg_;",
            "  std::vector<std::vector<int>> table;",
            "};"
        ]
    },
    "golden_section_search": {
        "prefix": "golden_section_search",
        "body": [
            "template <class F>",
            "std::pair<double, double> GoldenSectionSearch(double low, double high, F f, bool find_min = true) {",
            "  constexpr double phi = (1 + std::sqrt(5)) / 2;",
            "  double c1 = (phi * low + high) / (1 + phi);",
            "  double c2 = (low + phi * high) / (1 + phi);",
            "  double cache_f1 = f(c1), cache_f2 = f(c2);",
            "",
            "  for (int i = 0; i < 150; ++i) {",
            "    if ((find_min && cache_f1 > cache_f2) ||",
            "        (!find_min && cache_f1 < cache_f2)) {",
            "      low = c1;",
            "      cache_f1 = cache_f2;",
            "      c1 = c2;",
            "      c2 = (low + phi * high) / (1 + phi);",
            "      cache_f2 = f(c2);",
            "    } else {",
            "      high = c2;",
            "      cache_f2 = cache_f1;",
            "      c2 = c1;",
            "      c1 = (phi * low + high) / (1 + phi);",
            "      cache_f1 = f(c1);",
            "    }",
            "  }",
            "",
            "  return {low, cache_f1};",
            "}"
        ]
    },
    "run_length_encoding": {
        "prefix": "run_length_encoding",
        "body": [
            "std::vector<std::pair<char, int>> RunLengthEncoding(const std::string& str) {",
            "  std::vector<std::pair<char, int>> ret;",
            "  int sz = str.size();",
            "  int beg = 0;",
            "  while (beg < sz) {",
            "    int ed = beg;",
            "    while (ed + 1 < sz && str[beg] == str[ed + 1]) ++ed;",
            "    int len = ed - beg + 1;",
            "    ret.emplace_back(str[beg], len);",
            "    beg = ed + 1;",
            "  }",
            "  return ret;",
            "};",
            "",
            "template <class T>",
            "std::vector<std::pair<T, int>> RunLengthEncoding(const std::vector<T>& vec) {",
            "  std::vector<std::pair<T, int>> ret;",
            "  int sz = vec.size();",
            "  int beg = 0;",
            "  while (beg < sz) {",
            "    int ed = beg;",
            "    while (ed + 1 < sz && vec[beg] == vec[ed + 1]) ++ed;",
            "    int len = ed - beg + 1;",
            "    ret.emplace_back(vec[beg], len);",
            "    beg = ed + 1;",
            "  }",
            "  return ret;",
            "};"
        ]
    },
    "disjoint_sparse_table": {
        "prefix": "disjoint_sparse_table",
        "body": [
            "template <class T, class F>",
            "class DisjointSparseTable {",
            " public:",
            "  DisjointSparseTable(const std::vector<T>& data, F f)",
            "      : n_(int(data.size())), f_(f) {",
            "    int sz = 0;",
            "    while ((1 << sz) <= n_) ++sz;",
            "    tab_.assign(sz, std::vector<T>(n_, T{}));",
            "    for (int i = 0; i < n_; ++i) tab_[0][i] = data[i];",
            "    for (int i = 1; i < sz; ++i) {",
            "      int shift = 1 << i;",
            "      for (int j = 0; j < n_; j += shift << 1) {",
            "        int t = std::min(j + shift, n_);",
            "        tab_[i][t - 1] = data[t - 1];",
            "        for (int k = t - 2; k >= j; k--)",
            "          tab_[i][k] = f_(data[k], tab_[i][k + 1]);",
            "        if (n_ <= t) break;",
            "        tab_[i][t] = data[t];",
            "        int r = std::min(t + shift, n_);",
            "        for (int k = t + 1; k < r; k++)",
            "          tab_[i][k] = f_(tab_[i][k - 1], data[k]);",
            "      }",
            "    }",
            "    lookup_.resize(1 << sz);",
            "    for (int i = 2; i < int(lookup_.size()); ++i) {",
            "      lookup_[i] = lookup_[i >> 1] + 1;",
            "    }",
            "  }",
            "",
            "  // reutrn f_[l, r)",
            "  T get(int l, int r) {",
            "    if (l >= --r) return tab_[0][l];",
            "    int p = lookup_[l ^ r];",
            "    return f_(tab_[p][l], tab_[p][r]);",
            "  }",
            "",
            " private:",
            "  int n_;",
            "  F f_;",
            "  std::vector<std::vector<T>> tab_;",
            "  std::vector<int> lookup_;",
            "};"
        ]
    },
    "dual_segment_tree": {
        "prefix": "dual_segment_tree",
        "body": [
            "template <class OM, class F>",
            "class DualSegmentTree {",
            " public:",
            "  DualSegmentTree(const std::vector<OM>& data, OM oie, F f)",
            "      : data_(data), oie_(oie), f_(f) {",
            "    build();",
            "  }",
            "",
            "  // modify data_[l, r) -> f_(data_[l], val), ... , f_(data[r - 1], val)",
            "  void modify(int l, int r, OM val) {",
            "    thrust(l + n_);",
            "    thrust(r + n_ - 1);",
            "    for (l += n_, r += n_; l < r; l >>= 1, r >>= 1) {",
            "      if (l & 1) lazy_[l] = f_(lazy_[l], val), ++l;",
            "      if (r & 1) --r, lazy_[r] = f_(lazy_[r], val);",
            "    }",
            "  }",
            "",
            "  OM operator[](int pos) {",
            "    pos += n_;",
            "    thrust(pos);",
            "    return f_(data_[pos - n_], lazy_[pos]);",
            "  }",
            "",
            " private:",
            "  int n_, h_;",
            "  std::vector<OM> data_;",
            "  std::vector<OM> lazy_;",
            "  OM oie_;",
            "  F f_;",
            "",
            "  void build() {",
            "    int sz = data_.size();",
            "    n_ = 1;",
            "    h_ = 0;",
            "    while (n_ < sz) n_ <<= 1, ++h_;",
            "    lazy_.assign(2 * n_, oie_);",
            "  }",
            "",
            "  inline void propagate(int pos) {",
            "    if (lazy_[pos] != oie_) {",
            "      lazy_[2 * pos + 0] = f_(lazy_[2 * pos + 0], lazy_[pos]);",
            "      lazy_[2 * pos + 1] = f_(lazy_[2 * pos + 1], lazy_[pos]);",
            "      lazy_[pos] = oie_;",
            "    }",
            "  }",
            "",
            "  inline void thrust(int pos) {",
            "    for (int i = h_; i > 0; --i) propagate(pos >> i);",
            "  }",
            "};"
        ]
    },
    "fenwick_tree": {
        "prefix": "fenwick_tree",
        "body": [
            "template <class T>",
            "class FenwickTree {",
            " public:",
            "  FenwickTree(const std::vector<T>& data) : n_(int(data.size()) + 1) {",
            "    node_.assign(n_, 0);",
            "    for (int i = 0; i < n_ - 1; ++i) add(i, data[i]);",
            "  }",
            "",
            "  FenwickTree(int n) : n_(n + 1) { node_.assign(n_, 0); }",
            "",
            "  void add(int pos, T val) {",
            "    ++pos;",
            "    while (pos < n_) {",
            "      node_[pos] += val;",
            "      pos += pos & -pos;",
            "    }",
            "  }",
            "",
            "  // return sum of [l, r)",
            "  T get(int l, int r) const {",
            "    T sum = 0;",
            "    while (l < r) {",
            "      sum += node_[r];",
            "      r -= r & -r;",
            "    }",
            "    while (r < l) {",
            "      sum -= node_[l];",
            "      l -= l & -l;",
            "    }",
            "    return sum;",
            "  }",
            "",
            "  // return the first k where sum of [0, k] >= val",
            "  // use only when all element in data >= 0",
            "  int lower_bound(T val) const {",
            "    if (val <= 0) return 0;",
            "    int pos = 0;",
            "    int k = 1;",
            "    while (k < n_ - 1) k <<= 1;",
            "    while (k > 0) {",
            "      if (pos + k <= n_ - 1 && node_[pos + k] < val) {",
            "        val -= node_[pos + k];",
            "        pos += k;",
            "      }",
            "      k >>= 1;",
            "    }",
            "    return pos;",
            "  }",
            "",
            " private:",
            "  int n_;",
            "  std::vector<T> node_;",
            "};"
        ]
    },
    "fenwick_tree_2d": {
        "prefix": "fenwick_tree_2d",
        "body": [
            "template <class T>",
            "class FenwickTree2D {",
            " public:",
            "  FenwickTree2D(const std::vector<std::vector<T>>& vec)",
            "      : x_(int(vec.size())), y_(int(vec[0].size())) {",
            "    node_.assign(x_ + 1, std::vector<T>(y_ + 1, 0));",
            "    for (int i = 0; i < x_; ++i) {",
            "      for (int j = 0; j < y_; ++j) {",
            "        add(i, j, vec[i][j]);",
            "      }",
            "    }",
            "  }",
            "",
            "  FenwickTree2D(int x, int y) : x_(x), y_(y) {",
            "    node_.assign(x_ + 1, std::vector<T>(y_ + 1, 0));",
            "  }",
            "",
            "  // add val to (x, y)",
            "  void add(int x, int y, T val) {",
            "    for (int i = x + 1; i < x_ + 1; i += i & -i) {",
            "      for (int j = y + 1; j < y_ + 1; j += j & -j) {",
            "        node_[i][j] += val;",
            "      }",
            "    }",
            "  }",
            "",
            "  // return sum of [0, x] * [0, y]",
            "  T get(int x, int y) const {",
            "    T sum = 0;",
            "    for (int i = x + 1; i > 0; i -= i & -i) {",
            "      for (int j = y + 1; j > 0; j -= j & -j) {",
            "        sum += node_[i][j];",
            "      }",
            "    }",
            "    return sum;",
            "  }",
            "",
            "  // return sum of [sx, gx] * [sy, gy] ",
            "  T get(int sx, int sy, int gx, int gy) const {",
            "    return get(gx, gy) - get(sx - 1, gy) - get(gx, sy - 1) +",
            "           get(sx - 1, sy - 1);",
            "  }",
            "",
            " private:",
            "  int x_;",
            "  int y_;",
            "  std::vector<std::vector<T>> node_;",
            "};"
        ]
    },
    "fenwick_tree_raq": {
        "prefix": "fenwick_tree_raq",
        "body": [
            "template <class T>",
            "class FenwickTreeRAQ {",
            " public:",
            "  FenwickTreeRAQ(const std::vector<T>& data)",
            "      : n_(int(data.size())),",
            "        ft1_(FenwickTree<T>(data)),",
            "        ft2_(FenwickTree<T>(data)) {}",
            "",
            "  FenwickTreeRAQ(int n)",
            "      : n_(n), ft1_(FenwickTree<T>(n)), ft2_(FenwickTree<T>(n)) {}",
            "",
            "  // add val range [l, r)",
            "  void add(int l, int r, T val) {",
            "    add(ft1_, l, r, val);",
            "    add(ft2_, l, r, -val * (l - 1));",
            "    add(ft2_, r, n_, val * (r - l));",
            "  }",
            "",
            "  // get sum of [0, pos]",
            "  T get(int pos) const {",
            "    return ft1_.get(0, pos + 1) * pos + ft2_.get(0, pos + 1);",
            "  }",
            "",
            "  // get sum of [l, r]",
            "  T get(int l, int r) const { return get(r) - get(l - 1); }",
            "",
            " private:",
            "  int n_;",
            "  FenwickTree<T> ft1_;",
            "  FenwickTree<T> ft2_;",
            "",
            "  void add(FenwickTree<T>& ft, int l, int r, T val) {",
            "    ft.add(l, val);",
            "    ft.add(r, -val);",
            "  }",
            "};"
        ]
    },
    "kth_smallest_queue": {
        "prefix": "kth_smallest_queue",
        "body": [
            "template <class T, int K>",
            "class KthSmallestQueue {",
            " public:",
            "  KthSmallestQueue() {}",
            "",
            "  // O(logN)",
            "  void emplace(T val) noexcept {",
            "    if (int(lower_.size()) < K) {",
            "      lower_.emplace(val);",
            "    } else {  // lower_.size() == k \u3092\u4fdd\u3064",
            "      if (val >= lower_.top()) {",
            "        upper_.emplace(val);",
            "      } else {",
            "        lower_.emplace(val);",
            "        T tmp = lower_.top();",
            "        lower_.pop();",
            "        upper_.emplace(tmp);",
            "      }",
            "    }",
            "  }",
            "",
            "  // O(1)",
            "  T get() const {",
            "    assert(int(lower_.size()) == K);",
            "    return lower_.top();",
            "  }",
            "",
            " private:",
            "  std::priority_queue<T> lower_;",
            "  std::priority_queue<T, std::vector<T>, std::greater<T>> upper_;",
            "};"
        ]
    },
    "lazy_segment_tree": {
        "prefix": "lazy_segment_tree",
        "body": [
            "template <class M, class OM, class F1, class F2, class F3>",
            "class LazySegmentTree {",
            " public:",
            "  LazySegmentTree(const std::vector<M>& data, M ie, OM oie, F1 f1, F2 f2, F3 f3)",
            "      : ie_(ie), oie_(oie), f1_(f1), f2_(f2), f3_(f3) {",
            "    int sz = data.size();",
            "    n_ = 1, h_ = 0;",
            "    while (n_ < sz) n_ <<= 1, ++h_;",
            "    node_.assign(2 * n_, ie_);",
            "    lazy_.assign(2 * n_, oie_);",
            "    for (int i = 0; i < sz; ++i) node_[i + n_] = data[i];",
            "    for (int i = n_ - 1; i > 0; --i) node_[i] = f1_(node_[2 * i], node_[2 * i + 1]);",
            "  }",
            "",
            "  LazySegmentTree(int n, M ie, OM oie, F1 f1, F2 f2, F3 f3)",
            "      : ie_(ie), oie_(oie), f1_(f1), f2_(f2), f3_(f3) {",
            "    n_ = 1, h_ = 0;",
            "    while (n_ < n) n_ <<= 1, ++h_;",
            "    node_.assign(2 * n_, ie_);",
            "    lazy_.assign(2 * n_, oie_);",
            "    for (int i = n_ - 1; i > 0; --i) node_[i] = f1_(node_[2 * i], node_[2 * i + 1]);",
            "  }",
            "",
            "  // modify data_[l, r) -> f3_(data_[l], val), ... , f3_(data[r - 1], val)",
            "  void modify(int l, int r, OM val) {",
            "    if (l >= r) return;",
            "    thrust(l += n_);",
            "    thrust(r += n_ - 1);",
            "    for (int cl = l, cr = r + 1; cl < cr; cl >>= 1, cr >>= 1) {",
            "      if (cl & 1) lazy_[cl] = f3_(lazy_[cl], val), ++cl;",
            "      if (cr & 1) --cr, lazy_[cr] = f3_(lazy_[cr], val);",
            "    }",
            "    recalc(l);",
            "    recalc(r);",
            "  }",
            "",
            "  // return f1_[l, r)",
            "  M get(int l, int r) {",
            "    if (l >= r) return ie_;",
            "    thrust(l + n_);",
            "    thrust(r + n_ - 1);",
            "    M vl = ie_, vr = ie_;",
            "    for (l += n_, r += n_; l < r; l >>= 1, r >>= 1) {",
            "      if (l & 1) vl = f1_(vl, apply(l++));",
            "      if (r & 1) vr = f1_(apply(--r), vr);",
            "    }",
            "    return f1_(vl, vr);",
            "  }",
            "",
            " private:",
            "  int n_, h_;",
            "  std::vector<M> node_;",
            "  std::vector<OM> lazy_;",
            "  M ie_;",
            "  OM oie_;",
            "  F1 f1_;",
            "  F2 f2_;",
            "  F3 f3_;",
            "",
            "  inline void propagate(int pos) {",
            "    if (lazy_[pos] != oie_) {",
            "      lazy_[2 * pos] = f3_(lazy_[2 * pos], lazy_[pos]);",
            "      lazy_[2 * pos + 1] = f3_(lazy_[2 * pos + 1], lazy_[pos]);",
            "      node_[pos] = apply(pos);",
            "      lazy_[pos] = oie_;",
            "    }",
            "  }",
            "",
            "  inline M apply(int pos) {",
            "    if (lazy_[pos] == oie_) {",
            "      return node_[pos];",
            "    } else {",
            "      return f2_(node_[pos], lazy_[pos]);",
            "    }",
            "  }",
            "",
            "  inline void recalc(int pos) {",
            "    while (pos >>= 1) node_[pos] = f1_(apply(2 * pos), apply(2 * pos + 1));",
            "  }",
            "",
            "  inline void thrust(int pos) {",
            "    for (int i = h_; i > 0; --i) propagate(pos >> i);",
            "  }",
            "};"
        ]
    },
    "median_queue": {
        "prefix": "median_queue",
        "body": [
            "template <class T>",
            "class MedianQueue {",
            " public:",
            "  MedianQueue() {}",
            "",
            "  // O(logN)",
            "  void emplace(T val) noexcept {",
            "    if (lower_.empty()) {",
            "      lower_.emplace(val);",
            "    } else {",
            "      // lower_.size() == upper_.size() \u304b",
            "      // lower_.size() == upper_.size() + 1",
            "      // \u3092\u4fdd\u3064",
            "      if (val >= lower_.top()) {",
            "        upper_.emplace(val);",
            "      } else {",
            "        lower_.emplace(val);",
            "      }",
            "",
            "      if (upper_.size() > lower_.size()) {",
            "        T tmp = upper_.top();",
            "        upper_.pop();",
            "        lower_.emplace(tmp);",
            "      }",
            "      if (lower_.size() == upper_.size() + 2) {",
            "        T tmp = lower_.top();",
            "        lower_.pop();",
            "        upper_.emplace(tmp);",
            "      }",
            "    }",
            "  }",
            "",
            "  // O(1)",
            "  T get() const {",
            "    assert(!lower_.empty());",
            "    if (lower_.size() > upper_.size()) { // \u8981\u7d20\u304c\u5947\u6570\u500b",
            "      return lower_.top();",
            "    } else {  // \u8981\u7d20\u304c\u5076\u6570\u500b\u306e\u3068\u304d\u306f\u554f\u984c\u6587\u306e median \u306e\u5b9a\u7fa9\u3092\u3088\u304f\u8aad\u3080\u3053\u3068\uff01",
            "      return lower_.top();",
            "    }",
            "  }",
            "",
            " private:",
            "  std::priority_queue<T> lower_;",
            "  std::priority_queue<T, std::vector<T>, std::greater<T>> upper_;",
            "};"
        ]
    },
    "segment_tree": {
        "prefix": "segment_tree",
        "body": [
            "template <class M, class F>",
            "class SegmentTree {",
            " public:",
            "  SegmentTree(const std::vector<M>& data, M ie, F f)",
            "      : sz_(int(data.size())), ie_(ie), f_(f) {",
            "    n_ = 1;",
            "    while (n_ < sz_) n_ <<= 1;",
            "    node_.assign(2 * n_, ie_);",
            "    for (int i = 0; i < sz_; ++i) node_[i + n_] = data[i];",
            "    for (int i = n_ - 1; i > 0; --i)",
            "      node_[i] = f_(node_[2 * i], node_[2 * i + 1]);",
            "  }",
            "",
            "  SegmentTree(int n, M ie, F f) : sz_(n), ie_(ie), f_(f) {",
            "    n_ = 1;",
            "    while (n_ < sz_) n_ <<= 1;",
            "    node_.assign(2 * n_, ie_);",
            "  }",
            "",
            "  void update(int pos, M val) {",
            "    assert(0 <= pos && pos < n_);",
            "    pos += n_;",
            "    node_[pos] = val;",
            "    while (pos > 0) {",
            "      pos >>= 1;",
            "      node_[pos] = f_(node_[2 * pos], node_[2 * pos + 1]);",
            "    }",
            "  }",
            "",
            "  // return f_[l, r)",
            "  // if l >= r, return ie_",
            "  M get(int l, int r) const {",
            "    assert(0 <= l && l < n_ && 0 <= r && r < n_ + 1);",
            "    M vl = ie_, vr = ie_;",
            "    for (l += n_, r += n_; l < r; l >>= 1, r >>= 1) {",
            "      if (l & 1) vl = f_(vl, node_[l++]);",
            "      if (r & 1) vr = f_(node_[--r], vr);",
            "    }",
            "    return f_(vl, vr);",
            "  }",
            "",
            "  M operator[](int pos) const {",
            "    assert(0 <= pos && pos < n_);",
            "    return node_[n_ + pos];",
            "  }",
            "",
            "  // return f_[0, sz_)",
            "  M get_all() const { return node_[1]; }",
            "",
            "  // return the maximum i that satisfies cond(i) == true, where i >= l",
            "  // if there is no such i, return sz_",
            "  template <class Condition>",
            "  int max_right(int l, Condition cond) const {",
            "    assert(0 <= l && l <= sz_);",
            "    assert(cond(ie_));",
            "    if (l == sz_) return sz_;",
            "    l += n_;",
            "    M sm = ie_;",
            "",
            "    do {",
            "      while (~l & 1) l >>= 1;",
            "      if (!cond(f_(sm, node_[l]))) {",
            "        while (l < n_) {",
            "          l <<= 1;",
            "          if (cond(f_(sm, node_[l]))) {",
            "            sm = f_(sm, node_[l]);",
            "            ++l;",
            "          }",
            "        }",
            "        return l - n_;",
            "      }",
            "      sm = f_(sm, node_[l]);",
            "      ++l;",
            "    } while ((l & -l) != l);",
            "",
            "    return sz_;",
            "  }",
            "",
            "  // return the minimum i that satisfies cond(i) == true, where i <= r",
            "  // if there is no such i, return 0",
            "  // NOT VERIFIED!!",
            "  template <class Condition>",
            "  int min_left(int r, Condition cond) const {",
            "    assert(0 <= r && r <= sz_);",
            "    assert(cond(ie_));",
            "    if (r == 0) return 0;",
            "    r += n_;",
            "    M sm = ie_;",
            "",
            "    do {",
            "      --r;",
            "      while (r > 1 && (r & 1)) r >>= 1;",
            "      if (!cond(f_(node_[r], sm))) {",
            "        while (r < n_) {",
            "          r = (2 * r + 1);",
            "          if (cond(f_(node_[r], sm))) {",
            "            sm = f_(node_[r], sm);",
            "            --r;",
            "          }",
            "        }",
            "        return r + 1 - n_;",
            "      }",
            "      sm = f_(node_[r], sm);",
            "    } while ((r & -r) != r);",
            "",
            "    return 0;",
            "  }",
            "",
            " private:",
            "  int n_;",
            "  int sz_;",
            "  M ie_;",
            "  std::vector<M> node_;",
            "  F f_;",
            "};"
        ]
    },
    "sparse_table": {
        "prefix": "sparse_table",
        "body": [
            "template <class T, class F>",
            "class SparseTable {",
            "  // F must be idempotent function!",
            " public:",
            "  SparseTable(const std::vector<T>& data, F f)",
            "      : n_(int(data.size())), lg_(32 - __builtin_clz(n_)), f_(f) {",
            "    tab_.resize(lg_);",
            "    tab_[0] = data;",
            "    for (int j = 1; j < lg_; ++j) {",
            "      tab_[j].resize(n_ - (1 << j) + 1);",
            "      for (int i = 0; i <= n_ - (1 << j); ++i) {",
            "        tab_[j][i] = f_(tab_[j - 1][i], tab_[j - 1][i + (1 << (j - 1))]);",
            "      }",
            "    }",
            "  }",
            "",
            "  // return f_[l, r]",
            "  T get(int l, int r) {",
            "    assert(0 <= l && l <= r && r < n_);",
            "    int lg = 32 - __builtin_clz(r - l + 1) - 1;",
            "    return f_(tab_[lg][l], tab_[lg][r - (1 << lg) + 1]);",
            "  }",
            "",
            " private:",
            "  int n_;",
            "  int lg_;",
            "  F f_;",
            "  std::vector<std::vector<T>> tab_;",
            "};"
        ]
    },
    "unionfind_rank": {
        "prefix": "unionfind_rank",
        "body": [
            "class UnionFind {",
            " public:",
            "  UnionFind(int n) : n_(n) { init(); }",
            "",
            "  int root(int x) {",
            "    assert(0 <= x && x < n_);",
            "    if (par_[x] == -1)",
            "      return x;",
            "    else",
            "      return par_[x] = root(par_[x]);",
            "  }",
            "",
            "  bool same(int x, int y) {",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);",
            "    return root(x) == root(y);",
            "  }",
            "",
            "  void unite(int x, int y) {",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);",
            "    x = root(x);",
            "    y = root(y);",
            "    if (x == y) return;",
            "    if (rank_[x] < rank_[y]) std::swap(x, y);",
            "    if (rank_[x] == rank_[y]) ++rank_[x];",
            "    par_[y] = x;",
            "    return;",
            "  }",
            "",
            " private:",
            "  const int n_;",
            "  std::vector<int> par_;",
            "  std::vector<int> rank_;",
            "",
            "  void init() {",
            "    par_.assign(n_, -1);",
            "    rank_.assign(n_, 0);",
            "  }",
            "};"
        ]
    },
    "unionfind_size": {
        "prefix": "unionfind_size",
        "body": [
            "class UnionFind {",
            " public:",
            "  UnionFind(int n) : n_(n) { init(); }",
            "",
            "  int root(int x) {",
            "    assert(0 <= x && x < n_);",
            "    if (par_[x] < 0)",
            "      return x;",
            "    else",
            "      return par_[x] = root(par_[x]);",
            "  }",
            "",
            "  bool same(int x, int y) {",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);",
            "    return root(x) == root(y);",
            "  }",
            "",
            "  void unite(int x, int y) {",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);",
            "    x = root(x);",
            "    y = root(y);",
            "    if (x == y) return;",
            "    if (par_[x] > par_[y]) std::swap(x, y);",
            "    par_[x] += par_[y];",
            "    par_[y] = x;",
            "    return;",
            "  }",
            "",
            "  int size(int x) {",
            "    assert(0 <= x && x < n_);",
            "    return -par_[root(x)];",
            "  }",
            "",
            " private:",
            "  const int n_;",
            "  std::vector<int> par_;",
            "",
            "  void init() { par_.assign(n_, -1); }",
            "};"
        ]
    },
    "unionfind_weighted": {
        "prefix": "unionfind_weighted",
        "body": [
            "class UnionFind {",
            " public:",
            "  UnionFind(int n, int SUM_UNITY = 0) : n_(n), SUM_UNITY_(SUM_UNITY) {",
            "    init();",
            "  }",
            "",
            "  int root(int x) {",
            "    assert(0 <= x && x < n_);",
            "    if (par_[x] == -1) {",
            "      return x;",
            "    } else {",
            "      int r = root(par_[x]);",
            "      diff_weight_[x] += diff_weight_[par_[x]];",
            "      return par_[x] = r;",
            "    }",
            "  }",
            "",
            "  int weight(int x) {",
            "    assert(0 <= x && x < n_);",
            "    root(x);",
            "    return diff_weight_[x];",
            "  }",
            "",
            "  bool same(int x, int y) {",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);",
            "    return root(x) == root(y);",
            "  }",
            "",
            "  // y is w larger than x",
            "  void unite(int x, int y, int w) {",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);",
            "    w += weight(x);",
            "    w -= weight(y);",
            "    x = root(x);",
            "    y = root(y);",
            "    if (x == y) return;",
            "    if (rank_[x] < rank_[y]) {",
            "      std::swap(x, y);",
            "      w = -w;",
            "    }",
            "    if (rank_[x] == rank_[y]) ++rank_[x];",
            "    par_[y] = x;",
            "    diff_weight_[y] = w;",
            "    return;",
            "  }",
            "",
            "  int diff(int x, int y) {",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);",
            "    return weight(y) - weight(x);",
            "  }",
            "",
            " private:",
            "  const int n_;",
            "  const int SUM_UNITY_;",
            "  std::vector<int> par_;",
            "  std::vector<int> rank_;",
            "  std::vector<int> diff_weight_;",
            "",
            "  void init() {",
            "    par_.assign(n_, -1);",
            "    rank_.assign(n_, 0);",
            "    diff_weight_.assign(n_, SUM_UNITY_);",
            "  }",
            "};"
        ]
    },
    "debug": {
        "prefix": "debug",
        "body": [
            "template <class T, class U>",
            "std::ostream& operator<<(std::ostream& os, const std::pair<T, U>& p) {",
            "  return os << '(' << p.first << \", \" << p.second << ')';",
            "}",
            "",
            "template <class Tuple, std::size_t... Is>",
            "void tuple_out(std::ostream& os, const Tuple& tup, std::index_sequence<Is...>) {",
            "  ((os << (Is ? \", \" : \"(\") << std::get<Is>(tup)), ...) << \")\";",
            "}",
            "",
            "template <class... Args>",
            "std::ostream& operator<<(std::ostream& os, const std::tuple<Args...>& tup) {",
            "  tuple_out(os, tup, std::index_sequence_for<Args...>{});",
            "  return os;",
            "}",
            "",
            "template <class T>",
            "std::ostream& operator<<(std::ostream& os, const std::vector<T>& vec) {",
            "  bool first = true;",
            "  for (auto e : vec) os << (first ? \"{\" : \", \") << e, first = false;",
            "  return os << (first ? \"{}\" : \"}\");",
            "}",
            "",
            "template <class T, class Compare>",
            "std::ostream& operator<<(std::ostream& os, const std::set<T, Compare>& st) {",
            "  bool first = true;",
            "  for (auto e : st) os << (first ? \"{\" : \", \") << e, first = false;",
            "  return os << (first ? \"{}\" : \"}\");",
            "}",
            "",
            "template <class T, class U, class Compare>",
            "std::ostream& operator<<(std::ostream& os, const std::map<T, U, Compare>& mp) {",
            "  bool first = true;",
            "  for (auto e : mp) os << (first ? \"{\" : \", \") << e, first = false;",
            "  return os << (first ? \"{}\" : \"}\");",
            "}",
            "",
            "template <class T, class Compare>",
            "std::ostream& operator<<(std::ostream& os, const std::multiset<T, Compare>& st) {",
            "  bool first = true;",
            "  for (auto e : st) os << (first ? \"{\" : \", \") << e, first = false;",
            "  return os << (first ? \"{}\" : \"}\");",
            "}",
            "",
            "template <class T, class U, class Compare>",
            "std::ostream& operator<<(std::ostream& os, const std::multimap<T, U, Compare>& mp) {",
            "  bool first = true;",
            "  for (auto e : mp) os << (first ? \"{\" : \", \") << e, first = false;",
            "  return os << (first ? \"{}\" : \"}\");",
            "}",
            "",
            "#ifdef LOCAL",
            "#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]: \", debug_out(__VA_ARGS__)",
            "#else",
            "#define debug(...) void(0)",
            "#endif",
            "",
            "void debug_out() { std::cerr << '\\n'; }",
            "",
            "template <class Head, class... Tail>",
            "void debug_out(Head&& head, Tail&&... tail) {",
            "  std::cerr << head;",
            "  if (sizeof...(Tail) != 0) std::cerr << \", \";",
            "  debug_out(std::forward<Tail>(tail)...);",
            "}"
        ]
    },
    "fastio": {
        "prefix": "fastio",
        "body": [
            "namespace FastIO {",
            "class Scanner {",
            "  char buf[1 << 19];",
            "  char* cur = buf;",
            "",
            " public:",
            "  Scanner() { fread(buf, 1, std::size(buf), stdin); }",
            "",
            "  template <class T>",
            "  inline Scanner& operator>>(T& val) {",
            "    skip();",
            "    scan(val);",
            "    return *this;",
            "  }",
            "",
            " private:",
            "  inline void reload() {",
            "    int res = std::distance(cur, std::end(buf));",
            "    std::memcpy(buf, cur, res);",
            "    fread(std::next(buf, res), 1, std::size(buf) - res, stdin);",
            "    cur = buf;",
            "  }",
            "",
            "  inline void skip() {",
            "    while (*cur == ' ' || *cur == '\\n') ++cur;",
            "  }",
            "",
            "  inline void scan(int& num) {",
            "    if (std::next(cur, 20) >= std::end(buf)) reload();",
            "    bool neg = (*cur == '-');",
            "    if (neg) ++cur;",
            "    num = 0;",
            "    while (*cur >= '0') num = num * 10 + (*cur & 15), ++cur;",
            "    if (neg) num = -num;",
            "  }",
            "",
            "  inline void scan(int64& num) {",
            "    if (std::next(cur, 20) >= std::end(buf)) reload();",
            "    bool neg = (*cur == '-');",
            "    if (neg) ++cur;",
            "    num = 0;",
            "    while (*cur >= '0') num = num * 10 + (*cur & 15), ++cur;",
            "    if (neg) num = -num;",
            "  }",
            "};",
            "",
            "class Printer {",
            "  static constexpr int n = 10000;",
            "  char buf[1 << 19];",
            "  char table[n * 4];",
            "  char* cur = buf;",
            "",
            " public:",
            "  Printer() { build(); }",
            "",
            "  ~Printer() { flush(); }",
            "",
            "  template <class T>",
            "  inline Printer& operator<<(T val) {",
            "    print(val);",
            "    return *this;",
            "  }",
            "",
            "  template <class T>",
            "  inline void println(T val) {",
            "    print(val);",
            "    print('\\n');",
            "  }",
            "",
            " private:",
            "  void build() {",
            "    constexpr int base = 10;",
            "    for (int i = 0; i < n; ++i) {",
            "      int tmp = i;",
            "      for (int j = 3; j >= 0; --j) {",
            "        table[i * 4 + j] = tmp % base | 48;",
            "        tmp /= base;",
            "      }",
            "    }",
            "  }",
            "",
            "  inline void flush() {",
            "    fwrite(buf, 1, std::distance(buf, cur), stdout);",
            "    cur = buf;",
            "  }",
            "",
            "  inline int get_digit(int n) {",
            "    if (n >= int(1e5)) {",
            "      if (n >= int(1e8)) return 9;",
            "      if (n >= int(1e7)) return 8;",
            "      if (n >= int(1e6)) return 7;",
            "      return 6;",
            "    } else {",
            "      if (n >= int(1e4)) return 5;",
            "      if (n >= int(1e3)) return 4;",
            "      if (n >= int(1e2)) return 3;",
            "      if (n >= int(1e1)) return 2;",
            "      return 1;",
            "    }",
            "  }",
            "",
            "  inline int get_digit(int64 n) {",
            "    if (n >= int64(1e10)) {",
            "      if (n >= int64(1e14)) {",
            "        if (n >= int64(1e18)) return 19;",
            "        if (n >= int64(1e17)) return 18;",
            "        if (n >= int64(1e16)) return 17;",
            "        if (n >= int64(1e15)) return 16;",
            "        return 15;",
            "      } else {",
            "        if (n >= int64(1e14)) return 15;",
            "        if (n >= int64(1e13)) return 14;",
            "        if (n >= int64(1e12)) return 13;",
            "        if (n >= int64(1e11)) return 12;",
            "        return 11;",
            "      }",
            "    } else {",
            "      if (n >= int64(1e5)) {",
            "        if (n >= int64(1e9)) return 10;",
            "        if (n >= int64(1e8)) return 9;",
            "        if (n >= int64(1e7)) return 8;",
            "        if (n >= int64(1e6)) return 7;",
            "        return 6;",
            "      } else {",
            "        if (n >= int64(1e4)) return 5;",
            "        if (n >= int64(1e3)) return 4;",
            "        if (n >= int64(1e2)) return 3;",
            "        if (n >= int64(1e1)) return 2;",
            "        return 1;",
            "      }",
            "    }",
            "  }",
            "",
            "  inline void print(int num) {",
            "    if (std::next(cur, 20) >= std::end(buf)) flush();",
            "    if (num == 0) {",
            "      print('0');",
            "      return;",
            "    }",
            "    if (num < 0) {",
            "      print('-');",
            "      num = -num;",
            "    }",
            "    int len = get_digit(num);",
            "    int digits = len;",
            "    while (num >= n) {",
            "      std::memcpy(cur + len - 4, table + (num % n) * 4, 4);",
            "      num /= n;",
            "      len -= 4;",
            "    }",
            "    std::memcpy(cur, table + num * 4 + (4 - len), len);",
            "    cur += digits;",
            "  }",
            "",
            "  inline void print(int64 num) {",
            "    if (std::next(cur, 20) >= std::end(buf)) flush();",
            "    if (num == 0) {",
            "      print('0');",
            "      return;",
            "    }",
            "    if (num < 0) {",
            "      print('-');",
            "      num = -num;",
            "    }",
            "    int len = get_digit(num);",
            "    int digits = len;",
            "    while (num >= n) {",
            "      std::memcpy(cur + len - 4, table + (num % n) * 4, 4);",
            "      num /= n;",
            "      len -= 4;",
            "    }",
            "    std::memcpy(cur, table + num * 4 + (4 - len), len);",
            "    cur += digits;",
            "  }",
            "",
            "  inline void print(std::size_t num) {",
            "    print(static_cast<int>(num));",
            "  }",
            "",
            "  inline void print(std::ptrdiff_t num) {",
            "    print(static_cast<int>(num));",
            "  }",
            "",
            "  inline void print(char c) {",
            "    if (std::next(cur) >= std::end(buf)) flush();",
            "    *cur = c;",
            "    ++cur;",
            "  }",
            "",
            "  inline void print(const std::string& str) {",
            "    if (std::next(cur, str.size()) >= std::end(buf)) flush();",
            "    std::strcpy(cur, str.data());",
            "    std::advance(cur, str.size());",
            "  }",
            "",
            "  inline void print(const char* str) {",
            "    if (std::next(cur, std::strlen(str)) >= std::end(buf)) flush();",
            "    std::strcpy(cur, str);",
            "    std::advance(cur, std::strlen(str));",
            "  }",
            "};",
            "}  // namespace FastIO",
            "",
            "FastIO::Scanner in;",
            "FastIO::Printer out;"
        ]
    },
    "fastio2": {
        "prefix": "fastio2",
        "body": [
            "namespace FastIO {",
            "class Scanner {",
            " public:",
            "  Scanner() { fread(buf, 1, std::size(buf), stdin); }",
            "",
            "  template <class T>",
            "  inline Scanner& operator>>(T& val) {",
            "    skip();",
            "    scan(val);",
            "    return *this;",
            "  }",
            "",
            " private:",
            "  char buf[1 << 19];",
            "  char* cur = buf;",
            "",
            "  inline void reload() {",
            "    int res = std::distance(cur, std::end(buf));",
            "    std::memcpy(buf, cur, res);",
            "    fread(std::next(buf, res), 1, std::size(buf) - res, stdin);",
            "    cur = buf;",
            "  }",
            "",
            "  inline void skip() {",
            "    while (*cur == ' ' || *cur == '\\n') ++cur;",
            "  }",
            "",
            "  inline void scan(int& num) {",
            "    if (std::next(cur, 20) >= std::end(buf)) reload();",
            "    cur = const_cast<char*>(std::from_chars(cur, std::next(cur, 20), num).ptr);",
            "  }",
            "",
            "  inline void scan(int64& num) {",
            "    if (std::next(cur, 20) >= std::end(buf)) reload();",
            "    cur = const_cast<char*>(std::from_chars(cur, std::next(cur, 20), num).ptr);",
            "  }",
            "};",
            "",
            "class Printer {",
            " public:",
            "  Printer() {}",
            "",
            "  ~Printer() { flush(); }",
            "",
            "  template <class T>",
            "  inline Printer& operator<<(T val) {",
            "    print(val);",
            "    return *this;",
            "  }",
            "",
            "  template <class T>",
            "  inline void println(T val) {",
            "    print(val);",
            "    print('\\n');",
            "  }",
            "",
            " private:",
            "  char buf[1 << 19];",
            "  char* cur = buf;",
            "",
            "  void flush() {",
            "    fwrite(buf, 1, std::distance(buf, cur), stdout);",
            "    cur = buf;",
            "  }",
            "",
            "  inline void print(int num) {",
            "    if (std::next(cur, 20) >= std::end(buf)) flush();",
            "    cur = std::to_chars(cur, std::next(cur, 20), num).ptr;",
            "  }",
            "",
            "  inline void print(int64 num) {",
            "    if (std::next(cur, 20) >= std::end(buf)) flush();",
            "    cur = std::to_chars(cur, std::next(cur, 20), num).ptr;",
            "  }",
            "",
            "  inline void print(std::size_t num) {",
            "    print(static_cast<int>(num));",
            "  }",
            "",
            "  inline void print(std::ptrdiff_t num) {",
            "    print(static_cast<int>(num));",
            "  }",
            "",
            "  inline void print(char c) {",
            "    if (std::next(cur) >= std::end(buf)) flush();",
            "    *cur = c;",
            "    ++cur;",
            "  }",
            "",
            "  inline void print(const std::string& str) {",
            "    if (std::next(cur, str.size()) >= std::end(buf)) flush();",
            "    std::strcpy(cur, str.data());",
            "    std::advance(cur, str.size());",
            "  }",
            "",
            "  inline void print(const char* str) {",
            "    if (std::next(cur, std::strlen(str)) >= std::end(buf)) flush();",
            "    std::strcpy(cur, str);",
            "    std::advance(cur, std::strlen(str));",
            "  }",
            "};",
            "}  // namespace FastIO",
            "",
            "FastIO::Scanner in;",
            "FastIO::Printer out;"
        ]
    },
    "int128": {
        "prefix": "int128",
        "body": [
            "using int128 = __int128_t;",
            "",
            "int128 to_int128(const std::string& str) {",
            "  int128 val = 0;",
            "  bool neg = (str[0] == '-');",
            "  for (int i = neg ? 1 : 0; i < int(str.size()); ++i) {",
            "    val = val * 10 + (str[i] & 15);",
            "  }",
            "  return neg ? -val : val;",
            "}",
            "",
            "int128 to_int128(const char* str) { return to_int128(std::string(str)); }",
            "",
            "std::string to_string(const int128& val) {",
            "  std::string str = \"\";",
            "  int128 t = val;",
            "  bool neg = (t < 0);",
            "  if (neg) t = -t;",
            "  while (t) {",
            "    str += char(t % 10 | 48);",
            "    t /= 10;",
            "  }",
            "  if (neg) str += '-';",
            "  std::reverse(str.begin(), str.end());",
            "  return str;",
            "}",
            "",
            "std::istream& operator>>(std::istream& is, int128& val) {",
            "  std::string str;",
            "  is >> str;",
            "  val = to_int128(str);",
            "  return is;",
            "}",
            "",
            "std::ostream& operator<<(std::ostream& os, const int128& val) {",
            "  return os << to_string(val);",
            "}"
        ]
    },
    "pbds": {
        "prefix": "pbds",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "",
            "struct splitmix64_hash {",
            "  // http://xorshift.di.unimi.it/splitmix64.c",
            "  static uint64_t splitmix64(uint64_t x) {",
            "    x += 0x9e3779b97f4a7c15;",
            "    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
            "    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
            "    return x ^ (x >> 31);",
            "  }",
            "",
            "  size_t operator()(uint64_t x) const {",
            "    static const uint64_t FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();",
            "    return splitmix64(x + FIXED_RANDOM);",
            "  }",
            "};",
            "",
            "template <class Key, class Value, class Hash = splitmix64_hash>",
            "using hash_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;",
            "",
            "template <class Key, class Hash = splitmix64_hash>",
            "using hash_set = hash_map<Key, __gnu_pbds::null_type, Hash>;",
            "",
            "template <class T>",
            "using pbds_tree = __gnu_pbds::tree<T, __gnu_pbds::null_type, std::less<T>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;",
            "",
            "// find_by_order(k) : returns an iterator to the k-th largest element(0-origin)",
            "// order_of_key(k)  : returns the number of items in a set that are strictly smaller than k"
        ]
    },
    "template": {
        "prefix": "template",
        "body": [
            "#include <bits/stdc++.h>",
            "",
            "using namespace std;",
            "using int64 = long long;",
            "",
            "#define ALL(v) std::begin(v), std::end(v)",
            "#define RALL(v) std::rbegin(v), std::rend(v)",
            "",
            "template <class T> inline bool minimize(T& x, T y) { if (x > y) { x = y; return 1; } return 0; }",
            "template <class T> inline bool maximize(T& x, T y) { if (x < y) { x = y; return 1; } return 0; }",
            "",
            "int main() {",
            "  std::ios_base::sync_with_stdio(false);",
            "  std::cin.tie(nullptr);",
            "  std::cout << std::fixed << std::setprecision(17);",
            "",
            "",
            "  return 0;",
            "}"
        ]
    },
    "timer": {
        "prefix": "timer",
        "body": [
            "class Timer {",
            " public:",
            "  // (second)",
            "  double get_elapsed_time() {",
            "    return static_cast<double>(get_cycle() - start_) /",
            "           static_cast<double>(clock_frequency_);",
            "  }",
            "",
            "  void start() { start_ = get_cycle(); }",
            "",
            " private:",
            "  int64_t start_;",
            "  static constexpr int64_t clock_frequency_ = 1800000000; // Local",
            "  //static constexpr int64_t clock_frequency_ = 3000000000; // AtCoder",
            "  //static constexpr int64_t clock_frequency_ = 3600000000; // Codeforces",
            "  //static constexpr int64_t clock_frequency_ = 2300000000; // yukicoder",
            "",
            "  int64_t get_cycle() {",
            "    uint32_t low, high;",
            "    __asm__ volatile(\"rdtsc\" : \"=a\"(low), \"=d\"(high));",
            "    return (static_cast<int64_t>(low)) | (static_cast<int64_t>(high) << 32);",
            "  }",
            "};"
        ]
    },
    "utils": {
        "prefix": "utils",
        "body": [
            "inline void Yes(bool cond) noexcept { std::cout << (cond ? \"Yes\" : \"No\") << '\\n'; }",
            "",
            "inline void YES(bool cond) noexcept { std::cout << (cond ? \"YES\" : \"NO\") << '\\n'; }",
            "",
            "template <class T>",
            "std::istream& operator>>(std::istream& is, std::vector<T>& vec) {",
            "  for (T& e : vec) is >> e;",
            "  return is;",
            "}",
            "",
            "template <class T, class U>",
            "std::istream& operator>>(std::istream& is, std::pair<T, U>& p) {",
            "  return is >> p.first >> p.second;",
            "}",
            "",
            "template <class Tuple, std::size_t... Is>",
            "void tuple_in(std::istream& is, Tuple& tup, std::index_sequence<Is...>) {",
            "  ((is >> std::get<Is>(tup)), ...);",
            "}",
            "",
            "template <class... Args>",
            "std::istream& operator>>(std::istream& is, std::tuple<Args...>& tup) {",
            "  tuple_in(is, tup, std::index_sequence_for<Args...>{});",
            "  return is;",
            "}"
        ]
    },
    "xoroshiro": {
        "prefix": "xoroshiro",
        "body": [
            "// This is xoroshiro128+ 1.0",
            "// Reference : http://prng.di.unimi.it/xoroshiro128plus.c",
            "class Xoroshiro {",
            " public:",
            "  Xoroshiro() {",
            "    s[0] = static_cast<uint64_t>(std::chrono::steady_clock::now().time_since_epoch().count());",
            "    s[1] = s[0] ^ 0xffffffffful;",
            "    for (int i = 0; i < (1 << 6); ++i) next();",
            "  }",
            "",
            "  using result_type = uint64_t;",
            "  static constexpr uint64_t min() { return std::numeric_limits<result_type>::min(); }",
            "  static constexpr uint64_t max() { return std::numeric_limits<result_type>::max(); }",
            "",
            "  uint64_t operator()() { return next(); }",
            "",
            " private:",
            "  uint64_t s[2];",
            "",
            "  static inline uint64_t rotl(const uint64_t x, int k) {",
            "    return (x << k) | (x >> (64 - k));",
            "  }",
            "",
            "  uint64_t next() {",
            "    const uint64_t s0 = s[0];",
            "    uint64_t s1 = s[1];",
            "    const uint64_t result = s0 + s1;",
            "    s1 ^= s0;",
            "    s[0] = rotl(s0, 24) ^ s1 ^ (s1 << 16);",
            "    s[1] = rotl(s1, 37);",
            "",
            "    return result;",
            "  }",
            "};"
        ]
    },
    "2_sat": {
        "prefix": "2_sat",
        "body": [
            "class TwoSAT {",
            " public:",
            "  std::vector<bool> solution_;",
            "",
            "  TwoSAT(int n) : solution_(n), n_(n), g_(2 * n) {}",
            "",
            "  void add_clause(int i, bool f, int j, bool g) {",
            "    assert(0 <= i && i < n_);",
            "    assert(0 <= j && j < n_);",
            "    g_.add(2 * i + (f ? 0 : 1), 2 * j + (g ? 1 : 0));",
            "    g_.add(2 * j + (g ? 0 : 1), 2 * i + (f ? 1 : 0));",
            "  }",
            "",
            "  bool satisfiable() {",
            "    g_.build();",
            "    std::vector<int> ids = g_.ids_;",
            "    for (int i = 0; i < n_; ++i) {",
            "      if (ids[2 * i] == ids[2 * i + 1]) return false;",
            "      solution_[i] = ids[2 * i] < ids[2 * i + 1];",
            "    }",
            "    return true;",
            "  }",
            "",
            " private:",
            "  int n_;",
            "  scc_digraph<int> g_;",
            "};"
        ]
    },
    "bellman_ford": {
        "prefix": "bellman_ford",
        "body": [
            "template <class T>",
            "std::vector<T> bellmanford(const graph<T>& g, int s) {",
            "  assert(0 <= s && s < g.n_);",
            "  constexpr T kInfinity = std::numeric_limits<T>::max();",
            "  std::vector<T> dist(g.n_, kInfinity);",
            "  dist[s] = 0;",
            "  for (int i = 0; i < g.n_; ++i) {",
            "    for (const auto& [from, to, cost] : g.edges_) {",
            "      if (dist[from] == kInfinity) continue;",
            "      if (dist[to] > dist[from] + cost) {",
            "        dist[to] = dist[from] + cost;",
            "      }",
            "    }",
            "  }",
            "  for (const auto& [from, to, cost] : g.edges_) {",
            "    if (dist[from] == kInfinity) continue;",
            "    if (dist[to] > dist[from] + cost) return {};",
            "  }",
            "  return dist;",
            "}"
        ]
    },
    "bfs": {
        "prefix": "bfs",
        "body": [
            "template <class T>",
            "std::vector<T> bfs(const graph<T>& g, int s) {",
            "  std::vector<T> dist(g.n_, -1);",
            "  dist[s] = 0;",
            "  std::queue<int> que;",
            "  que.emplace(s);",
            "  while (!que.empty()) {",
            "    int cur = que.front();",
            "    que.pop();",
            "    for (int id : g.data_[cur]) {",
            "      const auto& [from, to, cost] = g.edges_[id];",
            "      int nxt = from ^ to ^ cur;",
            "      if (dist[nxt] != -1) continue;",
            "      dist[nxt] = dist[cur] + cost;",
            "      que.emplace(nxt);",
            "    }",
            "  }",
            "  return dist;",
            "}"
        ]
    },
    "bipartite": {
        "prefix": "bipartite",
        "body": [
            "template <class T>",
            "std::vector<int> is_bipartite(const graph<T>& g) {",
            "  std::vector<int> side(g.n_, -1);",
            "  std::queue<int> que;",
            "  for (int i = 0; i < g.n_; ++i) {",
            "    if (side[i] != -1) continue;",
            "    que.emplace(i);",
            "    side[i] = 0;",
            "    while (!que.empty()) {",
            "      int cur = que.front();",
            "      que.pop();",
            "      for (int id : g.data_[cur]) {",
            "        const auto& [from, to, cost] = g.edges_[id];",
            "        int nxt = from ^ to ^ cur;",
            "        if (side[nxt] == -1) {",
            "          side[nxt] = side[cur] ^ 1;",
            "          que.emplace(nxt);",
            "        } else {",
            "          if (side[cur] == side[nxt]) return {};",
            "        }",
            "      }",
            "    }",
            "  }",
            "  return side;",
            "}"
        ]
    },
    "dijkstra": {
        "prefix": "dijkstra",
        "body": [
            "template <class T>",
            "std::vector<T> dijkstra(const graph<T>& g, int s) {",
            "  assert(0 <= s && s < g.n_);",
            "  std::vector<T> dist(g.n_, std::numeric_limits<T>::max() / 2);",
            "  using Pair = std::pair<T, int>;",
            "  std::priority_queue<Pair, std::vector<Pair>, std::greater<Pair>> pq;",
            "  dist[s] = 0;",
            "  pq.emplace(0, s);",
            "  while (!pq.empty()) {",
            "    auto [d, v] = pq.top();",
            "    pq.pop();",
            "    if (dist[v] < d) continue;",
            "    for (int id : g.data_[v]) {",
            "      const auto& [from, to, cost] = g.edges_[id];",
            "      int nxt = from ^ to ^ v;",
            "      if (dist[nxt] > dist[v] + cost) {",
            "        dist[nxt] = dist[v] + cost;",
            "        pq.emplace(dist[nxt], nxt);",
            "      }",
            "    }",
            "  }",
            "  return dist;",
            "}"
        ]
    },
    "dinic": {
        "prefix": "dinic",
        "body": [
            "template <class T>",
            "class Dinic {",
            " public:",
            "  Dinic(int node_size) : node_size_(node_size) { init(); }",
            "",
            "  void add(int from, int to, T cost) {",
            "    assert(0 <= from && from < node_size_ && 0 <= to && to < node_size_);",
            "    graph_[from].emplace_back((edge){to, cost, int(graph_[to].size())});",
            "    graph_[to].emplace_back((edge){from, T(0), int(graph_[from].size()) - 1});",
            "  }",
            "",
            "  T max_flow(int s, int t) {",
            "    T flow = 0;",
            "    for (;;) {",
            "      bfs(s);",
            "      if (level_[t] < 0) return flow;",
            "      std::fill(iter_.begin(), iter_.end(), 0);",
            "      T f;",
            "      while ((f = dfs(s, t, std::numeric_limits<T>::max() / 2)) > 0) {",
            "        flow += f;",
            "      }",
            "    }",
            "  }",
            "",
            " private:",
            "  struct edge {",
            "    int to;",
            "    T cap;",
            "    int rev;",
            "  };",
            "  int node_size_;",
            "  std::vector<std::vector<edge>> graph_;",
            "  std::vector<int> level_;",
            "  std::vector<int> iter_;",
            "",
            "  void init() {",
            "    graph_.resize(node_size_);",
            "    level_.assign(node_size_, 0);",
            "    iter_.assign(node_size_, 0);",
            "  }",
            "",
            "  void bfs(int s) {",
            "    std::fill(level_.begin(), level_.end(), -1);",
            "    std::queue<int> que;",
            "    level_[s] = 0;",
            "    que.emplace(s);",
            "    while (!que.empty()) {",
            "      int cur = que.front();",
            "      que.pop();",
            "      for (const edge& next : graph_[cur]) {",
            "        if (next.cap > 0 && level_[next.to] < 0) {",
            "          level_[next.to] = level_[cur] + 1;",
            "          que.emplace(next.to);",
            "        }",
            "      }",
            "    }",
            "  }",
            "",
            "  T dfs(int v, int t, int f) {",
            "    if (v == t) return f;",
            "    for (int& i = iter_[v]; i < (int)graph_[v].size(); ++i) {",
            "      edge& e = graph_[v][i];",
            "      if (e.cap > 0 && level_[v] < level_[e.to]) {",
            "        T d = dfs(e.to, t, min(f, e.cap));",
            "        if (d > 0) {",
            "          e.cap -= d;",
            "          graph_[e.to][e.rev].cap += d;",
            "          return d;",
            "        }",
            "      }",
            "    }",
            "    return 0;",
            "  }",
            "};"
        ]
    },
    "graph": {
        "prefix": "graph",
        "body": [
            "template <class T>",
            "class graph {",
            " public:",
            "  graph(int n) : n_(n) { data_.resize(n_); }",
            "  struct edge {",
            "    int from, to;",
            "    T cost;",
            "",
            "    edge(int from_, int to_, T cost_) : from(from_), to(to_), cost(cost_) {}",
            "  };",
            "  int n_;",
            "  std::vector<std::vector<int>> data_;",
            "  std::vector<edge> edges_;",
            "",
            "  virtual void add(int from, int to, T cost) = 0;",
            "};",
            "",
            "template <class T>",
            "class forest : public graph<T> {",
            " public:",
            "  using graph<T>::n_;",
            "  using graph<T>::data_;",
            "  using graph<T>::edges_;",
            "",
            "  forest(int n) : graph<T>(n) {}",
            "",
            "  void add(int from, int to, T cost = 1) {",
            "    assert(0 <= from && from < n_ && 0 <= to && to < n_);",
            "    int id = edges_.size();",
            "    assert(id < n_ - 1);",
            "    data_[from].emplace_back(id);",
            "    data_[to].emplace_back(id);",
            "    edges_.emplace_back(from, to, cost);",
            "  }",
            "};",
            "",
            "template <class T>",
            "class digraph : public graph<T> {",
            " public:",
            "  using graph<T>::n_;",
            "  using graph<T>::data_;",
            "  using graph<T>::edges_;",
            "",
            "  digraph(int n) : graph<T>(n) {}",
            "",
            "  void add(int from, int to, T cost = 1) {",
            "    assert(0 <= from && from < n_ && 0 <= to && to < n_);",
            "    int id = edges_.size();",
            "    data_[from].emplace_back(id);",
            "    edges_.emplace_back(from, to, cost);",
            "  }",
            "",
            "  digraph<T> reverse() const {",
            "    digraph<T> rev(n_);",
            "    for (const auto& [from, to, cost] : edges_) {",
            "      rev.add(to, from, cost);",
            "    }",
            "    return rev;",
            "  }",
            "};",
            "",
            "template <class T>",
            "class undigraph : public graph<T> {",
            " public:",
            "  using graph<T>::n_;",
            "  using graph<T>::data_;",
            "  using graph<T>::edges_;",
            "",
            "  undigraph(int n) : graph<T>(n) {}",
            "",
            "  void add(int from, int to, T cost = 1) {",
            "    assert(0 <= from && from < n_ && 0 <= to && to < n_);",
            "    int id = edges_.size();",
            "    data_[from].emplace_back(id);",
            "    data_[to].emplace_back(id);",
            "    edges_.emplace_back(from, to, cost);",
            "  }",
            "};"
        ]
    },
    "grid_to_digraph": {
        "prefix": "grid_to_digraph",
        "body": [
            "digraph<int> grid_to_digraph(const std::vector<std::string>& sv) {",
            "  int h = sv.size(), w = sv[0].size();",
            "  digraph<int> g(h * w);",
            "  constexpr int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};",
            "  auto Out = [&](int x, int y) { return (x < 0 || x >= h || y < 0 || y >= w); };",
            "  auto Compress = [&](int x, int y) { return x * w + y; };",
            "  for (int i = 0; i < h; ++i) {",
            "    for (int j = 0; j < w; ++j) {",
            "      for (int k = 0; k < 4; ++k) {",
            "        int nx = i + dx[k], ny = j + dy[k];",
            "        if (Out(nx, ny)) continue;",
            "        if (...) {",
            "          g.add(Compress(i, j), Compress(nx, ny));",
            "        }",
            "      }",
            "    }",
            "  }",
            "  return g;",
            "}"
        ]
    },
    "lca": {
        "prefix": "lca",
        "body": [
            "template <class T>",
            "class lca_forest : public forest<T> {",
            " public:",
            "  using forest<T>::n_;",
            "  using forest<T>::data_;",
            "  using forest<T>::edges_;",
            "",
            "  lca_forest(int n) : forest<T>(n), lg_(32 - __builtin_clz(n)) { init(); }",
            "",
            "  void build(int r = 0) {",
            "    dfs(r, -1, 0);",
            "    for (int i = 0; i + 1 < lg_; ++i) {",
            "      for (int j = 0; j < n_; ++j) {",
            "        if (par_[i][j] < 0) {",
            "          par_[i + 1][j] = -1;",
            "        } else {",
            "          par_[i + 1][j] = par_[i][par_[i][j]];",
            "        }",
            "      }",
            "    }",
            "  }",
            "",
            "  // use after build()",
            "  int lca(int u, int v) {",
            "    assert(0 <= u && u < n_ && 0 <= v && v < n_);",
            "    if (dep_[u] > dep_[v]) std::swap(u, v);",
            "    for (int i = 0; i < lg_; ++i) {",
            "      if ((dep_[v] - dep_[u]) >> i & 1) {",
            "        v = par_[i][v];",
            "      }",
            "    }",
            "    if (u == v) return u;",
            "    for (int i = lg_ - 1; i >= 0; --i) {",
            "      if (par_[i][u] != par_[i][v]) {",
            "        u = par_[i][u];",
            "        v = par_[i][v];",
            "      }",
            "    }",
            "    return par_[0][u];",
            "  }",
            "",
            "  int dist(int u, int v) {",
            "    assert(0 <= u && u < n_ && 0 <= v && v < n_);",
            "    return dep_[u] + dep_[v] - 2 * dep_[lca(u, v)];",
            "  }",
            "",
            " private:",
            "  int lg_;",
            "  std::vector<std::vector<int>> par_;",
            "  std::vector<int> dep_;",
            "",
            "  void dfs(int cur, int pre, int d) {",
            "    par_[0][cur] = pre;",
            "    dep_[cur] = d;",
            "    for (int id : data_[cur]) {",
            "      const auto& [from, to, cost] = edges_[id];",
            "      int nxt = from ^ to ^ cur;",
            "      if (nxt == pre) continue;",
            "      dfs(nxt, cur, d + 1);",
            "    }",
            "  }",
            "",
            "  void init() {",
            "    dep_.resize(n_);",
            "    par_.assign(lg_, std::vector<int>(n_, -1));",
            "  }",
            "};"
        ]
    },
    "scc": {
        "prefix": "scc",
        "body": [
            "template <class T>",
            "class scc_digraph : public digraph<T> {",
            " public:",
            "  using digraph<T>::n_;",
            "  using digraph<T>::data_;",
            "  using digraph<T>::edges_;",
            "",
            "  std::vector<int> ids_;",
            "  std::vector<std::vector<int>> components_;",
            "",
            "  scc_digraph(int n)",
            "      : digraph<T>(n),",
            "        ids_(n),",
            "        components_(n),",
            "        cnt_(0),",
            "        visited_(n, false),",
            "        rg_(n) {}",
            "",
            "  void build() {",
            "    for (int i = 0; i < n_; ++i) {",
            "      if (!visited_[i]) dfs(i);",
            "    }",
            "    visited_.assign(n_, false);",
            "    rg_ = (*this).reverse();",
            "    for (int i = n_ - 1; i >= 0; --i) {",
            "      if (!visited_[order_[i]]) dfs2(order_[i], cnt_++);",
            "    }",
            "    components_.resize(cnt_);",
            "  }",
            "",
            "  int operator[](int v) const noexcept {",
            "    assert(0 <= v && v < n_);",
            "    return ids_[v];",
            "  }",
            "",
            " private:",
            "  int cnt_;",
            "  std::vector<int> order_;",
            "  std::vector<bool> visited_;",
            "  digraph<T> rg_;",
            "",
            "  void dfs(int cur) {",
            "    visited_[cur] = true;",
            "    for (int id : data_[cur]) {",
            "      const auto& [from, to, cost] = edges_[id];",
            "      int nxt = from ^ to ^ cur;",
            "      if (visited_[nxt]) continue;",
            "      dfs(nxt);",
            "    }",
            "    order_.emplace_back(cur);",
            "  }",
            "",
            "  void dfs2(int cur, int k) {",
            "    visited_[cur] = true;",
            "    components_[k].emplace_back(cur);",
            "    ids_[cur] = k;",
            "    for (int id : rg_.data_[cur]) {",
            "      const auto& [from, to, cost] = rg_.edges_[id];",
            "      int nxt = from ^ to ^ cur;",
            "      if (visited_[nxt]) continue;",
            "      dfs2(nxt, k);",
            "    }",
            "  }",
            "};"
        ]
    },
    "spfa": {
        "prefix": "spfa",
        "body": [
            "template <class T>",
            "std::vector<T> SPFA(const graph<T>& g, int s) {",
            "  assert(0 <= s && s < g.n_);",
            "  std::vector<T> dist(g.n_, std::numeric_limits<T>::max());",
            "  std::vector<int> pend(g.n_, 0);",
            "  std::vector<int> times(g.n_, 0);",
            "  std::queue<int> que;",
            "  que.emplace(s);",
            "  pend[s] = true;",
            "  ++times[s];",
            "  dist[s] = 0;",
            "  while (!que.empty()) {",
            "    int cur = que.front(); que.pop();",
            "    pend[cur] = false;",
            "    for (int id : g.data_[cur]) {",
            "      const auto& [from, to, cost] = g.edges_[id];",
            "      int nxt = from ^ to ^ cur;",
            "      T ncost = dist[cur] + cost;",
            "      if (ncost >= dist[nxt]) continue;",
            "      dist[nxt] = ncost;",
            "      if (!pend[nxt]) {",
            "        if (++times[nxt] >= g.n_) {",
            "          return {};",
            "        }",
            "        pend[nxt] = true;",
            "        que.emplace(nxt);",
            "      }",
            "    }",
            "  }",
            "  return dist;",
            "}"
        ]
    },
    "tree_diameter": {
        "prefix": "tree_diameter",
        "body": [
            "template <class T>",
            "T tree_diameter(const forest<T>& g) {",
            "  std::vector<T> d1 = bfs(g, 0);",
            "  std::vector<T> d2 = bfs(g, std::distance(d1.begin(), std::max_element(d1.begin(), d1.end())));",
            "  return *std::max_element(d2.begin(), d2.end());",
            "}"
        ]
    },
    "binary_gcd": {
        "prefix": "binary_gcd",
        "body": [
            "template <class T>",
            "T binary_gcd(T x, T y) {",
            "  assert(x >= 0 && y >= 0);",
            "  unsigned long long tx = x, ty = y;",
            "  if (!tx || !ty) return tx ^ ty ^ 0;",
            "  int s = __builtin_ctzll(tx | ty);",
            "  tx >>= __builtin_ctzll(tx);",
            "  do {",
            "    ty >>= __builtin_ctzll(ty);",
            "    if (tx > ty) std::swap(tx, ty);",
            "    ty -= tx;",
            "  } while (ty);",
            "  return static_cast<T>(tx << s);",
            "}"
        ]
    },
    "divisor": {
        "prefix": "divisor",
        "body": [
            "template<class T>",
            "std::vector<T> divisor(T n) {",
            "  std::vector<T> res;",
            "  for (T i = 1; i * i <= n; ++i) {",
            "    if (n % i == 0){",
            "      res.emplace_back(i);",
            "      if (i * i != n){",
            "        res.emplace_back(n / i);",
            "      }",
            "    }",
            "  }",
            "  std::sort(res.begin(), res.end());",
            "",
            "  return res;",
            "}"
        ]
    },
    "extgcd": {
        "prefix": "extgcd",
        "body": [
            "// find x, y such that a * x + b * y = gcd(a, b)",
            "template <class T>",
            "T extgcd(T a, T b, T& x, T& y) {",
            "  T d = a;",
            "  if (b) {",
            "    d = extgcd(b, a % b, y, x);",
            "    y -= (a / b) * x;",
            "  } else {",
            "    x = 1, y = 0;",
            "  }",
            "  return d;",
            "}"
        ]
    },
    "factor": {
        "prefix": "factor",
        "body": [
            "template <class T>",
            "inline std::vector<T> connect(const std::vector<T> &a,",
            "                              const std::vector<T> &b) {",
            "  std::vector<T> c(a.size() + b.size());",
            "  std::merge(a.begin(), a.end(), b.begin(), b.end(), c.begin());",
            "  return c;",
            "}",
            "",
            "template <class T>",
            "std::vector<T> factor(T n) {",
            "  if (n <= 1) return {};",
            "  if (is_prime(n)) return {n};",
            "  if (~n & 1) return connect({2}, factor(n >> 1));",
            "  for (T c = 1;; ++c) {",
            "    T x = 2, y = 2, d;",
            "    do {",
            "      x = (int128(x * x + c)) % n;",
            "      y = (int128(y * y + c)) % n;",
            "      y = (int128(y * y + c)) % n;",
            "      d = binary_gcd(x - y, n);",
            "    } while (d == 1);",
            "    if (d < n) return connect(factor(d), factor(n / d));",
            "  }",
            "}"
        ]
    },
    "fast_divisor": {
        "prefix": "fast_divisor",
        "body": [
            "template <class T>",
            "std::vector<T> divisor(T n) {",
            "  std::vector<T> v1 = factor(n);",
            "  auto v2 = RunLengthEncoding(v1);",
            "  std::vector<T> div;",
            "  int sz = v2.size();",
            "  auto dfs = [&](auto&& self, T val, int d) -> void {",
            "    if (d == sz) {",
            "      div.emplace_back(val);",
            "      return;",
            "    }",
            "    T cur = 1;",
            "    auto [pr, cnt] = v2[d];",
            "    for (int i = 0; i < cnt + 1; ++i, cur *= pr) {",
            "      self(self, val * cur, d + 1);",
            "    }",
            "  };",
            "  dfs(dfs, 1, 0);",
            "  std::sort(div.begin(), div.end());",
            "",
            "  return div;",
            "}"
        ]
    },
    "miller_rabin": {
        "prefix": "miller_rabin",
        "body": [
            "using int128 = __int128_t;",
            "",
            "int128 power_i128(int128 base, int128 e, int128 mod) {",
            "  int128 res = 1;",
            "  base %= mod;",
            "  while (e) {",
            "    if (e & 1) (res *= base) %= mod;",
            "    (base *= base) %= mod;",
            "    e >>= 1;",
            "  }",
            "  return res;",
            "}",
            "",
            "bool is_prime(int64 n) {",
            "  if (n < 2 || ~n & 1) return n == 2;",
            "  int s = __builtin_ctzll(n - 1);",
            "  int64 d = (n - 1) >> s;",
            "  for (int64 base : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) {",
            "    int128 x = base % n;",
            "    if (!x) continue;",
            "    x = power_i128(x, d, n);",
            "    if (x == 1 || x == n - 1) continue;",
            "    bool ok = false;",
            "    for (int i = 0; i < s - 1; ++i) {",
            "      (x *= x) %= n;",
            "      if (x == n - 1) {",
            "        ok = true; break;",
            "      }",
            "    }",
            "    if (!ok) return false;",
            "  }",
            "  return true;",
            "}"
        ]
    },
    "modint": {
        "prefix": "modint",
        "body": [
            "template <class T>",
            "T inverse(T a, T m) {",
            "  T u = 0, v = 1;",
            "  while (a != 0) {",
            "    T t = m / a;",
            "    m -= t * a;",
            "    std::swap(a, m);",
            "    u -= t * v;",
            "    std::swap(u, v);",
            "  }",
            "  assert(m == 1);",
            "  return u;",
            "}",
            "",
            "template <int Mod>",
            "class Modular {",
            " public:",
            "  constexpr Modular(int64 val = 0) : val_(val % mod()) {",
            "    if (val_ < 0) val_ += mod();",
            "  }",
            "",
            "  const int64& operator()() const noexcept { return val_; }",
            "",
            "  constexpr int mod() const noexcept { return Mod; }",
            "",
            "  constexpr Modular& operator+=(const Modular& other) noexcept {",
            "    if ((val_ += other.val_) >= mod()) val_ -= mod();",
            "    return *this;",
            "  }",
            "",
            "  constexpr Modular& operator-=(const Modular& other) noexcept {",
            "    if ((val_ -= other.val_) < 0) val_ += mod();",
            "    return *this;",
            "  }",
            "",
            "  constexpr Modular& operator*=(const Modular& other) noexcept {",
            "    (val_ *= other.val_) %= mod();",
            "    if (val_ < 0) val_ += mod();",
            "    return *this;",
            "  }",
            "",
            "  constexpr Modular& operator/=(const Modular& other) noexcept {",
            "    return *this *= Modular(inverse(other.val_, static_cast<int64>(mod())));",
            "  }",
            "",
            "  constexpr Modular& operator++() noexcept { return *this += 1; }",
            "",
            "  constexpr Modular& operator--() noexcept { return *this -= 1; }",
            "",
            "  constexpr Modular operator-() const noexcept { return Modular(-val_); }",
            "",
            "  friend std::istream& operator>>(std::istream& is, Modular& num) {",
            "    int64 x;",
            "    is >> x;",
            "    num = Modular(x);",
            "    return is;",
            "  }",
            "",
            "  friend std::ostream& operator<<(std::ostream& os, const Modular& num) {",
            "    return os << num();",
            "  }",
            "",
            " private:",
            "  int64 val_;",
            "};",
            "",
            "constexpr int mod = int(1e9) + 7;",
            "using Mint = Modular<mod>;",
            "",
            "Mint operator+(const Mint& lhs, const Mint& rhs) noexcept {",
            "  return Mint(lhs) += rhs;",
            "}",
            "",
            "Mint operator-(const Mint& lhs, const Mint& rhs) noexcept {",
            "  return Mint(lhs) -= rhs;",
            "}",
            "",
            "Mint operator*(const Mint& lhs, const Mint& rhs) noexcept {",
            "  return Mint(lhs) *= rhs;",
            "}",
            "",
            "Mint operator/(const Mint& lhs, const Mint& rhs) noexcept {",
            "  return Mint(lhs) /= rhs;",
            "}",
            "",
            "bool operator==(const Mint& lhs, const Mint& rhs) noexcept {",
            "  return lhs() == rhs();",
            "}",
            "",
            "bool operator!=(const Mint& lhs, const Mint& rhs) noexcept {",
            "  return !(lhs() == rhs());",
            "}",
            "",
            "template <class T>",
            "Mint power(const Mint& a, T b) {",
            "  assert(b >= 0);",
            "  Mint x = a, res = 1;",
            "  while (b) {",
            "    if (b & 1) res *= x;",
            "    x *= x;",
            "    b >>= 1;",
            "  }",
            "  return res;",
            "}",
            "",
            "// \u4e8c\u9805\u4fc2\u6570\u30c6\u30fc\u30d6\u30eb\u3092\u5fc5\u8981\u306a\u3068\u3053\u308d\u307e\u3067\u4f5c\u308b",
            "// inv \u3060\u3051\u524d\u8a08\u7b97\u3057\u305f\u3044\u3068\u304d\u306f choose(200000, 1) \u3068\u304b\u3067\u9069\u5f53\u306b\u7a7a\u547c\u3073\u51fa\u3057\u3059\u308c\u3070\u3044\u3044",
            "// std::vector<Mint> fact{1, 1};",
            "// std::vector<Mint> inv{0, 1};",
            "// std::vector<Mint> inv_fact{1, 1};",
            "",
            "// Mint choose(int n, int k) noexcept {",
            "//   if (n < k || n < 0 || k < 0) return 0;",
            "//   while (int(fact.size()) < n + 1) {",
            "//     int sz = fact.size();",
            "//     fact.emplace_back(fact.back() * sz);",
            "//     inv.emplace_back(mod - inv[mod % sz] * (mod / sz));",
            "//     inv_fact.emplace_back(inv_fact.back() * inv.back());",
            "//   }",
            "//   return fact[n] * inv_fact[k] * inv_fact[n - k];",
            "// }"
        ]
    },
    "osa_k": {
        "prefix": "osa_k",
        "body": [
            "class osa_k {",
            "  static constexpr int n_ = 1000000 + 5;",
            "",
            " public:",
            "  osa_k() { build(); }",
            "",
            "  std::vector<std::pair<int, int>> prime_factor(int n) {",
            "    std::vector<std::pair<int, int>> res;",
            "    while (n != 1) {",
            "      int p = min_factor[n];",
            "      int cnt = 0;",
            "      while (min_factor[n] == p) ++cnt, n /= p;",
            "      res.emplace_back(p, cnt);",
            "    }",
            "    return res;",
            "  }",
            "",
            " private:",
            "  int min_factor[n_ + 1];",
            "",
            "  void build() {",
            "    std::fill(min_factor, min_factor + n_ + 1, 0);",
            "    std::vector<int> pr;",
            "    for (int i = 2; i <= n_; ++i) {",
            "      if (!min_factor[i]) {",
            "        min_factor[i] = i;",
            "        pr.emplace_back(i);",
            "      }",
            "      for (int j = 0; j < (int)pr.size() && pr[j] <= min_factor[i] && i * pr[j] <= n_; ++j) {",
            "        min_factor[i * pr[j]] = pr[j];",
            "      }",
            "    }",
            "  }",
            "};"
        ]
    },
    "prime_factorization": {
        "prefix": "prime_factorization",
        "body": [
            "template<class T>",
            "std::map<T, int> prime_fact(T n){",
            "  std::map<T, int> result;",
            "  for (T i = 2; i * i <= n; ++i){",
            "    if (n % i != 0) continue;",
            "    int cnt = 0;",
            "    while (n % i == 0){",
            "      n /= i; ++cnt;",
            "    }",
            "    result[i] = cnt;",
            "  }",
            "  if (n != 1) result[n] = 1;",
            "  return result;",
            "}"
        ]
    },
    "sieve": {
        "prefix": "sieve",
        "body": [
            "std::vector<int> LinearTimeSieve() {",
            "  constexpr int n = 1000000;",
            "  int lp[n + 1];",
            "  std::fill(lp, lp + n + 1, 0);",
            "  std::vector<int> pr;",
            "  for (int i = 2; i <= n; ++i) {",
            "    if (!lp[i]) {",
            "      lp[i] = i;",
            "      pr.emplace_back(i);",
            "    }",
            "    for (int j = 0; j < (int)pr.size() && pr[j] <= lp[i] && i * pr[j] <= n;",
            "         ++j) {",
            "      lp[i * pr[j]] = pr[j];",
            "    }",
            "  }",
            "  return pr;",
            "}"
        ]
    },
    "totient": {
        "prefix": "totient",
        "body": [
            "template <class T>",
            "T Totient(T n) {",
            "  T res = n;",
            "  for (T i = 2; i * i <= n; ++i) {",
            "    if (n % i != 0) continue;",
            "    (res /= i) *= (i - 1);",
            "    while (n % i == 0) n /= i;",
            "  }",
            "  if (n != 1) (res /= n) *= (n - 1);",
            "  return res;",
            "}"
        ]
    },
    "lcs": {
        "prefix": "lcs",
        "body": [
            "std::string LCS(const std::string& str1, const std::string& str2) {",
            "  int n1 = str1.size(), n2 = str2.size();",
            "  std::vector<std::vector<int>> dp(n1 + 1, std::vector<int>(n2 + 1, 0));",
            "  for (int i = 0; i < n1; ++i) {",
            "    for (int j = 0; j < n2; ++j) {",
            "      if (str1[i] == str2[j]) {",
            "        dp[i + 1][j + 1] = dp[i][j] + 1;",
            "      } else {",
            "        dp[i + 1][j + 1] = std::max(dp[i + 1][j], dp[i][j + 1]);",
            "      }",
            "    }",
            "  }",
            "  int c1 = n1, c2 = n2;",
            "  std::string ret = \"\";",
            "  while (c1 > 0 && c2 > 0) {",
            "    if (str1[c1 - 1] == str2[c2 - 1]) {",
            "      ret += str1[c1 - 1];",
            "      --c1;",
            "      --c2;",
            "    } else {",
            "      if (dp[c1][c2] == dp[c1][c2 - 1]) {",
            "        --c2;",
            "      } else {",
            "        --c1;",
            "      }",
            "    }",
            "  }",
            "  std::reverse(ret.begin(), ret.end());",
            "  return ret;",
            "}"
        ]
    },
    "levenshtein_distance": {
        "prefix": "levenshtein_distance",
        "body": [
            "int Levenshtein_distance(const std::string& str1, const std::string& str2) {",
            "  int n1 = str1.size(), n2 = str2.size();",
            "  std::vector<std::vector<int>> dp(n1 + 1, std::vector<int>(n2 + 1, 0));",
            "  for (int i = 0; i <= n1; ++i) dp[i][0] = i;",
            "  for (int i = 0; i <= n2; ++i) dp[0][i] = i;",
            "  for (int i = 0; i < n1; ++i) {",
            "    for (int j = 0; j < n2; ++j) {",
            "      const int cost = (str1[i] != str2[j]);",
            "      dp[i + 1][j + 1] =",
            "          std::min({dp[i + 1][j] + 1, dp[i][j + 1] + 1, dp[i][j] + cost});",
            "    }",
            "  }",
            "  return dp[n1][n2];",
            "}"
        ]
    },
    "manacher": {
        "prefix": "manacher",
        "body": [
            "std::vector<int> Manacher(const std::string& str) {",
            "  int n = str.size();",
            "  std::vector<int> res(n);",
            "  int i = 0, j = 0;",
            "  while (i < n) {",
            "    while (i - j >= 0 && i + j < n && str[i - j] == str[i + j]) ++j;",
            "    res[i] = j;",
            "    int k = 1;",
            "    while (i - k >= 0 && k + res[i - k] < j) res[i + k] = res[i - k], ++k;",
            "    i += k;",
            "    j -= k;",
            "  }",
            "  return res;",
            "}"
        ]
    },
    "nextchar": {
        "prefix": "nextchar",
        "body": [
            "class NextChar {",
            " public:",
            "  NextChar(const std::string& str) : str_(str) { build(); }",
            "",
            "  // returns the first position in str[pos:n_) that c appears",
            "  // if c is not in str[pos:n_), returns n_",
            "  int find(int pos, char c) const {",
            "    assert(0 <= pos && pos < n_);",
            "    return table_[c - 'a'][pos];",
            "  }",
            "",
            "  // returns whether str contains c or not",
            "  bool contains(char c) const { return find(0, c) != n_; }",
            "",
            " private:",
            "  int n_;",
            "  std::string str_;",
            "  std::vector<std::vector<int>> table_;",
            "",
            "  void build() {",
            "    n_ = str_.size();",
            "    table_.resize(26, std::vector<int>(n_));",
            "    for (char c = 'a'; c <= 'z'; ++c) {",
            "      int nxt = n_;",
            "      for (int i = n_ - 1; i >= 0; --i) {",
            "        if (str_[i] == c) nxt = i;",
            "        table_[c - 'a'][i] = nxt;",
            "      }",
            "    }",
            "  }",
            "};"
        ]
    },
    "rolling_hash": {
        "prefix": "rolling_hash",
        "body": [
            "class RollingHash {",
            "  using Hashes = std::pair<int64, int64>;",
            "",
            " public:",
            "  RollingHash(const std::string& str) {",
            "    int n = str.size();",
            "    h0_.reserve(n + 1);",
            "    h1_.reserve(n + 1);",
            "    h0_.emplace_back(1);",
            "    h1_.emplace_back(1);",
            "    for (int i = 0; i < n; ++i) {",
            "      h0_.emplace_back((h0_.back() * base0_ + str[i]) % mod0_);",
            "      h1_.emplace_back((h1_.back() * base1_ + str[i]) % mod1_);",
            "    }",
            "    while (int(pow0_.size()) < n + 1) {",
            "      pow0_.emplace_back(pow0_.back() * base0_ % mod0_);",
            "      pow1_.emplace_back(pow1_.back() * base1_ % mod1_);",
            "    }",
            "  }",
            "",
            "  // get hash value of str[l, r)",
            "  Hashes get(int l, int r) const {",
            "    int64 hash0 = (h0_[r] - h0_[l] * pow0_[r - l]) % mod0_;",
            "    int64 hash1 = (h1_[r] - h1_[l] * pow1_[r - l]) % mod1_;",
            "    if (hash0 < 0) hash0 += mod0_;",
            "    if (hash1 < 0) hash1 += mod1_;",
            "    return {hash0, hash1};",
            "  }",
            "",
            "  static std::vector<int64> select_random_base() {",
            "    std::vector<int64> bases;",
            "    const std::vector<int64> primitive_roots = {",
            "    100001, 100002, 100006, 100007, 100008, 100010, 100015, 100016, 100023,",
            "    100028, 100032, 100033, 100036, 100037, 100038, 100045, 100051, 100053,",
            "    100058, 100063, 100064, 100065, 100066, 100069, 100074, 100076, 100077,",
            "    100078, 100079, 100082, 100093, 100095, 100097, 100101, 100110, 100111,",
            "    100120, 100121, 100122, 100126, 100128, 100133, 100136, 100139, 100140,",
            "    100147, 100148, 100149, 100150, 100152, 100158, 100162, 100165, 100166,",
            "    100177, 100183, 100190, 100191, 100192, 100196, 100199, 100203, 100206,",
            "    100211, 100217, 100218, 100220, 100221, 100224, 100229, 100230, 100232,",
            "    100235, 100239, 100241, 100244, 100247, 100249, 100250, 100252, 100253,",
            "    100260, 100266, 100267, 100270, 100271, 100280, 100284, 100287, 100292,",
            "    100294, 100308, 100310, 100312, 100321, 100324, 100326, 100329, 100339,",
            "    100340};  // primitive root of both 2000000011 and 2000000033",
            "    std::mt19937_64 rng(std::chrono::steady_clock::now().time_since_epoch().count());",
            "    std::sample(primitive_roots.begin(), primitive_roots.end(), std::back_inserter(bases), 2, rng);",
            "    return bases;",
            "  }",
            "",
            " private:",
            "  static constexpr int64 mod0_ = 2000000011;  // prime number",
            "  static constexpr int64 mod1_ = 2000000033;  // prime number",
            "  static int64 base0_;",
            "  static int64 base1_;",
            "  std::vector<int64> h0_;",
            "  std::vector<int64> h1_;",
            "  static std::vector<int64> pow0_;",
            "  static std::vector<int64> pow1_;",
            "};",
            "",
            "std::vector<int64> random_bases = RollingHash::select_random_base();",
            "int64 RollingHash::base0_ = random_bases[0];",
            "int64 RollingHash::base1_ = random_bases[1];",
            "std::vector<int64> RollingHash::pow0_{1};",
            "std::vector<int64> RollingHash::pow1_{1};"
        ]
    },
    "z_algorithm": {
        "prefix": "z_algorithm",
        "body": [
            "std::vector<int> Zalgorithm(const std::string str) {",
            "  int n = str.size();",
            "  std::vector<int> res(n);",
            "  res[0] = n;",
            "  int i = 1, j = 0;",
            "  while (i < n) {",
            "    while (i + j < n && str[j] == str[i + j]) ++j;",
            "    res[i] = j;",
            "    if (j == 0) {",
            "      ++i;",
            "      continue;",
            "    }",
            "    int k = 1;",
            "    while (i + k < n && k + res[k] < j) res[i + k] = res[k], ++k;",
            "    i += k;",
            "    j -= k;",
            "  }",
            "  return res;",
            "};"
        ]
    }
}