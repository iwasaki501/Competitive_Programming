{
    "cumulative_sum": {
        "prefix": "cumulative_sum",
        "body": [
            "template <class T>",
            "class CumulativeSum {",
            " public:",
            "  CumulativeSum(const std::vector<T>& vec) : vec_(vec) { build(); }",
            "",
            "  // return sum of [l, r]",
            "  T get(int l, int r) { return sum_[r + 1] - sum_[l]; }",
            "",
            "  // return the first k where sum of [0, k] >= value",
            "  // use only when all element in vec >= 0",
            "  int lower_bound(T val) {",
            "    return std::distance(sum_.begin() + 1,",
            "                         std::lower_bound(sum_.begin() + 1, sum_.end(), val));",
            "  }",
            "",
            "  // return the first k where sum of [0, k] > value",
            "  // use only when all element in vec >= 0",
            "  int upper_bound(T val) {",
            "    return std::distance(sum_.begin() + 1,",
            "                         std::upper_bound(sum_.begin() + 1, sum_.end(), val));",
            "  }",
            "",
            " private:",
            "  std::vector<T> vec_;",
            "  std::vector<T> sum_;",
            "",
            "  void build() {",
            "    sum_.resize(vec_.size() + 1);",
            "    sum_[0] = 0;",
            "    std::partial_sum(vec_.begin(), vec_.end(), sum_.begin() + 1);",
            "  }",
            "};",
            "// snippet-end"
        ]
    },
    "cumulative_sum_2d": {
        "prefix": "cumulative_sum_2d",
        "body": [
            "template <class T>",
            "class CumulativeSum2D {",
            " public:",
            "  CumulativeSum2D(const std::vector<vector<T>>& vec)",
            "      : x_((int)vec.size()), y_((int)vec[0].size()), vec_(vec) {",
            "    build();",
            "  }",
            "",
            "  // return sum of [sx, gx] * [sy, gy]",
            "  T get(int sx, int sy, int gx, int gy) {",
            "    assert(sx <= gx && sy <= gy);",
            "    assert(0 <= sx && sx < x_ && 0 <= gx && gx < x_ && 0 <= sy && sy < y_ &&",
            "           0 <= gy && gy < y_);",
            "    return sum_[gx + 1][gy + 1] - sum_[gx + 1][sy] - sum_[sx][gy + 1] +",
            "           sum_[sx][sy];",
            "  }",
            "",
            " private:",
            "  int x_;",
            "  int y_;",
            "  std::vector<vector<T>> vec_;",
            "  std::vector<vector<T>> sum_;",
            "",
            "  void build() {",
            "    sum_.assign(x_ + 1, std::vector<T>(y_ + 1, 0));",
            "    for (int i = 0; i < x_; ++i) {",
            "      std::partial_sum(vec_[i].begin(), vec_[i].end(), sum_[i + 1].begin() + 1);",
            "    }",
            "    for (int i = 0; i < y_; ++i) {",
            "      for (int j = 0; j < x_; ++j) {",
            "        sum_[j + 1][i + 1] += sum_[j][i + 1];",
            "      }",
            "    }",
            "  }",
            "};",
            "// snippet-end",
            "",
            "// verification code",
            "/*",
            "void ABC106_D() {",
            "  int n, m, query;",
            "  cin >> n >> m >> query;",
            "  vector<vector<int>> board(n, vector<int>(n));",
            "  for (int i = 0; i < m; ++i) {",
            "    int l, r;",
            "    cin >> l >> r;",
            "    --l;",
            "    --r;",
            "    ++board[l][r];",
            "  }",
            "",
            "  CumulativeSum2D<int> cs2(board);",
            "",
            "  for (int i = 0; i < query; ++i) {",
            "    int p, q;",
            "    cin >> p >> q;",
            "    --p;",
            "    --q;",
            "    cout << cs2.get(p, p, q, q) << '\\n';",
            "  }",
            "}",
            "",
            "*/"
        ]
    },
    "doubling": {
        "prefix": "doubling",
        "body": [
            "class Doubling {",
            " public:",
            "  Doubling(int n, int64 k) : n_(n), lg_(64 - __builtin_clzll(k)) {",
            "    table.assign(lg_, std::vector<int>(n_, -1));",
            "  }",
            "",
            "  void set(int pos, int val) { table[0][pos] = val; }",
            "",
            "  void build() {",
            "    for (int i = 0; i + 1 < lg_; ++i) {",
            "      for (int j = 0; j < (int)table[i].size(); ++j) {",
            "        table[i + 1][j] = (table[i][j] == -1 ? -1 : table[i][table[i][j]]);",
            "      }",
            "    }",
            "  }",
            "",
            "  int query(int pos, int64 k) {",
            "    for (int i = lg_ - 1; i >= 0; --i) {",
            "      if (k & (1LL << i)) {",
            "        pos = table[i][pos];",
            "      }",
            "    }",
            "    return pos;",
            "  }",
            "",
            " private:",
            "  int n_;",
            "  int lg_;",
            "  std::vector<std::vector<int>> table;",
            "};",
            "// snippet-end"
        ]
    },
    "golden_section_search": {
        "prefix": "golden_section_search",
        "body": [
            "template <class F>",
            "std::pair<double, double> GoldenSectionSearch(double low, double high, F f, bool find_min = true) {",
            "  constexpr double phi = (1 + std::sqrt(5)) / 2;",
            "  double c1 = (phi * low + high) / (1 + phi);",
            "  double c2 = (low + phi * high) / (1 + phi);",
            "  double cache_f1 = f(c1), cache_f2 = f(c2);",
            "",
            "  for (int i = 0; i < 150; ++i) {",
            "    if ((find_min && cache_f1 > cache_f2) ||",
            "        (!find_min && cache_f1 < cache_f2)) {",
            "      low = c1;",
            "      cache_f1 = cache_f2;",
            "      c1 = c2;",
            "      c2 = (low + phi * high) / (1 + phi);",
            "      cache_f2 = f(c2);",
            "    } else {",
            "      high = c2;",
            "      cache_f2 = cache_f1;",
            "      c2 = c1;",
            "      c1 = (phi * low + high) / (1 + phi);",
            "      cache_f1 = f(c1);",
            "    }",
            "  }",
            "",
            "  return {low, cache_f1};",
            "}",
            "// snippet-end",
            "",
            "// verification code",
            "/*",
            "void ARC54_B() {",
            "  double p; cin >> p;",
            "  auto f = [&](double x) { return x + p * (pow(0.5, (x / 1.5))); };",
            "  cout << fixed << setprecision(17) << GoldenSectionSearch(0, p, f).second << '\\n';",
            "}",
            "*/"
        ]
    },
    "run_length_encoding": {
        "prefix": "run_length_encoding",
        "body": [
            "std::vector<std::pair<char, int>> RunLengthEncoding(const std::string& str) {",
            "  std::vector<std::pair<char, int>> ret;",
            "  int sz = str.size();",
            "  int beg = 0;",
            "  while (beg < sz) {",
            "    int ed = beg;",
            "    while (ed + 1 < sz && str[beg] == str[ed + 1]) ++ed;",
            "    int len = ed - beg + 1;",
            "    ret.emplace_back(str[beg], len);",
            "    beg = ed + 1;",
            "  }",
            "  return ret;",
            "};",
            "",
            "template <class T>",
            "std::vector<std::pair<T, int>> RunLengthEncoding(const std::vector<T>& vec) {",
            "  std::vector<std::pair<T, int>> ret;",
            "  int sz = vec.size();",
            "  int beg = 0;",
            "  while (beg < sz) {",
            "    int ed = beg;",
            "    while (ed + 1 < sz && vec[beg] == vec[ed + 1]) ++ed;",
            "    int len = ed - beg + 1;",
            "    ret.emplace_back(vec[beg], len);",
            "    beg = ed + 1;",
            "  }",
            "  return ret;",
            "};",
            "// snippet-end"
        ]
    },
    "disjoint_sparse_table": {
        "prefix": "disjoint_sparse_table",
        "body": [
            "template <class T, class F>",
            "class DisjointSparseTable {",
            " public:",
            "  DisjointSparseTable(const std::vector<T>& data, F f)",
            "      : n_((int)data.size()), f_(f), data_(data) {",
            "    build();",
            "  }",
            "",
            "  // reutrn f_[l, r)",
            "  T get(int l, int r) {",
            "    if (l >= --r) return tab_[0][l];",
            "    int p = lookup_[l ^ r];",
            "    return f_(tab_[p][l], tab_[p][r]);",
            "  }",
            "",
            " private:",
            "  int n_;",
            "  F f_;",
            "  std::vector<T> data_;",
            "  std::vector<std::vector<T>> tab_;",
            "  std::vector<int> lookup_;",
            "",
            "  void build() {",
            "    int sz = 0;",
            "    while ((1 << sz) <= n_) ++sz;",
            "    tab_.assign(sz, std::vector<T>(n_, T{}));",
            "    for (int i = 0; i < n_; ++i) tab_[0][i] = data_[i];",
            "    for (int i = 1; i < sz; ++i) {",
            "      int shift = 1 << i;",
            "      for (int j = 0; j < n_; j += shift << 1) {",
            "        int t = std::min(j + shift, n_);",
            "        tab_[i][t - 1] = data_[t - 1];",
            "        for (int k = t - 2; k >= j; k--)",
            "          tab_[i][k] = f_(data_[k], tab_[i][k + 1]);",
            "        if (n_ <= t) break;",
            "        tab_[i][t] = data_[t];",
            "        int r = std::min(t + shift, n_);",
            "        for (int k = t + 1; k < r; k++)",
            "          tab_[i][k] = f_(tab_[i][k - 1], data_[k]);",
            "      }",
            "    }",
            "    lookup_.resize(1 << sz);",
            "    for (int i = 2; i < (int)lookup_.size(); ++i) {",
            "      lookup_[i] = lookup_[i >> 1] + 1;",
            "    }",
            "  }",
            "};",
            "// snippet-end"
        ]
    },
    "dual_segment_tree": {
        "prefix": "dual_segment_tree",
        "body": [
            "template <class OM, class F>",
            "class DualSegmentTree {",
            " public:",
            "  DualSegmentTree(const std::vector<OM>& data, OM oie, F f)",
            "      : data_(data), oie_(oie), f_(f) {",
            "    build();",
            "  }",
            "",
            "  // modify data_[l, r) -> f_(data_[l], val), ... , f_(data[r - 1], val)",
            "  void modify(int l, int r, OM val) {",
            "    thrust(l + n_);",
            "    thrust(r + n_ - 1);",
            "    for (l += n_, r += n_; l < r; l >>= 1, r >>= 1) {",
            "      if (l & 1) lazy_[l] = f_(lazy_[l], val), ++l;",
            "      if (r & 1) --r, lazy_[r] = f_(lazy_[r], val);",
            "    }",
            "  }",
            "",
            "  OM operator[](int pos) {",
            "    pos += n_;",
            "    thrust(pos);",
            "    return f_(data_[pos - n_], lazy_[pos]);",
            "  }",
            "",
            " private:",
            "  int n_, h_;",
            "  std::vector<OM> data_;",
            "  std::vector<OM> lazy_;",
            "  OM oie_;",
            "  F f_;",
            "",
            "  void build() {",
            "    int sz = data_.size();",
            "    n_ = 1;",
            "    h_ = 0;",
            "    while (n_ < sz) n_ <<= 1, ++h_;",
            "    lazy_.assign(2 * n_, oie_);",
            "  }",
            "",
            "  inline void propagate(int pos) {",
            "    if (lazy_[pos] != oie_) {",
            "      lazy_[2 * pos + 0] = f_(lazy_[2 * pos + 0], lazy_[pos]);",
            "      lazy_[2 * pos + 1] = f_(lazy_[2 * pos + 1], lazy_[pos]);",
            "      lazy_[pos] = oie_;",
            "    }",
            "  }",
            "",
            "  inline void thrust(int pos) {",
            "    for (int i = h_; i > 0; --i) propagate(pos >> i);",
            "  }",
            "};",
            "// snippet-end",
            "",
            "// verification code",
            "/*",
            "void DSL_2_D() {",
            "  int n, q;",
            "  cin >> n >> q;",
            "  constexpr int inf = 2147483647;",
            "  auto f = [](int e, int x) { return x; };",
            "  DualSegmentTree<int, decltype(f)> seg(vector<int>(n, inf), inf, f);",
            "  while (q--) {",
            "    int op;",
            "    cin >> op;",
            "    if (op == 0) {",
            "      int s, t, x;",
            "      cin >> s >> t >> x;",
            "      seg.modify(s, t + 1, x);",
            "    } else {",
            "      int pos;",
            "      cin >> pos;",
            "      cout << seg[pos] << '\\n';",
            "    }",
            "  }",
            "}",
            "*/",
            "",
            "/*",
            "void DSL_2_E() {",
            "  int n, q;",
            "  cin >> n >> q;",
            "  auto f = [](int e, int x) { return e + x; };",
            "  DualSegmentTree<int, decltype(f)> seg(vector<int>(n, 0), 0, f);",
            "  while (q--) {",
            "    int op;",
            "    cin >> op;",
            "    if (op == 0) {",
            "      int s, t, x;",
            "      cin >> s >> t >> x;",
            "      --s;",
            "      --t;",
            "      seg.modify(s, t + 1, x);",
            "    } else {",
            "      int pos;",
            "      cin >> pos;",
            "      --pos;",
            "      cout << seg[pos] << '\\n';",
            "    }",
            "  }",
            "}",
            "*/"
        ]
    },
    "fenwick_tree": {
        "prefix": "fenwick_tree",
        "body": [
            "template <class T>",
            "class FenwickTree {",
            " public:",
            "  FenwickTree(const std::vector<T>& data) : n_(data.size() + 1), data_(data) {",
            "    init();",
            "  }",
            "",
            "  void add(int pos, T val) {",
            "    ++pos;",
            "    while (pos < n_) {",
            "      node_[pos] += val;",
            "      pos += pos & -pos;",
            "    }",
            "  }",
            "",
            "  // return sum of [0, i]",
            "  T get(int pos) {",
            "    ++pos;",
            "    T sum = 0;",
            "    while (pos > 0) {",
            "      sum += node_[pos];",
            "      pos -= pos & -pos;",
            "    }",
            "    return sum;",
            "  }",
            "",
            "/*",
            "  // this code works faster",
            "  // return sum of [l, r)",
            "  T get(int l, int r) {",
            "    T sum = 0;",
            "    while (l < r) {",
            "      sum += node_[r];",
            "      r -= r & -r;",
            "    }",
            "    while (r < l) {",
            "      sum -= node_[l];",
            "      l -= l & -l;",
            "    }",
            "    return sum;",
            "  }",
            "*/",
            "",
            "  // return sum of [l, r]",
            "  T get(int l, int r) { return get(r) - get(l - 1); }",
            "",
            "  // return the first k where sum of [0, k] >= val",
            "  // use only when all element in data >= 0",
            "  int lower_bound(T val) {",
            "    if (val <= 0) return 0;",
            "    int pos = 0;",
            "    int k = 1;",
            "    while (k < n_ - 1) k <<= 1;",
            "    while (k > 0) {",
            "      if (pos + k <= n_ - 1 && node_[pos + k] < val) {",
            "        val -= node_[pos + k];",
            "        pos += k;",
            "      }",
            "      k >>= 1;",
            "    }",
            "    return pos;",
            "  }",
            "",
            " private:",
            "  int n_;",
            "  std::vector<T> data_;",
            "  std::vector<T> node_;",
            "  void init() {",
            "    node_.assign(n_ + 1, 0);",
            "    for (int i = 0; i < n_ - 1; ++i) add(i, data_[i]);",
            "  }",
            "};",
            "// snippet-end",
            "",
            "// verification code",
            "/*",
            "void DSL_2_B() {",
            "  int n, q;",
            "  cin >> n >> q;",
            "  FenwickTree<int> ft(vector<int>(n, 0));",
            "  for (int i = 0; i < q; ++i) {",
            "    int com, x, y;",
            "    cin >> com >> x >> y;",
            "    if (com == 0) {",
            "      ft.add(x - 1, y);",
            "    } else {",
            "      cout << ft.get(x - 1, y - 1) << '\\n';",
            "    }",
            "  }",
            "}",
            "*/"
        ]
    },
    "fenwick_tree_2d": {
        "prefix": "fenwick_tree_2d",
        "body": [
            "template <class T>",
            "class FenwickTree2D {",
            " public:",
            "  FenwickTree2D(const std::vector<std::vector<T>>& vec)",
            "      : x_((int)vec.size()), y_((int)vec[0].size()), vec_(vec) {",
            "    build();",
            "  }",
            "",
            "  // add val to (x, y)",
            "  void add(int x, int y, T val) {",
            "    for (int i = x + 1; i < x_ + 1; i += i & -i) {",
            "      for (int j = y + 1; j < y_ + 1; j += j & -j) {",
            "        node_[i][j] += val;",
            "      }",
            "    }",
            "  }",
            "",
            "  // return sum of [0, x] * [0, y]",
            "  T get(int x, int y) {",
            "    T sum = 0;",
            "    for (int i = x + 1; i > 0; i -= i & -i) {",
            "      for (int j = y + 1; j > 0; j -= j & -j) {",
            "        sum += node_[i][j];",
            "      }",
            "    }",
            "    return sum;",
            "  }",
            "",
            "  // return sum of [sx, gx] * [sy, gy] ",
            "  T get(int sx, int sy, int gx, int gy) {",
            "    return get(gx, gy) - get(sx - 1, gy) - get(gx, sy - 1) +",
            "           get(sx - 1, sy - 1);",
            "  }",
            "",
            " private:",
            "  int x_;",
            "  int y_;",
            "  std::vector<std::vector<T>> vec_;",
            "  std::vector<std::vector<T>> node_;",
            "",
            "  void build() {",
            "    node_.assign(x_ + 1, std::vector<T>(y_ + 1, 0));",
            "    for (int i = 0; i < x_; ++i) {",
            "      for (int j = 0; j < y_; ++j) {",
            "        add(i, j, vec_[i][j]);",
            "      }",
            "    }",
            "  }",
            "};",
            "// snippet-end"
        ]
    },
    "fenwick_tree_raq": {
        "prefix": "fenwick_tree_raq",
        "body": [
            "template <class T>",
            "class FenwickTreeRAQ {",
            " public:",
            "  FenwickTreeRAQ(const std::vector<T>& data)",
            "      : n_(data.size()),",
            "        ft1_(FenwickTree<T>(data)),",
            "        ft2_(FenwickTree<T>(data)) {}",
            "",
            "  // add val range [l, r)",
            "  void add(int l, int r, T val) {",
            "    add(ft1_, l, r, val);",
            "    add(ft2_, l, r, -val * (l - 1));",
            "    add(ft2_, r, n_, val * (r - l));",
            "  }",
            "",
            "  // get sum of [0, i]",
            "  T get(int pos) { return ft1_.get(pos) * pos + ft2_.get(pos); }",
            "",
            "  // get sum of [l, r]",
            "  T get(int l, int r) { return get(r) - get(l - 1); }",
            "",
            " private:",
            "  int n_;",
            "  FenwickTree<T> ft1_;",
            "  FenwickTree<T> ft2_;",
            "  void add(FenwickTree<T>& ft, int l, int r, T val) {",
            "    ft.add(l, val);",
            "    ft.add(r, -val);",
            "  }",
            "};",
            "// snippet-end",
            "",
            "/*",
            "void DSL_2_G() {",
            "  int n, q;",
            "  cin >> n >> q;",
            "  FenwickTreeRAQ<int64> ft(vector<int64>(n, 0));",
            "  while (q--) {",
            "    int com;",
            "    cin >> com;",
            "    if (com == 0) {",
            "      int s, t, x;",
            "      cin >> s >> t >> x;",
            "      ft.add(s - 1, t, x);",
            "    } else {",
            "      int s, t;",
            "      cin >> s >> t;",
            "      cout << ft.get(s - 1, t - 1) << '\\n';",
            "    }",
            "  }",
            "}",
            "*/"
        ]
    },
    "lazy_segment_tree": {
        "prefix": "lazy_segment_tree",
        "body": [
            "template <class M, class OM, class F1, class F2, class F3>",
            "class LazySegmentTree {",
            " public:",
            "  LazySegmentTree(const std::vector<M>& data, M ie, OM oie, F1 f1, F2 f2, F3 f3)",
            "      : ie_(ie), oie_(oie), data_(data), f1_(f1), f2_(f2), f3_(f3) {",
            "    build();",
            "  }",
            "",
            "  // modify data_[l, r) -> f3_(data_[l], val), ... , f3_(data[r - 1], val)",
            "  void modify(int l, int r, OM val) {",
            "    if (l >= r) return;",
            "    thrust(l += n_);",
            "    thrust(r += n_ - 1);",
            "    for (int cl = l, cr = r + 1; cl < cr; cl >>= 1, cr >>= 1) {",
            "      if (cl & 1) lazy_[cl] = f3_(lazy_[cl], val), ++cl;",
            "      if (cr & 1) --cr, lazy_[cr] = f3_(lazy_[cr], val);",
            "    }",
            "    recalc(l);",
            "    recalc(r);",
            "  }",
            "",
            "  // return f1_[l, r)",
            "  M get(int l, int r) {",
            "    if (l >= r) return ie_;",
            "    thrust(l + n_);",
            "    thrust(r + n_ - 1);",
            "    M vl = ie_, vr = ie_;",
            "    for (l += n_, r += n_; l < r; l >>= 1, r >>= 1) {",
            "      if (l & 1) vl = f1_(vl, apply(l++));",
            "      if (r & 1) vr = f1_(apply(--r), vr);",
            "    }",
            "    return f1_(vl, vr);",
            "  }",
            "",
            " private:",
            "  int n_, h_;",
            "  std::vector<M> data_;",
            "  std::vector<M> node_;",
            "  std::vector<OM> lazy_;",
            "  M ie_;",
            "  OM oie_;",
            "  F1 f1_;",
            "  F2 f2_;",
            "  F3 f3_;",
            "",
            "  void build() {",
            "    int sz = data_.size();",
            "    n_ = 1, h_ = 0;",
            "    while (n_ < sz) n_ <<= 1, ++h_;",
            "    node_.assign(2 * n_, ie_);",
            "    lazy_.assign(2 * n_, oie_);",
            "    for (int i = 0; i < sz; ++i) node_[i + n_] = data_[i];",
            "    for (int i = n_ - 1; i > 0; --i) node_[i] = f1_(node_[2 * i], node_[2 * i + 1]);",
            "  }",
            "",
            "  inline void propagate(int pos) {",
            "    if (lazy_[pos] != oie_) {",
            "      lazy_[2 * pos] = f3_(lazy_[2 * pos], lazy_[pos]);",
            "      lazy_[2 * pos + 1] = f3_(lazy_[2 * pos + 1], lazy_[pos]);",
            "      node_[pos] = apply(pos);",
            "      lazy_[pos] = oie_;",
            "    }",
            "  }",
            "",
            "  inline M apply(int pos) {",
            "    if (lazy_[pos] == oie_) {",
            "      return node_[pos];",
            "    } else {",
            "      return f2_(node_[pos], lazy_[pos]);",
            "    }",
            "  }",
            "",
            "  inline void recalc(int pos) {",
            "    while (pos >>= 1) node_[pos] = f1_(apply(2 * pos), apply(2 * pos + 1));",
            "  }",
            "",
            "  inline void thrust(int pos) {",
            "    for (int i = h_; i > 0; --i) propagate(pos >> i);",
            "  }",
            "};",
            "// snippet-end",
            "",
            "// verification code",
            "/*",
            "// RMQ and RUQ",
            "void DSL_2_F() {",
            "  int n, q; cin >> n >> q;",
            "  auto f1 = [](int e1, int e2){ return min(e1, e2); };",
            "  auto f2 = [](int e, int x){ return x; };",
            "  auto f3 = [](int x1, int x2){ return x2; };",
            "  constexpr int inf = 2147483647;",
            "  vector<int> v(n, inf);",
            "  LazySegmentTree<int, int, decltype(f1), decltype(f2), decltype(f3)> seg(v, inf, -1, f1, f2, f3);",
            "  while (q--) {",
            "    int op; cin >> op;",
            "    if (op == 0) {",
            "      int s, t, x; cin >> s >> t >> x;",
            "      seg.modify(s, t + 1, x);",
            "    } else {",
            "      int s, t; cin >> s >> t;",
            "      cout << seg.get(s, t + 1) << '\\n';",
            "    }",
            "  }",
            "}",
            "*/",
            "/*",
            "// RSQ and RAQ",
            "void DSL_2_G() {",
            "  int n, q; cin >> n >> q;",
            "  struct Node {",
            "    int64 val, len;",
            "  };",
            "  auto f1 = [](Node e1, Node e2) { return (Node){e1.val + e2.val, e1.len + e2.len}; };",
            "  auto f2 = [](Node e, int64 x){ return (Node){e.val + e.len * x, e.len}; };",
            "  auto f3 = [](int64 x1, int64 x2){ return x1 + x2; };",
            "  vector<Node> v(n, (Node){0, 1});",
            "  LazySegmentTree<Node, int64, decltype(f1), decltype(f2), decltype(f3)> seg(v, (Node){0, 1}, 0, f1, f2, f3);",
            "  while (q--) {",
            "    int op; cin >> op;",
            "    if (op == 0) {",
            "      int s, t; int64 x; cin >> s >> t >> x;",
            "      seg.modify(s - 1, t, x);",
            "    } else {",
            "      int s, t; cin >> s >> t;",
            "      cout << seg.get(s - 1, t).val << '\\n';",
            "    }",
            "  }",
            "}",
            "*/",
            "/*",
            "// RMQ and RAQ",
            "void DSL_2_H() {",
            "  int n, q; cin >> n >> q;",
            "  auto f1 = [](int e1, int e2){ return min(e1, e2); };",
            "  auto f2 = [](int e, int x){ return e + x; };",
            "  auto f3 = [](int x1, int x2){ return x1 + x2; };",
            "  constexpr int inf = (int)1e9;",
            "  vector<int> v(n, 0);",
            "  LazySegmentTree<int, int, decltype(f1), decltype(f2), decltype(f3)> seg(v, inf, 0, f1, f2, f3);",
            "  while (q--) {",
            "    int op; cin >> op;",
            "    if (op == 0) {",
            "      int s, t, x; cin >> s >> t >> x;",
            "      seg.modify(s, t + 1, x);",
            "    } else {",
            "      int s, t; cin >> s >> t;",
            "      cout << seg.get(s, t + 1) << '\\n';",
            "    }",
            "  }",
            "}",
            "*/",
            "/*",
            "// RSQ and RUQ",
            "void DSL_2_I() {",
            "  int n, q; cin >> n >> q;",
            "  struct Node {",
            "    int64 val, len;",
            "  };",
            "  auto f1 = [](Node e1, Node e2) { return (Node){e1.val + e2.val, e1.len + e2.len}; };",
            "  auto f2 = [](Node e, int64 x){ return (Node){e.len * x, e.len}; };",
            "  auto f3 = [](int64 x1, int64 x2){ return x2; };",
            "  vector<Node> v(n, (Node){0, 1});",
            "  LazySegmentTree<Node, int64, decltype(f1), decltype(f2), decltype(f3)> seg(v, (Node){0, 1}, -(int64)1e18, f1, f2, f3);",
            "  while (q--) {",
            "    int op; cin >> op;",
            "    if (op == 0) {",
            "      int s, t; int64 x; cin >> s >> t >> x;",
            "      seg.modify(s, t + 1, x);",
            "    } else {",
            "      int s, t; cin >> s >> t;",
            "      cout << seg.get(s, t + 1).val << '\\n';",
            "    }",
            "  }",
            "}",
            "*/",
            "/*",
            "void Range_Affine_Range_Sum() {",
            "  int n, q;",
            "  cin >> n >> q;",
            "  vector<int64> a(n);",
            "  for (int64& e : a) cin >> e;",
            "",
            "  struct Node {",
            "    int64 val, len;",
            "",
            "    Node(int64 val_, int64 len_) : val(val_), len(len_) {}",
            "  };",
            "",
            "  struct Op {",
            "    int64 op1, op2;",
            "",
            "    Op(int64 op1_, int64 op2_) : op1(op1_), op2(op2_) {}",
            "",
            "    bool operator==(const Op& rhs) const {",
            "      return rhs.op1 == op1 && rhs.op2 == op2;",
            "    };",
            "",
            "    bool operator!=(const Op& rhs) const {",
            "      return rhs.op1 != op1 || rhs.op2 != op2;",
            "    };",
            "  };",
            "",
            "  constexpr int mod = 998244353;",
            "",
            "  auto f1 = [](Node e1, Node e2) -> Node {",
            "    return (Node){(e1.val + e2.val) % mod, e1.len + e2.len};",
            "  };",
            "  auto f2 = [](Node e, Op x) -> Node {",
            "    return (Node){(e.val * x.op1 + e.len * x.op2) % mod, e.len};",
            "  };",
            "  auto f3 = [](Op x1, Op x2) -> Op {",
            "    return (Op){(x1.op1 * x2.op1) % mod, (x1.op2 * x2.op1 + x2.op2) % mod};",
            "  };",
            "",
            "  vector<Node> v;",
            "  for (int64 e : a) v.emplace_back(e, 1);",
            "  Node ie = {0, 1};",
            "  Op oie = {1, 0};",
            "  LazySegmentTree seg(v, ie, oie, f1, f2, f3);",
            "",
            "  while (q--) {",
            "    int com;",
            "    cin >> com;",
            "    if (com == 0) {",
            "      int l, r, b, c;",
            "      cin >> l >> r >> b >> c;",
            "      seg.modify(l, r, (Op){b, c});",
            "    } else {",
            "      int l, r;",
            "      cin >> l >> r;",
            "      cout << seg.get(l, r).val << '\\n';",
            "    }",
            "  }",
            "}",
            "*/"
        ]
    },
    "segment_tree": {
        "prefix": "segment_tree",
        "body": [
            "template <class M, class F>",
            "class SegmentTree {",
            " public:",
            "  SegmentTree(const std::vector<M>& data, M ie, F f)",
            "      : ie_(ie), data_(data), f_(f) {",
            "    build();",
            "  }",
            "",
            "  void update(int pos, M val) {",
            "    assert(0 <= pos && pos < n_);",
            "    pos += n_;",
            "    node_[pos] = val;",
            "    while (pos > 0) {",
            "      pos >>= 1;",
            "      node_[pos] = f_(node_[2 * pos], node_[2 * pos + 1]);",
            "    }",
            "  }",
            "",
            "  // return f_[l, r)",
            "  // if l >= r, return ie_",
            "  M get(int l, int r) {",
            "    assert(0 <= l && l < n_ && 0 <= r && r < n_ + 1);",
            "    M vl = ie_, vr = ie_;",
            "    for (l += n_, r += n_; l < r; l >>= 1, r >>= 1) {",
            "      if (l & 1) vl = f_(vl, node_[l++]);",
            "      if (r & 1) vr = f_(node_[--r], vr);",
            "    }",
            "    return f_(vl, vr);",
            "  }",
            "",
            "  M operator[](int pos) const {",
            "    assert(0 <= pos && pos < n_);",
            "    return node_[n_ + pos];",
            "  }",
            "",
            "  // return f_[0, sz_)",
            "  M get_all() { return node_[1]; }",
            "",
            "  // return the maximum i that satisfies cond(i) == true, where i >= l",
            "  // if there is no such i, return sz_",
            "  template <class Condition>",
            "  int max_right(int l, Condition cond) {",
            "    assert(0 <= l && l <= sz_);",
            "    assert(cond(ie_));",
            "    if (l == sz_) return sz_;",
            "    l += n_;",
            "    M sm = ie_;",
            "",
            "    do {",
            "      while (~l & 1) l >>= 1;",
            "      if (!cond(f_(sm, node_[l]))) {",
            "        while (l < n_) {",
            "          l <<= 1;",
            "          if (cond(f_(sm, node_[l]))) {",
            "            sm = f_(sm, node_[l]);",
            "            ++l;",
            "          }",
            "        }",
            "        return l - n_;",
            "      }",
            "      sm = f_(sm, node_[l]);",
            "      ++l;",
            "    } while ((l & -l) != l);",
            "",
            "    return sz_;",
            "  }",
            "",
            "  // return the minimum i that satisfies cond(i) == true, where i <= r",
            "  // if there is no such i, return 0",
            "  // NOT VERIFIED!!",
            "  template <class Condition>",
            "  int min_left(int r, Condition cond) {",
            "    assert(0 <= r && r <= sz_);",
            "    assert(cond(ie_));",
            "    if (r == 0) return 0;",
            "    r += n_;",
            "    M sm = ie_;",
            "",
            "    do {",
            "      --r;",
            "      while (r > 1 && (r & 1)) r >>= 1;",
            "      if (!cond(f_(node_[r], sm))) {",
            "        while (r < n_) {",
            "          r = (2 * r + 1);",
            "          if (cond(f_(node_[r], sm))) {",
            "            sm = f_(node_[r], sm);",
            "            --r;",
            "          }",
            "        }",
            "        return r + 1 - n_;",
            "      }",
            "      sm = f_(node_[r], sm);",
            "    } while ((r & -r) != r);",
            "",
            "    return 0;",
            "  }",
            "",
            " private:",
            "  int n_;",
            "  int sz_;",
            "  M ie_;",
            "  std::vector<M> data_;",
            "  std::vector<M> node_;",
            "  F f_;",
            "",
            "  void build() {",
            "    sz_ = data_.size();",
            "    n_ = 1;",
            "    while (n_ < sz_) n_ <<= 1;",
            "    node_.assign(2 * n_, ie_);",
            "    for (int i = 0; i < sz_; ++i) node_[i + n_] = data_[i];",
            "    for (int i = n_ - 1; i > 0; --i) node_[i] = f_(node_[2 * i], node_[2 * i + 1]);",
            "  }",
            "};",
            "// snippet-end",
            "",
            "// verification code",
            "/*",
            "void DSL_2_A() {",
            "  int n, q;",
            "  cin >> n >> q;",
            "  auto f = [](int x, int y) { return min(x, y); };",
            "  constexpr int INF = 2147483647;",
            "  SegmentTree<int, decltype(f)> seg(vector<int>(n, INF), INF, f);",
            "  for (int i = 0; i < q; ++i) {",
            "    int com, x, y;",
            "    cin >> com >> x >> y;",
            "    if (com == 0) {",
            "      seg.update(x, y);",
            "    } else {",
            "      cout << seg.get(x, y + 1) << '\\n';",
            "    }",
            "  }",
            "}",
            "*/",
            "",
            "/*",
            "void DSL_2_B() {",
            "  int n, q;",
            "  cin >> n >> q;",
            "  auto f = [](int x, int y) { return x + y; };",
            "  SegmentTree<int, decltype(f)> seg(vector<int>(n, 0), 0, f);",
            "  for (int i = 0; i < q; ++i) {",
            "    int com, x, y;",
            "    cin >> com >> x >> y;",
            "    if (com == 0) {",
            "      --x;",
            "      seg.update(x, seg[x] + y);",
            "    } else {",
            "      --x;",
            "      --y;",
            "      cout << seg.get(x, y + 1) << '\\n';",
            "    }",
            "  }",
            "}",
            "*/",
            "",
            "/*",
            "void practice2_J() {",
            "  int n, q;",
            "  cin >> n >> q;",
            "  vector<int> a(n);",
            "  for (int& e : a) cin >> e;",
            "",
            "  int ie = -1;",
            "  auto f = [](int x, int y) { return max(x, y); };",
            "  SegmentTree seg(a, ie, f);",
            "",
            "  while (q--) {",
            "    int t;",
            "    cin >> t;",
            "    if (t == 1) {",
            "      int x, v;",
            "      cin >> x >> v;",
            "      --x;",
            "      seg.update(x, v);",
            "    } else if (t == 2) {",
            "      int l, r;",
            "      cin >> l >> r;",
            "      cout << seg.get(l - 1, r) << '\\n';",
            "    } else {",
            "      int x, v;",
            "      cin >> x >> v;",
            "      auto cond = [&](int val) -> bool { return val < v; };",
            "      cout << seg.max_right(x - 1, cond) + 1 << '\\n';",
            "    }",
            "  }",
            "} ",
            "*/"
        ]
    },
    "sparse_table": {
        "prefix": "sparse_table",
        "body": [
            "template <class T, class F>",
            "class SparseTable {",
            "  // F must be idempotent function!",
            " public:",
            "  SparseTable(const std::vector<T>& data, F f)",
            "      : n_((int)data.size()), lg_(32 - __builtin_clz(n_)), f_(f), data_(data) {",
            "    build();",
            "  }",
            "",
            "  // return f_[l, r]",
            "  T get(int l, int r) {",
            "    assert(0 <= l && l <= r && r < n_);",
            "    int lg = 32 - __builtin_clz(r - l + 1) - 1;",
            "    return f_(tab_[lg][l], tab_[lg][r - (1 << lg) + 1]);",
            "  }",
            "",
            " private:",
            "  int n_;",
            "  int lg_;",
            "  F f_;",
            "  std::vector<T> data_;",
            "  std::vector<std::vector<T>> tab_;",
            "",
            "  void build() {",
            "    tab_.resize(lg_);",
            "    tab_[0] = data_;",
            "    for (int j = 1; j < lg_; ++j) {",
            "      tab_[j].resize(n_ - (1 << j) + 1);",
            "      for (int i = 0; i <= n_ - (1 << j); ++i) {",
            "        tab_[j][i] = f_(tab_[j - 1][i], tab_[j - 1][i + (1 << (j - 1))]);",
            "      }",
            "    }",
            "  }",
            "};",
            "// snippet-end",
            "",
            "// verification code",
            "/*",
            "void Static_RMQ() {",
            "  int n, q;",
            "  cin >> n >> q;",
            "  vector<int> a(n);",
            "  for (int& e : a) cin >> e;",
            "  auto f = [](int x, int y) { return min(x, y); };",
            "  SparseTable st(a, f);",
            "  while (q--) {",
            "    int l, r;",
            "    cin >> l >> r;",
            "    cout << st.get(l, r - 1) << '\\n';",
            "  }",
            "}",
            "*/"
        ]
    },
    "unionfind_rank": {
        "prefix": "unionfind_rank",
        "body": [
            "class UnionFind {",
            " public:",
            "  UnionFind(int n) : n_(n) { init(); }",
            "",
            "  int root(int x) {",
            "    assert(0 <= x && x < n_);",
            "    if (par_[x] == -1)",
            "      return x;",
            "    else",
            "      return par_[x] = root(par_[x]);",
            "  }",
            "",
            "  bool same(int x, int y) {",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);",
            "    return root(x) == root(y);",
            "  }",
            "",
            "  void unite(int x, int y) {",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);",
            "    x = root(x);",
            "    y = root(y);",
            "    if (x == y) return;",
            "    if (rank_[x] < rank_[y]) std::swap(x, y);",
            "    if (rank_[x] == rank_[y]) ++rank_[x];",
            "    par_[y] = x;",
            "    return;",
            "  }",
            "",
            " private:",
            "  const int n_;",
            "  std::vector<int> par_;",
            "  std::vector<int> rank_;",
            "",
            "  void init() {",
            "    par_.assign(n_, -1);",
            "    rank_.assign(n_, 0);",
            "  }",
            "};",
            "// snippet-end",
            "",
            "// verification code",
            "/*",
            "void DSL_1_A() {",
            "  int n, q;",
            "  cin >> n >> q;",
            "  UnionFind uf(n);",
            "  for (int i = 0; i < q; ++i) {",
            "    int com, x, y;",
            "    cin >> com >> x >> y;",
            "    if (com == 0) {",
            "      uf.unite(x, y);",
            "    } else {",
            "      cout << uf.same(x, y) << '\\n';",
            "    }",
            "  }",
            "}",
            "*/"
        ]
    },
    "unionfind_size": {
        "prefix": "unionfind_size",
        "body": [
            "class UnionFind {",
            " public:",
            "  UnionFind(int n) : n_(n) { init(); }",
            "",
            "  int root(int x) {",
            "    assert(0 <= x && x < n_);",
            "    if (par_[x] < 0)",
            "      return x;",
            "    else",
            "      return par_[x] = root(par_[x]);",
            "  }",
            "",
            "  bool same(int x, int y) {",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);",
            "    return root(x) == root(y);",
            "  }",
            "",
            "  void unite(int x, int y) {",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);",
            "    x = root(x);",
            "    y = root(y);",
            "    if (x == y) return;",
            "    if (par_[x] > par_[y]) std::swap(x, y);",
            "    par_[x] += par_[y];",
            "    par_[y] = x;",
            "    return;",
            "  }",
            "",
            "  int size(int x) {",
            "    assert(0 <= x && x < n_);",
            "    return -par_[root(x)];",
            "  }",
            "",
            " private:",
            "  const int n_;",
            "  std::vector<int> par_;",
            "",
            "  void init() { par_.assign(n_, -1); }",
            "};",
            "// snippet-end",
            "",
            "// verification code",
            "/*",
            "void ABC120_D() {",
            "  int n, m;",
            "  cin >> n >> m;",
            "  int64 ans = int64{n} * int64{n - 1} / 2;",
            "",
            "  UnionFind uf(n);",
            "",
            "  vector<pair<int, int>> in;",
            "",
            "  for (int i = 0; i < m; ++i) {",
            "    int a, b;",
            "    cin >> a >> b;",
            "    --a;",
            "    --b;",
            "    in.emplace_back(a, b);",
            "  }",
            "",
            "  reverse(in.begin(), in.end());",
            "",
            "  vector<int64> v;",
            "",
            "  v.emplace_back(ans);",
            "",
            "  for (int i = 0; i < m; ++i) {",
            "    if (uf.same(in[i].first, in[i].second)) {",
            "      ;",
            "    } else {",
            "      ans -= uf.size(in[i].first) * uf.size(in[i].second);",
            "      uf.unite(in[i].first, in[i].second);",
            "    }",
            "    v.emplace_back(ans);",
            "  }",
            "",
            "  reverse(v.begin(), v.end());",
            "",
            "  for (int i = 1; i < m + 1; ++i) {",
            "    cout << v[i] << '\\n';",
            "  }",
            "}",
            "*/"
        ]
    },
    "unionfind_weighted": {
        "prefix": "unionfind_weighted",
        "body": [
            "class UnionFind {",
            " public:",
            "  UnionFind(int n, int SUM_UNITY = 0) : n_(n), SUM_UNITY_(SUM_UNITY) {",
            "    init();",
            "  }",
            "",
            "  int root(int x) {",
            "    assert(0 <= x && x < n_);",
            "    if (par_[x] == -1) {",
            "      return x;",
            "    } else {",
            "      int r = root(par_[x]);",
            "      diff_weight_[x] += diff_weight_[par_[x]];",
            "      return par_[x] = r;",
            "    }",
            "  }",
            "",
            "  int weight(int x) {",
            "    assert(0 <= x && x < n_);",
            "    root(x);",
            "    return diff_weight_[x];",
            "  }",
            "",
            "  bool same(int x, int y) {",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);",
            "    return root(x) == root(y);",
            "  }",
            "",
            "  // y is w larger than x",
            "  void unite(int x, int y, int w) {",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);",
            "    w += weight(x);",
            "    w -= weight(y);",
            "    x = root(x);",
            "    y = root(y);",
            "    if (x == y) return;",
            "    if (rank_[x] < rank_[y]) {",
            "      std::swap(x, y);",
            "      w = -w;",
            "    }",
            "    if (rank_[x] == rank_[y]) ++rank_[x];",
            "    par_[y] = x;",
            "    diff_weight_[y] = w;",
            "    return;",
            "  }",
            "",
            "  int diff(int x, int y) {",
            "    assert(0 <= x && x < n_ && 0 <= y && y < n_);",
            "    return weight(y) - weight(x);",
            "  }",
            "",
            " private:",
            "  const int n_;",
            "  const int SUM_UNITY_;",
            "  std::vector<int> par_;",
            "  std::vector<int> rank_;",
            "  std::vector<int> diff_weight_;",
            "",
            "  void init() {",
            "    par_.assign(n_, -1);",
            "    rank_.assign(n_, 0);",
            "    diff_weight_.assign(n_, SUM_UNITY_);",
            "  }",
            "};",
            "// snippet-end",
            "",
            "// verification code",
            "/*",
            "void DSL_1_B() {",
            "  int n, q;",
            "  cin >> n >> q;",
            "  UnionFind uf(n);",
            "  for (int i = 0; i < q; ++i) {",
            "    int com;",
            "    cin >> com;",
            "    if (com == 0) {",
            "      int x, y, z;",
            "      cin >> x >> y >> z;",
            "      uf.unite(x, y, z);",
            "    } else {",
            "      int x, y;",
            "      cin >> x >> y;",
            "      if (!uf.same(x, y)) {",
            "        cout << '?' << '\\n';",
            "      } else {",
            "        cout << uf.diff(x, y) << '\\n';",
            "      }",
            "    }",
            "  }",
            "}",
            "*/"
        ]
    },
    "debug": {
        "prefix": "debug",
        "body": [
            "template <class T, class U>",
            "std::ostream& operator<<(std::ostream& os, const std::pair<T, U>& p) {",
            "  return os << '(' << p.first << \", \" << p.second << ')';",
            "}",
            "",
            "template <class Tuple, std::size_t... Is>",
            "void tuple_out(std::ostream& os, const Tuple& tp, std::index_sequence<Is...>) {",
            "  ((os << (Is ? \", \" : \"(\") << std::get<Is>(tp)), ...) << \")\";",
            "}",
            "",
            "template <class... Args>",
            "std::ostream& operator<<(std::ostream& os, const std::tuple<Args...>& tp) {",
            "  tuple_out(os, tp, std::index_sequence_for<Args...>{});",
            "  return os;",
            "}",
            "",
            "template <class T>",
            "std::ostream& operator<<(std::ostream& os, const std::vector<T>& vec) {",
            "  bool f = true;",
            "  for (auto e : vec) os << (f ? \"{\" : \", \") << e, f = false;",
            "  return os << (f ? \"{}\" : \"}\");",
            "}",
            "",
            "template <class T, class Compare>",
            "std::ostream& operator<<(std::ostream& os, const std::set<T, Compare>& st) {",
            "  bool f = true;",
            "  for (auto e : st) os << (f ? \"{\" : \", \") << e, f = false;",
            "  return os << (f ? \"{}\" : \"}\");",
            "}",
            "",
            "template <class T, class U, class Compare>",
            "std::ostream& operator<<(std::ostream& os, const std::map<T, U, Compare>& mp) {",
            "  bool f = true;",
            "  for (auto e : mp) os << (f ? \"{\" : \", \") << e, f = false;",
            "  return os << (f ? \"{}\" : \"}\");",
            "}",
            "",
            "template <class T, class Compare>",
            "std::ostream& operator<<(std::ostream& os, const std::multiset<T, Compare>& st) {",
            "  bool f = true;",
            "  for (auto e : st) os << (f ? \"{\" : \", \") << e, f = false;",
            "  return os << (f ? \"{}\" : \"}\");",
            "}",
            "",
            "template <class T, class U, class Compare>",
            "std::ostream& operator<<(std::ostream& os, const std::multimap<T, U, Compare>& mp) {",
            "  bool f = true;",
            "  for (auto e : mp) os << (f ? \"{\" : \", \") << e, f = false;",
            "  return os << (f ? \"{}\" : \"}\");",
            "}",
            "",
            "#ifdef LOCAL",
            "#define debug(...) std::cerr << \"[\" << #__VA_ARGS__ << \"]: \", debug_out(__VA_ARGS__)",
            "#else",
            "#define debug(...) void(0)",
            "#endif",
            "",
            "void debug_out() { std::cerr << '\\n'; }",
            "",
            "template <class Head, class... Tail>",
            "void debug_out(Head&& head, Tail&&... tail) {",
            "  std::cerr << head;",
            "  if (sizeof...(Tail) != 0) std::cerr << \", \";",
            "  debug_out(std::forward<Tail>(tail)...);",
            "}",
            "// snippet-end"
        ]
    },
    "fastio": {
        "prefix": "fastio",
        "body": [
            "namespace FastIO {",
            "class Scanner {",
            "  char buf[1 << 19];",
            "  char* cur = buf;",
            "",
            " public:",
            "  Scanner() { fread(buf, 1, std::size(buf), stdin); }",
            "",
            "  template <class T>",
            "  inline Scanner& operator>>(T& val) {",
            "    skip();",
            "    scan(val);",
            "    return *this;",
            "  }",
            "",
            " private:",
            "  inline void reload() {",
            "    int res = std::distance(cur, std::end(buf));",
            "    memcpy(buf, cur, res);",
            "    fread(std::next(buf, res), 1, std::size(buf) - res, stdin);",
            "    cur = buf;",
            "  }",
            "",
            "  inline void skip() {",
            "    while (*cur == ' ' || *cur == '\\n') ++cur;",
            "  }",
            "",
            "  inline void scan(int& num) {",
            "    if (std::next(cur, 20) >= std::end(buf)) reload();",
            "    bool neg = (*cur == '-');",
            "    if (neg) ++cur;",
            "    num = 0;",
            "    while (*cur >= '0') num = num * 10 + (*cur & 15), ++cur;",
            "    if (neg) num = -num;",
            "  }",
            "",
            "  inline void scan(int64& num) {",
            "    if (std::next(cur, 20) >= std::end(buf)) reload();",
            "    bool neg = (*cur == '-');",
            "    if (neg) ++cur;",
            "    num = 0;",
            "    while (*cur >= '0') num = num * 10 + (*cur & 15), ++cur;",
            "    if (neg) num = -num;",
            "  }",
            "};",
            "",
            "class Printer {",
            "  static constexpr int n = 10000;",
            "  char buf[1 << 19];",
            "  char table[n * 4];",
            "  char* cur = buf;",
            "",
            " public:",
            "  Printer() { build(); }",
            "",
            "  ~Printer() { flush(); }",
            "",
            "  template <class T>",
            "  inline Printer& operator<<(T val) {",
            "    print(val);",
            "    return *this;",
            "  }",
            "",
            "  template <class T>",
            "  inline void println(T val) {",
            "    print(val);",
            "    print('\\n');",
            "  }",
            "",
            " private:",
            "  void build() {",
            "    constexpr int base = 10;",
            "    for (int i = 0; i < n; ++i) {",
            "      int tmp = i;",
            "      for (int j = 3; j >= 0; --j) {",
            "        table[i * 4 + j] = tmp % base | 48;",
            "        tmp /= base;",
            "      }",
            "    }",
            "  }",
            "",
            "  inline void flush() {",
            "    fwrite(buf, 1, std::distance(buf, cur), stdout);",
            "    cur = buf;",
            "  }",
            "",
            "  inline int get_digit(int n) {",
            "    if (n >= (int)1e5) {",
            "      if (n >= (int)1e8) return 9;",
            "      if (n >= (int)1e7) return 8;",
            "      if (n >= (int)1e6) return 7;",
            "      return 6;",
            "    } else {",
            "      if (n >= (int)1e4) return 5;",
            "      if (n >= (int)1e3) return 4;",
            "      if (n >= (int)1e2) return 3;",
            "      if (n >= (int)1e1) return 2;",
            "      return 1;",
            "    }",
            "  }",
            "",
            "  inline int get_digit(int64 n) {",
            "    if (n >= (int64)1e10) {",
            "      if (n >= (int64)1e14) {",
            "        if (n >= (int64)1e18) return 19;",
            "        if (n >= (int64)1e17) return 18;",
            "        if (n >= (int64)1e16) return 17;",
            "        if (n >= (int64)1e15) return 16;",
            "        return 15;",
            "      } else {",
            "        if (n >= (int64)1e14) return 15;",
            "        if (n >= (int64)1e13) return 14;",
            "        if (n >= (int64)1e12) return 13;",
            "        if (n >= (int64)1e11) return 12;",
            "        return 11;",
            "      }",
            "    } else {",
            "      if (n >= (int64)1e5) {",
            "        if (n >= (int64)1e9) return 10;",
            "        if (n >= (int64)1e8) return 9;",
            "        if (n >= (int64)1e7) return 8;",
            "        if (n >= (int64)1e6) return 7;",
            "        return 6;",
            "      } else {",
            "        if (n >= (int64)1e4) return 5;",
            "        if (n >= (int64)1e3) return 4;",
            "        if (n >= (int64)1e2) return 3;",
            "        if (n >= (int64)1e1) return 2;",
            "        return 1;",
            "      }",
            "    }",
            "  }",
            "",
            "  inline void print(int num) {",
            "    if (std::next(cur, 20) >= std::end(buf)) flush();",
            "    if (num == 0) {",
            "      print('0');",
            "      return;",
            "    }",
            "    if (num < 0) {",
            "      print('-');",
            "      num = -num;",
            "    }",
            "    int len = get_digit(num);",
            "    int digits = len;",
            "    while (num >= n) {",
            "      memcpy(cur + len - 4, table + (num % n) * 4, 4);",
            "      num /= n;",
            "      len -= 4;",
            "    }",
            "    memcpy(cur, table + num * 4 + (4 - len), len);",
            "    cur += digits;",
            "  }",
            "",
            "  inline void print(int64 num) {",
            "    if (std::next(cur, 20) >= std::end(buf)) flush();",
            "    if (num == 0) {",
            "      print('0');",
            "      return;",
            "    }",
            "    if (num < 0) {",
            "      print('-');",
            "      num = -num;",
            "    }",
            "    int len = get_digit(num);",
            "    int digits = len;",
            "    while (num >= n) {",
            "      memcpy(cur + len - 4, table + (num % n) * 4, 4);",
            "      num /= n;",
            "      len -= 4;",
            "    }",
            "    memcpy(cur, table + num * 4 + (4 - len), len);",
            "    cur += digits;",
            "  }",
            "",
            "  inline void print(char c) {",
            "    if (std::next(cur) >= std::end(buf)) flush();",
            "    *cur = c;",
            "    ++cur;",
            "  }",
            "",
            "  inline void print(const std::string& str) {",
            "    if (std::next(cur, str.size()) >= std::end(buf)) flush();",
            "    strcpy(cur, str.data());",
            "    std::advance(cur, str.size());",
            "  }",
            "",
            "  inline void print(const char* str) {",
            "    if (std::next(cur, std::strlen(str)) >= std::end(buf)) flush();",
            "    strcpy(cur, str);",
            "    std::advance(cur, std::strlen(str));",
            "  }",
            "};",
            "}  // namespace FastIO",
            "",
            "FastIO::Scanner in;",
            "FastIO::Printer out;",
            "// snippet-end"
        ]
    },
    "int128": {
        "prefix": "int128",
        "body": [
            "using int128 = __int128_t;",
            "",
            "std::istream& operator>>(std::istream& is, int128& val) {",
            "  std::string str;",
            "  is >> str;",
            "  val = 0;",
            "  bool neg = false;",
            "  int sz = str.size();",
            "  for (int i = 0; i < sz; ++i) {",
            "    if (!i && str[i] == '-') {",
            "      neg = true;",
            "    } else {",
            "      val = val * 10 + (str[i] & 15);",
            "    }",
            "  }",
            "  if (neg) val = -val;",
            "  return is;",
            "}",
            "",
            "std::ostream& operator<<(std::ostream& os, const int128& val) {",
            "  if (!val) return os << '0';",
            "  int128 t = val;",
            "  if (val < 0) {",
            "    os << '-';",
            "    t = -t;",
            "  }",
            "  std::string str = \"\";",
            "  while (t) {",
            "    str += (char)(t % 10 | 48);",
            "    t /= 10;",
            "  }",
            "  std::reverse(str.begin(), str.end());",
            "  return os << str;",
            "}",
            "",
            "int128 to_int128(const std::string& str) {",
            "  int sz = str.size();",
            "  int128 val = 0;",
            "  bool neg = false;",
            "  for (int i = 0; i < sz; ++i) {",
            "    if (!i && str[i] == '-') {",
            "      neg = true;",
            "    } else {",
            "      val = val * 10 + (str[i] & 15);",
            "    }",
            "  }",
            "  if (neg) val = -val;",
            "  return val;",
            "}",
            "",
            "int128 to_int128(const char* str) {",
            "  int128 val = 0;",
            "  bool neg = false;",
            "  for (int i = 0; str[i]; ++i) {",
            "    if (!i && str[i] == '-') {",
            "      neg = true;",
            "    } else {",
            "      val = val * 10 + (str[i] & 15);",
            "    }",
            "  }",
            "  if (neg) val = -val;",
            "  return val;",
            "}",
            "",
            "std::string to_string(const int128& val) {",
            "  std::string str = \"\";",
            "  int128 t = val;",
            "  bool neg = false;",
            "  if (t < 0) {",
            "    neg = true;",
            "    t = -t;",
            "  }",
            "  while (t) {",
            "    str += (char)(t % 10 | 48);",
            "    t /= 10;",
            "  }",
            "  if (neg) str += '-';",
            "  std::reverse(str.begin(), str.end());",
            "  return str;",
            "}",
            "// snippet-end"
        ]
    },
    "kyomukyomuio": {
        "prefix": "kyomukyomuio",
        "body": [
            "#include <charconv>",
            "",
            "namespace kyomukyomuIO {",
            "class Scanner {",
            "  char buf[1 << 19];",
            "  char* cur = buf;",
            "",
            " public:",
            "  Scanner() { fread(buf, 1, std::size(buf), stdin); }",
            "",
            "  template <class T>",
            "  inline Scanner& operator>>(T& val) {",
            "    skip();",
            "    scan(val);",
            "    return *this;",
            "  }",
            "",
            " private:",
            "  inline void reload() {",
            "    int res = std::distance(cur, std::end(buf));",
            "    memcpy(buf, cur, res);",
            "    fread(std::next(buf, res), 1, std::size(buf) - res, stdin);",
            "    cur = buf;",
            "  }",
            "",
            "  inline void skip() {",
            "    while (*cur == ' ' || *cur == '\\n') ++cur;",
            "  }",
            "",
            "  inline void scan(int& num) {",
            "    if (std::next(cur, 20) >= std::end(buf)) reload();",
            "    cur = const_cast<char*>(std::from_chars(cur, std::next(cur, 20), num).ptr);",
            "  }",
            "",
            "  inline void scan(int64& num) {",
            "    if (std::next(cur, 20) >= std::end(buf)) reload();",
            "    cur = const_cast<char*>(std::from_chars(cur, std::next(cur, 20), num).ptr);",
            "  }",
            "};",
            "",
            "class Printer {",
            "  char buf[1 << 19];",
            "  char* cur = buf;",
            "",
            " public:",
            "  Printer() {}",
            "",
            "  ~Printer() { flush(); }",
            "",
            "  template <class T>",
            "  inline Printer& operator<<(T val) {",
            "    print(val);",
            "    return *this;",
            "  }",
            "",
            "  template <class T>",
            "  inline void println(T val) {",
            "    print(val);",
            "    print('\\n');",
            "  }",
            "",
            " private:",
            "  void flush() {",
            "    fwrite(buf, 1, std::distance(buf, cur), stdout);",
            "    cur = buf;",
            "  }",
            "",
            "  inline void print(int num) {",
            "    if (std::next(cur, 20) >= std::end(buf)) flush();",
            "    cur = std::to_chars(cur, std::next(cur, 20), num).ptr;",
            "  }",
            "",
            "  inline void print(int64 num) {",
            "    if (std::next(cur, 20) >= std::end(buf)) flush();",
            "    cur = std::to_chars(cur, std::next(cur, 20), num).ptr;",
            "  }",
            "",
            "  inline void print(char c) {",
            "    if (std::next(cur) >= std::end(buf)) flush();",
            "    *cur = c;",
            "    ++cur;",
            "  }",
            "",
            "  inline void print(const std::string& str) {",
            "    if (std::next(cur, str.size()) >= std::end(buf)) flush();",
            "    strcpy(cur, str.data());",
            "    std::advance(cur, str.size());",
            "  }",
            "",
            "  inline void print(const char* str) {",
            "    if (std::next(cur, std::strlen(str)) >= std::end(buf)) flush();",
            "    strcpy(cur, str);",
            "    std::advance(cur, std::strlen(str));",
            "  }",
            "};",
            "}  // namespace kyomukyomuIO",
            "",
            "kyomukyomuIO::Scanner in;",
            "kyomukyomuIO::Printer out;",
            "// snippet-end"
        ]
    },
    "modint": {
        "prefix": "modint",
        "body": [
            "template <typename T>",
            "class Modular {",
            " public:",
            "  using Type = typename decay<decltype(T::value)>::type;",
            "",
            "  constexpr Modular() : value() {}",
            "  template <typename U>",
            "  Modular(const U& x) {",
            "    value = normalize(x);",
            "  }",
            "",
            "  template <typename U>",
            "  static Type normalize(const U& x) {",
            "    Type v;",
            "    if (-mod() <= x && x < mod()) v = static_cast<Type>(x);",
            "    else v = static_cast<Type>(x % mod());",
            "    if (v < 0) v += mod();",
            "    return v;",
            "  }",
            "",
            "  const Type& operator()() const { return value; }",
            "  template <typename U>",
            "  explicit operator U() const { return static_cast<U>(value); }",
            "  constexpr static Type mod() { return T::value; }",
            "",
            "  Modular& operator+=(const Modular& other) { if ((value += other.value) >= mod()) value -= mod(); return *this; }",
            "  Modular& operator-=(const Modular& other) { if ((value -= other.value) < 0) value += mod(); return *this; }",
            "  template <typename U> Modular& operator+=(const U& other) { return *this += Modular(other); }",
            "  template <typename U> Modular& operator-=(const U& other) { return *this -= Modular(other); }",
            "  Modular& operator++() { return *this += 1; }",
            "  Modular& operator--() { return *this -= 1; }",
            "  Modular operator++(int) { Modular result(*this); *this += 1; return result; }",
            "  Modular operator--(int) { Modular result(*this); *this -= 1; return result; }",
            "  Modular operator-() const { return Modular(-value); }",
            "",
            "  template <typename U = T>",
            "  typename enable_if<is_same<typename Modular<U>::Type, int>::value, Modular>::type& operator*=(const Modular& rhs) {",
            "  #ifdef _WIN32",
            "    uint64_t x = static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value);",
            "    uint32_t xh = static_cast<uint32_t>(x >> 32), xl = static_cast<uint32_t>(x), d, m;",
            "    asm(",
            "      \"divl %4; \\n\\t\"",
            "      : \"=a\" (d), \"=d\" (m)",
            "      : \"d\" (xh), \"a\" (xl), \"r\" (mod())",
            "    );",
            "    value = m;",
            "  #else",
            "    value = normalize(static_cast<int64_t>(value) * static_cast<int64_t>(rhs.value));",
            "  #endif",
            "    return *this;",
            "  }",
            "  template <typename U = T>",
            "  typename enable_if<is_same<typename Modular<U>::Type, int64_t>::value, Modular>::type& operator*=(const Modular& rhs) {",
            "    int64_t q = static_cast<int64_t>(static_cast<long double>(value) * rhs.value / mod());",
            "    value = normalize(value * rhs.value - q * mod());",
            "    return *this;",
            "  }",
            "  template <typename U = T>",
            "  typename enable_if<!is_integral<typename Modular<U>::Type>::value, Modular>::type& operator*=(const Modular& rhs) {",
            "    value = normalize(value * rhs.value);",
            "    return *this;",
            "  }",
            "",
            "  Modular& operator/=(const Modular& other) { return *this *= Modular(inverse(other.value, mod())); }",
            "",
            "  template <typename U>",
            "  friend const Modular<U>& abs(const Modular<U>& v) { return v; }",
            "",
            "  template <typename U>",
            "  friend bool operator==(const Modular<U>& lhs, const Modular<U>& rhs);",
            "",
            "  template <typename U>",
            "  friend bool operator<(const Modular<U>& lhs, const Modular<U>& rhs);",
            "",
            "  template <typename U>",
            "  friend std::istream& operator>>(std::istream& stream, Modular<U>& number);",
            "",
            " private:",
            "  Type value;",
            "};",
            "",
            "template <typename T> bool operator==(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value == rhs.value; }",
            "template <typename T, typename U> bool operator==(const Modular<T>& lhs, U rhs) { return lhs == Modular<T>(rhs); }",
            "template <typename T, typename U> bool operator==(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) == rhs; }",
            "",
            "template <typename T> bool operator!=(const Modular<T>& lhs, const Modular<T>& rhs) { return !(lhs == rhs); }",
            "template <typename T, typename U> bool operator!=(const Modular<T>& lhs, U rhs) { return !(lhs == rhs); }",
            "template <typename T, typename U> bool operator!=(U lhs, const Modular<T>& rhs) { return !(lhs == rhs); }",
            "",
            "template <typename T> bool operator<(const Modular<T>& lhs, const Modular<T>& rhs) { return lhs.value < rhs.value; }",
            "",
            "template <typename T> Modular<T> operator+(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }",
            "template <typename T, typename U> Modular<T> operator+(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) += rhs; }",
            "template <typename T, typename U> Modular<T> operator+(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) += rhs; }",
            "",
            "template <typename T> Modular<T> operator-(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }",
            "template <typename T, typename U> Modular<T> operator-(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) -= rhs; }",
            "template <typename T, typename U> Modular<T> operator-(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) -= rhs; }",
            "",
            "template <typename T> Modular<T> operator*(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }",
            "template <typename T, typename U> Modular<T> operator*(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) *= rhs; }",
            "template <typename T, typename U> Modular<T> operator*(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) *= rhs; }",
            "",
            "template <typename T> Modular<T> operator/(const Modular<T>& lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }",
            "template <typename T, typename U> Modular<T> operator/(const Modular<T>& lhs, U rhs) { return Modular<T>(lhs) /= rhs; }",
            "template <typename T, typename U> Modular<T> operator/(U lhs, const Modular<T>& rhs) { return Modular<T>(lhs) /= rhs; }",
            "",
            "template<typename T, typename U>",
            "Modular<T> power(const Modular<T>& a, const U& b) {",
            "  assert(b >= 0);",
            "  Modular<T> x = a, res = 1;",
            "  U p = b;",
            "  while (p > 0) {",
            "    if (p & 1) res *= x;",
            "    x *= x;",
            "    p >>= 1;",
            "  }",
            "  return res;",
            "}",
            "",
            "template <typename T>",
            "bool IsZero(const Modular<T>& number) {",
            "  return number() == 0;",
            "}",
            " ",
            "template <typename T>",
            "std::ostream& operator<<(std::ostream& stream, const Modular<T>& number) {",
            "  return stream << number();",
            "}",
            "",
            "template <typename T>",
            "std::istream& operator>>(std::istream& stream, Modular<T>& number) {",
            "  typename common_type<typename Modular<T>::Type, int64_t>::type x;",
            "  stream >> x;",
            "  number.value = Modular<T>::normalize(x);",
            "  return stream;",
            "}",
            "",
            "/*",
            "using ModType = int;",
            "",
            "struct VarMod { static ModType value; };",
            "ModType VarMod::value;",
            "ModType& MOD = VarMod::value;",
            "using Mint = Modular<VarMod>;",
            "*/",
            "",
            "constexpr int MOD = (int) 1e9 + 7;",
            "using Mint = Modular<std::integral_constant<std::decay<decltype(MOD)>::type, MOD>>;",
            "// snippet-end"
        ]
    },
    "pbds": {
        "prefix": "pbds",
        "body": [
            "#include <ext/pb_ds/assoc_container.hpp>",
            "#include <ext/pb_ds/tree_policy.hpp>",
            "",
            "struct splitmix64_hash {",
            "  // http://xorshift.di.unimi.it/splitmix64.c",
            "  static uint64_t splitmix64(uint64_t x) {",
            "    x += 0x9e3779b97f4a7c15;",
            "    x = (x ^ (x >> 30)) * 0xbf58476d1ce4e5b9;",
            "    x = (x ^ (x >> 27)) * 0x94d049bb133111eb;",
            "    return x ^ (x >> 31);",
            "  }",
            "",
            "  size_t operator()(uint64_t x) const {",
            "    static const uint64_t FIXED_RANDOM = std::chrono::steady_clock::now().time_since_epoch().count();",
            "    return splitmix64(x + FIXED_RANDOM);",
            "  }",
            "};",
            "",
            "template <class Key, class Value, class Hash = splitmix64_hash>",
            "using hash_map = __gnu_pbds::gp_hash_table<Key, Value, Hash>;",
            "",
            "template <class Key, class Hash = splitmix64_hash>",
            "using hash_set = hash_map<Key, __gnu_pbds::null_type, Hash>;",
            "",
            "template <class T>",
            "using pbds_tree = __gnu_pbds::tree<T, __gnu_pbds::null_type, std::less<T>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update>;",
            "",
            "// find_by_order(k) : returns an iterator to the k-th largest element(0-origin)",
            "// order_of_key(k)  : returns the number of items in a set that are strictly smaller than k",
            "// snippet-end"
        ]
    },
    "template": {
        "prefix": "template",
        "body": [
            "#include <algorithm>",
            "#include <bitset>",
            "#include <cassert>",
            "#include <cctype>",
            "#include <chrono>",
            "#include <complex>",
            "#include <cstring>",
            "#include <iomanip>",
            "#include <iostream>",
            "#include <map>",
            "#include <numeric>",
            "#include <queue>",
            "#include <random>",
            "#include <set>",
            "#include <stack>",
            "#include <tuple>",
            "",
            "using namespace std;",
            "",
            "using int64 = long long;",
            "",
            "#define all($) std::begin($), std::end($)",
            "#define rall($) std::rbegin($), std::rend($)",
            "",
            "int main() {",
            "  std::ios_base::sync_with_stdio(false);",
            "  std::cin.tie(nullptr);",
            "",
            "",
            "  return 0;",
            "}",
            "// snippet-end"
        ]
    },
    "timer": {
        "prefix": "timer",
        "body": [
            "class Timer {",
            " public:",
            "  // (second)",
            "  double get_elapsed_time() {",
            "    return static_cast<double>(get_cycle() - start_) /",
            "           static_cast<double>(clock_frequency_);",
            "  }",
            "",
            "  void start() { start_ = get_cycle(); }",
            "",
            " private:",
            "  int64_t start_;",
            "  static constexpr int64_t clock_frequency_ = 1800000000; // Local",
            "  //static constexpr int64_t clock_frequency_ = 3000000000; // AtCoder",
            "  //static constexpr int64_t clock_frequency_ = 3600000000; // Codeforces",
            "  //static constexpr int64_t clock_frequency_ = 2300000000; // yukicoder",
            "",
            "  int64_t get_cycle() {",
            "    uint32_t low, high;",
            "    __asm__ volatile(\"rdtsc\" : \"=a\"(low), \"=d\"(high));",
            "    return (static_cast<int64_t>(low)) | (static_cast<int64_t>(high) << 32);",
            "  }",
            "};",
            "// snippet-end"
        ]
    },
    "utils": {
        "prefix": "utils",
        "body": [
            "template <class T>",
            "inline int lower_position(const std::vector<T>& vec, T val) {",
            "  return std::distance(vec.begin(),",
            "                       std::lower_bound(vec.begin(), vec.end(), val));",
            "}",
            "",
            "template <class T>",
            "inline int upper_position(const std::vector<T>& vec, T val) {",
            "  return std::distance(vec.begin(),",
            "                       std::upper_bound(vec.begin(), vec.end(), val));",
            "}",
            "",
            "template <class T>",
            "inline std::vector<int> compressed(const std::vector<T>& vec) {",
            "  std::vector<T> t = vec;",
            "  std::sort(t.begin(), t.end());",
            "  int n = vec.size();",
            "  int w = 0;",
            "  for (int i = 0; i < n; ++i) {",
            "    if (!(w > 0 && t[w - 1] == t[i])) {",
            "      std::swap(t[w], t[i]);",
            "      ++w;",
            "    }",
            "  }",
            "  t.resize(w);",
            "  std::vector<int> compressed(n);",
            "  for (int i = 0; i < n; ++i)",
            "    compressed[i] =",
            "        std::distance(t.begin(), std::lower_bound(t.begin(), t.end(), vec[i]));",
            "  return compressed;",
            "}",
            "",
            "template <class T>",
            "inline std::string to_binary(T n) {",
            "  assert(n > 0);",
            "  std::string ret = \"\";",
            "  while (n) ret += (n & 1) ? '1' : '0', n >>= 1;",
            "  std::reverse(ret.begin(), ret.end());",
            "  return ret;",
            "}",
            "",
            "template <class T>",
            "inline void println(T val) {",
            "  std::cout << val << '\\n';",
            "}",
            "",
            "inline void println(double val) {",
            "  std::cout << std::fixed << std::setprecision(17) << val << '\\n';",
            "}",
            "",
            "inline void println(long double val) {",
            "  std::cout << std::fixed << std::setprecision(17) << val << '\\n';",
            "}",
            "",
            "template <class T>",
            "inline void println(const std::vector<T>& vec, const char del = ' ') {",
            "  bool first = true;",
            "  for (T e : vec) {",
            "    if (!first) std::cout << del;",
            "    first = false;",
            "    std::cout << e;",
            "  } ",
            "  std::cout << '\\n';",
            "}",
            "",
            "inline void Yes(bool cond) {",
            "  println(cond ? \"Yes\" : \"No\");",
            "}",
            "",
            "inline void YES(bool cond) {",
            "  println(cond ? \"YES\" : \"NO\");",
            "}",
            "",
            "template <class T>",
            "using binary_heap = std::priority_queue<T, std::vector<T>, std::greater<T>>;",
            "",
            "template <class T>",
            "std::istream& operator>>(std::istream& is, std::vector<T>& vec) {",
            "  for (T& e : vec) is >> e;",
            "  return is;",
            "}",
            "",
            "template <class T, class U>",
            "std::istream& operator>>(std::istream& is, std::pair<T, U>& p) {",
            "  return is >> p.first >> p.second;",
            "}",
            "",
            "template <class Tuple, std::size_t... Is>",
            "void tuple_in(std::istream& is, Tuple& tp, std::index_sequence<Is...>) {",
            "  ((is >> std::get<Is>(tp)), ...);",
            "}",
            "",
            "template <class... Args>",
            "std::istream& operator>>(std::istream& is, std::tuple<Args...>& tp) {",
            "  tuple_in(is, tp, std::index_sequence_for<Args...>{});",
            "  return is;",
            "}",
            "// snippet-end"
        ]
    },
    "xoroshiro": {
        "prefix": "xoroshiro",
        "body": [
            "// This is xoroshiro128+ 1.0",
            "// Reference : http://prng.di.unimi.it/xoroshiro128plus.c",
            "class Xoroshiro {",
            " public:",
            "  Xoroshiro() {",
            "    s[0] = static_cast<uint64_t>(std::chrono::steady_clock::now().time_since_epoch().count());",
            "    s[1] = s[0] ^ 0xffffffffful;",
            "    for (int i = 0; i < (1 << 6); ++i) next();",
            "  }",
            "",
            "  using result_type = uint64_t;",
            "  static constexpr uint64_t min() { return std::numeric_limits<result_type>::min(); }",
            "  static constexpr uint64_t max() { return std::numeric_limits<result_type>::max(); }",
            "",
            "  uint64_t operator()() { return next(); }",
            "",
            " private:",
            "  uint64_t s[2];",
            "",
            "  static inline uint64_t rotl(const uint64_t x, int k) {",
            "    return (x << k) | (x >> (64 - k));",
            "  }",
            "",
            "  uint64_t next() {",
            "    const uint64_t s0 = s[0];",
            "    uint64_t s1 = s[1];",
            "    const uint64_t result = s0 + s1;",
            "    s1 ^= s0;",
            "    s[0] = rotl(s0, 24) ^ s1 ^ (s1 << 16);",
            "    s[1] = rotl(s1, 37);",
            "",
            "    return result;",
            "  }",
            "};",
            "// snippet-end"
        ]
    },
    "bellman_ford": {
        "prefix": "bellman_ford",
        "body": [
            "template <class T>",
            "std::vector<T> bellmanford(const graph<T>& g, int s) {",
            "  assert(0 <= s && s < g.n_);",
            "  constexpr T kInfinity = std::numeric_limits<T>::max();",
            "  std::vector<T> dist(g.n_, kInfinity);",
            "  dist[s] = 0;",
            "  for (int i = 0; i < g.n_; ++i) {",
            "    for (const auto& [from, to, cost] : g.edges_) {",
            "      if (dist[from] == kInfinity) continue;",
            "      if (dist[to] > dist[from] + cost) {",
            "        dist[to] = dist[from] + cost;",
            "      }",
            "    }",
            "  }",
            "  for (const auto& [from, to, cost] : g.edges_) {",
            "    if (dist[from] == kInfinity) continue;",
            "    if (dist[to] > dist[from] + cost) return {};",
            "  }",
            "  return dist;",
            "}",
            "// snippet-end",
            "",
            "// verification code",
            "/*",
            "void GRL_1_B() {",
            "  int n, m, r; cin >> n >> m >> r;",
            "  digraph<int> g(n);",
            "  for (int i = 0; i < m; ++i) {",
            "    int s, t, d; cin >> s >> t >> d;",
            "    g.add(s, t, d);",
            "  }",
            "",
            "  constexpr int kInfinity = numeric_limits<int>::max();",
            "",
            "  vector<int> dist = bellmanford(g, r);",
            "  if (dist.empty()) {",
            "    cout << \"NEGATIVE CYCLE\" << '\\n';",
            "  } else {",
            "    for (int e : dist) {",
            "      if (e == kInfinity) {",
            "        cout << \"INF\" << '\\n';",
            "      } else {",
            "        cout << e << '\\n';",
            "      }",
            "    }",
            "  }",
            "}",
            "*/"
        ]
    },
    "bfs": {
        "prefix": "bfs",
        "body": [
            "template <class T>",
            "std::vector<T> bfs(const graph<T>& g, int s) {",
            "  std::vector<T> dist(g.n_, -1);",
            "  dist[s] = 0;",
            "  std::queue<int> que;",
            "  que.emplace(s);",
            "  while (!que.empty()) {",
            "    int cur = que.front();",
            "    que.pop();",
            "    for (int id : g.data_[cur]) {",
            "      const auto& [from, to, cost] = g.edges_[id];",
            "      int nxt = from ^ to ^ cur;",
            "      if (dist[nxt] != -1) continue;",
            "      dist[nxt] = dist[cur] + cost;",
            "      que.emplace(nxt);",
            "    }",
            "  }",
            "  return dist;",
            "}",
            "// snippet-end"
        ]
    },
    "dijkstra": {
        "prefix": "dijkstra",
        "body": [
            "template <class T>",
            "std::vector<T> dijkstra(const graph<T>& g, int s) {",
            "  assert(0 <= s && s < g.n_);",
            "  std::vector<T> dist(g.n_, std::numeric_limits<T>::max());",
            "  using Pair = std::pair<T, int>;",
            "  std::priority_queue<Pair, std::vector<Pair>, std::greater<Pair>> pq;",
            "  dist[s] = 0;",
            "  pq.emplace(0, s);",
            "  while (!pq.empty()) {",
            "    auto [d, v] = pq.top();",
            "    pq.pop();",
            "    if (dist[v] < d) continue;",
            "    for (int id : g.data_[v]) {",
            "      const auto& [from, to, cost] = g.edges_[id];",
            "      int nxt = from ^ to ^ v;",
            "      if (dist[nxt] > dist[v] + cost) {",
            "        dist[nxt] = dist[v] + cost;",
            "        pq.emplace(dist[nxt], nxt);",
            "      }",
            "    }",
            "  }",
            "  return dist;",
            "}",
            "// snippet-end",
            "",
            "// verification code",
            "/*",
            "void GRL_1_A() {",
            "  int n, m, r; cin >> n >> m >> r;",
            "  digraph<int> g(n);",
            "  for (int i = 0; i < m; ++i) {",
            "    int s, t, d; cin >> s >> t >> d;",
            "    g.add(s, t, d);",
            "  }",
            "",
            "  vector<int> dist = dijkstra(g, r);",
            "  for (int e : dist) {",
            "    if (e == numeric_limits<int>::max()) {",
            "      cout << \"INF\" << '\\n';",
            "    } else {",
            "      cout << e << '\\n';",
            "    }",
            "  }",
            "}",
            "*/"
        ]
    },
    "dinic": {
        "prefix": "dinic",
        "body": [
            "template <class T>",
            "class Dinic {",
            " public:",
            "  Dinic(int node_size) : node_size_(node_size) { init(); }",
            "",
            "  void add(int from, int to, T cost) {",
            "    assert(0 <= from && from < node_size_ && 0 <= to && to < node_size_);",
            "    graph_[from].emplace_back(",
            "        (edge){to, cost, static_cast<int>(graph_[to].size())});",
            "    graph_[to].emplace_back((edge){from, static_cast<T>(0),",
            "                                   static_cast<int>(graph_[from].size()) - 1});",
            "  }",
            "",
            "  T max_flow(int s, int t) {",
            "    T flow = 0;",
            "    for (;;) {",
            "      bfs(s);",
            "      if (level_[t] < 0) return flow;",
            "      std::fill(iter_.begin(), iter_.end(), 0);",
            "      T f;",
            "      while ((f = dfs(s, t,",
            "                      std::numeric_limits<T>::max() / static_cast<T>(2))) >",
            "             0) {",
            "        flow += f;",
            "      }",
            "    }",
            "  }",
            "",
            " private:",
            "  struct edge {",
            "    int to;",
            "    T cap;",
            "    int rev;",
            "  };",
            "  int node_size_;",
            "  std::vector<std::vector<edge>> graph_;",
            "  std::vector<int> level_;",
            "  std::vector<int> iter_;",
            "",
            "  void init() {",
            "    graph_.resize(node_size_);",
            "    level_.assign(node_size_, 0);",
            "    iter_.assign(node_size_, 0);",
            "  }",
            "",
            "  void bfs(int s) {",
            "    std::fill(level_.begin(), level_.end(), -1);",
            "    std::queue<int> que;",
            "    level_[s] = 0;",
            "    que.emplace(s);",
            "    while (!que.empty()) {",
            "      int cur = que.front();",
            "      que.pop();",
            "      for (const edge& next : graph_[cur]) {",
            "        if (next.cap > 0 && level_[next.to] < 0) {",
            "          level_[next.to] = level_[cur] + 1;",
            "          que.emplace(next.to);",
            "        }",
            "      }",
            "    }",
            "  }",
            "",
            "  T dfs(int v, int t, int f) {",
            "    if (v == t) return f;",
            "    for (int& i = iter_[v]; i < (int)graph_[v].size(); ++i) {",
            "      edge& e = graph_[v][i];",
            "      if (e.cap > 0 && level_[v] < level_[e.to]) {",
            "        T d = dfs(e.to, t, min(f, e.cap));",
            "        if (d > 0) {",
            "          e.cap -= d;",
            "          graph_[e.to][e.rev].cap += d;",
            "          return d;",
            "        }",
            "      }",
            "    }",
            "    return 0;",
            "  }",
            "};",
            "// snippet-end",
            "",
            "// verification code",
            "/*",
            "void GRL_6_A() {",
            "  int n, m;",
            "  cin >> n >> m;",
            "  Dinic<int> dinic(n);",
            "  for (int i = 0; i < m; ++i) {",
            "    int u, v, c;",
            "    cin >> u >> v >> c;",
            "    dinic.add(u, v, c);",
            "  }",
            "  cout << dinic.max_flow(0, n - 1) << '\\n';",
            "}",
            "*/",
            "",
            "/*",
            "void ARC092_A() {",
            "  int n;",
            "  cin >> n;",
            "  vector<int> a(n), b(n), c(n), d(n);",
            "  for (int i = 0; i < n; ++i) {",
            "    cin >> a[i] >> b[i];",
            "  }",
            "  for (int i = 0; i < n; ++i) {",
            "    cin >> c[i] >> d[i];",
            "  }",
            "",
            "  Dinic<int> dinic(2 * n + 2);",
            "  int s = 2 * n, t = 2 * n + 1;",
            "",
            "  for (int i = 0; i < n; ++i) {",
            "    dinic.add(s, i, 1);",
            "  }",
            "",
            "  for (int i = 0; i < n; ++i) {",
            "    dinic.add(n + i, t, 1);",
            "  }",
            "",
            "  for (int i = 0; i < n; ++i) {",
            "    for (int j = 0; j < n; ++j) {",
            "      if (a[i] < c[j] && b[i] < d[j]) {",
            "        dinic.add(i, j + n, 1);",
            "      }",
            "    }",
            "  }",
            "",
            "  cout << dinic.max_flow(s, t) << '\\n';",
            "}",
            "*/"
        ]
    },
    "graph": {
        "prefix": "graph",
        "body": [
            "template <class T>",
            "class graph {",
            " public:",
            "  graph(int n) : n_(n) { data_.resize(n_); }",
            "  struct edge {",
            "    int from, to;",
            "    T cost;",
            "",
            "    edge(int from_, int to_, T cost_) : from(from_), to(to_), cost(cost_) {}",
            "  };",
            "  int n_;",
            "  std::vector<std::vector<int>> data_;",
            "  std::vector<edge> edges_;",
            "",
            "  virtual void add(int from, int to, T cost) = 0;",
            "};",
            "",
            "template <class T>",
            "class forest : public graph<T> {",
            " public:",
            "  using graph<T>::n_;",
            "  using graph<T>::data_;",
            "  using graph<T>::edges_;",
            "",
            "  forest(int n) : graph<T>(n) {}",
            "",
            "  void add(int from, int to, T cost = 1) {",
            "    assert(0 <= from && from < n_ && 0 <= to && to < n_);",
            "    int id = edges_.size();",
            "    assert(id < n_ - 1);",
            "    data_[from].emplace_back(id);",
            "    data_[to].emplace_back(id);",
            "    edges_.emplace_back(from, to, cost);",
            "  }",
            "};",
            "",
            "template <class T>",
            "class digraph : public graph<T> {",
            " public:",
            "  using graph<T>::n_;",
            "  using graph<T>::data_;",
            "  using graph<T>::edges_;",
            "",
            "  digraph(int n) : graph<T>(n) {}",
            "",
            "  void add(int from, int to, T cost = 1) {",
            "    assert(0 <= from && from < n_ && 0 <= to && to < n_);",
            "    int id = edges_.size();",
            "    data_[from].emplace_back(id);",
            "    edges_.emplace_back(from, to, cost);",
            "  }",
            "",
            "  digraph<T> reverse() const {",
            "    digraph<T> rev(n_);",
            "    for (const auto& [from, to, cost] : edges_) {",
            "      rev.add(to, from, cost);",
            "    }",
            "    return rev;",
            "  }",
            "};",
            "",
            "template <class T>",
            "class undigraph : public graph<T> {",
            " public:",
            "  using graph<T>::n_;",
            "  using graph<T>::data_;",
            "  using graph<T>::edges_;",
            "",
            "  undigraph(int n) : graph<T>(n) {}",
            "",
            "  void add(int from, int to, T cost = 1) {",
            "    assert(0 <= from && from < n_ && 0 <= to && to < n_);",
            "    int id = edges_.size();",
            "    data_[from].emplace_back(id);",
            "    data_[to].emplace_back(id);",
            "    edges_.emplace_back(from, to, cost);",
            "  }",
            "};",
            "// snippet-end"
        ]
    },
    "grid_to_digraph": {
        "prefix": "grid_to_digraph",
        "body": [
            "digraph<int> grid_to_digraph(const std::vector<std::string>& sv) {",
            "  int h = sv.size(), w = sv[0].size();",
            "  digraph<int> g(h * w);",
            "  constexpr int dx[4] = {1, 0, -1, 0}, dy[4] = {0, 1, 0, -1};",
            "  auto Out = [&](int x, int y) { return (x < 0 || x >= h || y < 0 || y >= w); };",
            "  auto Compress = [&](int x, int y) { return x * w + y; };",
            "  for (int i = 0; i < h; ++i) {",
            "    for (int j = 0; j < w; ++j) {",
            "      for (int k = 0; k < 4; ++k) {",
            "        int nx = i + dx[k], ny = j + dy[k];",
            "        if (Out(nx, ny)) continue;",
            "        if (...) {",
            "          g.add(Compress(i, j), Compress(nx, ny));",
            "        }",
            "      }",
            "    }",
            "  }",
            "  return g;",
            "}",
            "// snippet-end"
        ]
    },
    "lca": {
        "prefix": "lca",
        "body": [
            "template <class T>",
            "class lca_forest : public forest<T> {",
            " public:",
            "  using forest<T>::n_;",
            "  using forest<T>::data_;",
            "  using forest<T>::edges_;",
            "",
            "  lca_forest(int n) : forest<T>(n), lg_(32 - __builtin_clz(n)) { init(); }",
            "",
            "  void build(int r = 0) {",
            "    dfs(r, -1, 0);",
            "    for (int i = 0; i + 1 < lg_; ++i) {",
            "      for (int j = 0; j < n_; ++j) {",
            "        if (par_[i][j] < 0) {",
            "          par_[i + 1][j] = -1;",
            "        } else {",
            "          par_[i + 1][j] = par_[i][par_[i][j]];",
            "        }",
            "      }",
            "    }",
            "  }",
            "",
            "  // use after build()",
            "  int lca(int u, int v) {",
            "    assert(0 <= u && u < n_ && 0 <= v && v < n_);",
            "    if (dep_[u] > dep_[v]) std::swap(u, v);",
            "    for (int i = 0; i < lg_; ++i) {",
            "      if ((dep_[v] - dep_[u]) >> i & 1) {",
            "        v = par_[i][v];",
            "      }",
            "    }",
            "    if (u == v) return u;",
            "    for (int i = lg_ - 1; i >= 0; --i) {",
            "      if (par_[i][u] != par_[i][v]) {",
            "        u = par_[i][u];",
            "        v = par_[i][v];",
            "      }",
            "    }",
            "    return par_[0][u];",
            "  }",
            "",
            "  int dist(int u, int v) {",
            "    assert(0 <= u && u < n_ && 0 <= v && v < n_);",
            "    return dep_[u] + dep_[v] - 2 * dep_[lca(u, v)];",
            "  }",
            "",
            " private:",
            "  int lg_;",
            "  std::vector<std::vector<int>> par_;",
            "  std::vector<int> dep_;",
            "",
            "  void dfs(int cur, int pre, int d) {",
            "    par_[0][cur] = pre;",
            "    dep_[cur] = d;",
            "    for (int id : data_[cur]) {",
            "      const auto& [from, to, cost] = edges_[id];",
            "      int nxt = from ^ to ^ cur;",
            "      if (nxt == pre) continue;",
            "      dfs(nxt, cur, d + 1);",
            "    }",
            "  }",
            "",
            "  void init() {",
            "    dep_.resize(n_);",
            "    par_.assign(lg_, std::vector<int>(n_, -1));",
            "  }",
            "};",
            "// snippet-end",
            "",
            "// verification code",
            "/*",
            "void GRL_5_C() {",
            "  int n;",
            "  cin >> n;",
            "  lca_forest<int> lca(n);",
            "  for (int i = 0; i < n; ++i) {",
            "    int k;",
            "    cin >> k;",
            "    for (int j = 0; j < k; ++j) {",
            "      int c;",
            "      cin >> c;",
            "      lca.add(i, c);",
            "    }",
            "  }",
            "  lca.build();",
            "  int q;",
            "  cin >> q;",
            "  while (q--) {",
            "    int u, v;",
            "    cin >> u >> v;",
            "    cout << lca.lca(u, v) << '\\n';",
            "  }",
            "}",
            "*/",
            "/*",
            "void ABC_14_D() {",
            "  int n; cin >> n;",
            "  lca_forest<int> lca(n);",
            "  for (int i = 0; i < n - 1; ++i) {",
            "    int x, y; cin >> x >> y;",
            "    --x; --y;",
            "    lca.add(x, y);",
            "  }",
            "  lca.build();",
            "  int q; cin >> q;",
            "  while (q--) {",
            "    int a, b; cin >> a >> b;",
            "    --a; --b;",
            "    cout << lca.dist(a, b) + 1 << '\\n';",
            "  }",
            "}",
            "*/"
        ]
    },
    "spfa": {
        "prefix": "spfa",
        "body": [
            "template <class T>",
            "std::vector<T> SPFA(const graph<T>& g, int s) {",
            "  assert(0 <= s && s < g.n_);",
            "  std::vector<T> dist(g.n_, std::numeric_limits<T>::max());",
            "  std::vector<int> pend(g.n_, 0);",
            "  std::vector<int> times(g.n_, 0);",
            "  std::queue<int> que;",
            "  que.emplace(s);",
            "  pend[s] = true;",
            "  ++times[s];",
            "  dist[s] = 0;",
            "  while (!que.empty()) {",
            "    int cur = que.front(); que.pop();",
            "    pend[cur] = false;",
            "    for (int id : g.data_[cur]) {",
            "      const auto& [from, to, cost] = g.edges_[id];",
            "      int nxt = from ^ to ^ cur;",
            "      T ncost = dist[cur] + cost;",
            "      if (ncost >= dist[nxt]) continue;",
            "      dist[nxt] = ncost;",
            "      if (!pend[nxt]) {",
            "        if (++times[nxt] >= g.n_) {",
            "          return {};",
            "        }",
            "        pend[nxt] = true;",
            "        que.emplace(nxt);",
            "      }",
            "    }",
            "  }",
            "  return dist;",
            "}",
            "// snippet-end",
            "",
            "// verification code",
            "/*",
            "void GRL_1_B() {",
            "  int n, m, r; cin >> n >> m >> r;",
            "  digraph<int> g(n);",
            "  for (int i = 0; i < m; ++i) {",
            "    int s, t, d; cin >> s >> t >> d;",
            "    g.add(s, t, d);",
            "  }",
            "  vector<int> dist = SPFA(g, r);",
            "  constexpr int kInfinity = numeric_limits<int>::max();",
            "  if (dist.empty()){",
            "    cout << \"NEGATIVE CYCLE\" << '\\n';",
            "  } else {",
            "    for (int e : dist) {",
            "      if (e == kInfinity) {",
            "        cout << \"INF\" << '\\n';",
            "      } else {",
            "        cout << e << '\\n';",
            "      }",
            "    }",
            "  }",
            "}",
            "*/"
        ]
    },
    "topological_sort": {
        "prefix": "topological_sort",
        "body": [
            "template <class T>",
            "std::vector<int> topological_sort(const digraph<T>& g) {",
            "  std::vector<int> lev(g.n_, 0);",
            "  std::vector<int> res;",
            "  for (auto e : g.edges_) ++lev[e.to];",
            "  std::queue<int> que;",
            "  for (int i = 0; i < g.n_; ++i) {",
            "    if (lev[i] == 0) que.emplace(i);",
            "  }",
            "  while (!que.empty()) {",
            "    int cur = que.front(); que.pop();",
            "    res.emplace_back(cur);",
            "    for (int id : g.data_[cur]) {",
            "      const auto& [from, to, cost] = g.edges_[id];",
            "      int nxt = from ^ to ^ cur;",
            "      if (--lev[nxt] == 0) que.emplace(nxt);",
            "    }",
            "  }",
            "  if (std::all_of(lev.begin(), lev.end(), [](int e){ return e == 0; })) {",
            "    return res;",
            "  } else {",
            "    return {};",
            "  }",
            "}",
            "// snippet-end",
            "",
            "// verification code",
            "/*",
            "void GRL_4_B() {",
            "  int n, m; cin >> n >> m;",
            "  digraph<int> g(n);",
            "  for (int i = 0; i < m; ++i) {",
            "    int s, t; cin >> s >> t;",
            "    g.add(s, t);",
            "  }",
            "  vector<int> ts = topological_sort(g);",
            "  for (int e : ts) cout << e << '\\n';",
            "}",
            "*/"
        ]
    },
    "tree_diameter": {
        "prefix": "tree_diameter",
        "body": [
            "template <class T>",
            "T tree_diameter(const forest<T>& g) {",
            "  std::vector<T> d1 = bfs(g, 0);",
            "  std::vector<T> d2 = bfs(g, std::distance(d1.begin(), std::max_element(d1.begin(), d1.end())));",
            "  return *std::max_element(d2.begin(), d2.end());",
            "}",
            "// snippet-end",
            "",
            "// verification code",
            "/*",
            "void GRL_5_A() {",
            "  int n; cin >> n;",
            "  forest<int> g(n);",
            "  for (int i = 0; i < n - 1; ++i) {",
            "    int s, t, d; cin >> s >> t >> d;",
            "    g.add(s, t, d);",
            "  }",
            "  cout << tree_diameter(g) << '\\n';",
            "}",
            "*/"
        ]
    },
    "binary_gcd": {
        "prefix": "binary_gcd",
        "body": [
            "template <class T>",
            "T binary_gcd(T x, T y) {",
            "  assert(x >= 0 && y >= 0);",
            "  unsigned long long tx = x, ty = y;",
            "  if (!tx || !ty) return tx ^ ty ^ 0;",
            "  int s = __builtin_ctzll(tx | ty);",
            "  tx >>= __builtin_ctzll(tx);",
            "  do {",
            "    ty >>= __builtin_ctzll(ty);",
            "    if (tx > ty) std::swap(tx, ty);",
            "    ty -= tx;",
            "  } while (ty);",
            "  return static_cast<T>(tx << s);",
            "}",
            "// snippet-end"
        ]
    },
    "combination": {
        "prefix": "combination",
        "body": [
            "class Combination {",
            " public:",
            "  static constexpr int mod_ = 1000000007;",
            "  static constexpr int n_ = 2000000 + 5;",
            "",
            "  Combination() { build(); }",
            "",
            "  int64 fact_[n_];",
            "  int64 inv_[n_];",
            "  int64 finv_[n_];",
            "",
            "  // return nCk",
            "  int64 get(int n, int k) const noexcept {",
            "    if (n < k || n < 0 || k < 0) return 0;",
            "    return fact_[n] * (finv_[k] * finv_[n - k] % mod_) % mod_;",
            "  }",
            "",
            " private:",
            "  void build() noexcept {",
            "    fact_[0] = 1;",
            "    fact_[1] = 1;",
            "    finv_[0] = 1;",
            "    finv_[1] = 1;",
            "    inv_[1] = 1;",
            "    for (int i = 2; i < n_; ++i) {",
            "      fact_[i] = fact_[i - 1] * i % mod_;",
            "      inv_[i] = mod_ - inv_[mod_ % i] * (mod_ / i) % mod_;",
            "      finv_[i] = finv_[i - 1] * inv_[i] % mod_;",
            "    }",
            "  }",
            "};",
            "// snippet-end",
            "",
            "// verification code",
            "/*",
            "void ABC_154_F() {",
            "  int64 r1, c1, r2, c2;",
            "  cin >> r1 >> c1 >> r2 >> c2;",
            "",
            "  int64 ans = 0;",
            "",
            "  Combination kyomu;",
            "",
            "  for (int64 i = r1; i <= r2; ++i) {",
            "    ans += (((c2 + 1LL) * kyomu.get(c2 + i + 1LL, i) % kyomu.mod_) * kyomu.inv_[i + 1]) % kyomu.mod_ - ((c1 * kyomu.get(c1 + i, i) % kyomu.mod_) * kyomu.inv_[i + 1] % kyomu.mod_);",
            "    while (ans < 0) ans += kyomu.mod_;",
            "    ans %= kyomu.mod_;",
            "  }",
            "",
            "  cout << ans << endl;",
            "}",
            "*/"
        ]
    },
    "divisor": {
        "prefix": "divisor",
        "body": [
            "template<class T>",
            "std::vector<T> divisor(T n) {",
            "  std::vector<T> res;",
            "  for (T i = 1; i * i <= n; ++i) {",
            "    if (n % i == 0){",
            "      res.emplace_back(i);",
            "      if (i * i != n){",
            "        res.emplace_back(n / i);",
            "      }",
            "    }",
            "  }",
            "  std::sort(res.begin(), res.end());",
            "",
            "  return res;",
            "}",
            "// snippet-end"
        ]
    },
    "extgcd": {
        "prefix": "extgcd",
        "body": [
            "// find x, y such that a * x + b * y = gcd(a, b)",
            "template <class T>",
            "T extgcd(T a, T b, T& x, T& y) {",
            "  T d = a;",
            "  if (b) {",
            "    d = extgcd(b, a % b, y, x);",
            "    y -= (a / b) * x;",
            "  } else {",
            "    x = 1, y = 0;",
            "  }",
            "  return d;",
            "}",
            "// snippet-end",
            "",
            "// verification code",
            "/*",
            "void NTL_1_E() {",
            "  int a, b; cin >> a >> b;",
            "  int x, y;",
            "  extgcd(a, b, x, y);",
            "  cout << x << \" \" << y << '\\n';",
            "}",
            "*/"
        ]
    },
    "factor": {
        "prefix": "factor",
        "body": [
            "template <class T>",
            "inline std::vector<T> connect(const std::vector<T> &a,",
            "                              const std::vector<T> &b) {",
            "  std::vector<T> c(a.size() + b.size());",
            "  std::merge(a.begin(), a.end(), b.begin(), b.end(), c.begin());",
            "  return c;",
            "}",
            "",
            "template <class T>",
            "std::vector<T> factor(T n) {",
            "  if (n <= 1) return {};",
            "  if (is_prime(n)) return {n};",
            "  if (~n & 1) return connect({2}, factor(n >> 1));",
            "  for (T c = 1;; ++c) {",
            "    T x = 2, y = 2, d;",
            "    do {",
            "      x = ((int128)x * x + c) % n;",
            "      y = ((int128)y * y + c) % n;",
            "      y = ((int128)y * y + c) % n;",
            "      d = binary_gcd(x - y, n);",
            "    } while (d == 1);",
            "    if (d < n) return connect(factor(d), factor(n / d));",
            "  }",
            "}",
            "// snippet-end",
            "",
            "// verification code",
            "/*",
            "void factorize() {",
            "  int t; cin >> t;",
            "  while (t--) {",
            "    int64 n; cin >> n;",
            "    auto v = factor(n);",
            "    cout << v.size();",
            "    for (int64 e : v) {",
            "      cout << \" \" << e;",
            "    }",
            "    cout << '\\n';",
            "  }",
            "}",
            "*/"
        ]
    },
    "fast_divisor": {
        "prefix": "fast_divisor",
        "body": [
            "template <class T>",
            "std::vector<T> divisor(T n) {",
            "  std::vector<T> v1 = factor(n);",
            "  auto v2 = RunLengthEncoding(v1);",
            "  std::vector<T> div;",
            "  int sz = v2.size();",
            "  auto dfs = [&](auto&& self, T val, int d) -> void {",
            "    if (d == sz) {",
            "      div.emplace_back(val);",
            "      return;",
            "    }",
            "    T cur = 1;",
            "    auto [pr, cnt] = v2[d];",
            "    for (int i = 0; i < cnt + 1; ++i, cur *= pr) {",
            "      self(self, val * cur, d + 1);",
            "    }",
            "  };",
            "  dfs(dfs, 1, 0);",
            "  std::sort(div.begin(), div.end());",
            "",
            "  return div;",
            "}",
            "// snippet-end"
        ]
    },
    "miller_rabin": {
        "prefix": "miller_rabin",
        "body": [
            "using int128 = __int128_t;",
            "",
            "int128 power(int128 base, int128 e, int128 mod) {",
            "  int128 res = 1;",
            "  base %= mod;",
            "  while (e) {",
            "    if (e & 1) (res *= base) %= mod;",
            "    (base *= base) %= mod;",
            "    e >>= 1;",
            "  }",
            "  return res;",
            "}",
            "",
            "bool is_prime(int64 n) {",
            "  if (n < 2 || ~n & 1) return n == 2;",
            "  int s = __builtin_ctzll(n - 1);",
            "  int64 d = (n - 1) >> s;",
            "  for (int64 base : {2, 325, 9375, 28178, 450775, 9780504, 1795265022}) {",
            "    int128 x = base % n;",
            "    if (!x) continue;",
            "    x = power(x, d, n);",
            "    if (x == 1 || x == n - 1) continue;",
            "    bool ok = false;",
            "    for (int i = 0; i < s - 1; ++i) {",
            "      (x *= x) %= n;",
            "      if (x == n - 1) {",
            "        ok = true; break;",
            "      }",
            "    }",
            "    if (!ok) return false;",
            "  }",
            "  return true;",
            "}",
            "// snippet-end"
        ]
    },
    "mod_pow": {
        "prefix": "mod_pow",
        "body": [
            "template<class T, class U> T mod_pow(T x, U n, T mod) {",
            "  T res = 1;",
            "  while (n > 0) {",
            "    if (n & 1) (res *= x) %= mod;",
            "    (x *= x) %= mod;",
            "    n >>= 1;",
            "  }",
            "  return res;",
            "}",
            "// snippet-end"
        ]
    },
    "osa_k": {
        "prefix": "osa_k",
        "body": [
            "class osa_k {",
            "  static constexpr int n_ = 1000000 + 5;",
            "",
            " public:",
            "  osa_k() { build(); }",
            "",
            "  std::vector<std::pair<int, int>> prime_factor(int n) {",
            "    std::vector<std::pair<int, int>> res;",
            "    while (n != 1) {",
            "      int p = min_factor[n];",
            "      int cnt = 0;",
            "      while (min_factor[n] == p) ++cnt, n /= p;",
            "      res.emplace_back(p, cnt);",
            "    }",
            "    return res;",
            "  }",
            "",
            " private:",
            "  int min_factor[n_ + 1];",
            "",
            "  void build() {",
            "    std::fill(min_factor, min_factor + n_ + 1, 0);",
            "    std::vector<int> pr;",
            "    for (int i = 2; i <= n_; ++i) {",
            "      if (!min_factor[i]) {",
            "        min_factor[i] = i;",
            "        pr.emplace_back(i);",
            "      }",
            "      for (int j = 0; j < (int)pr.size() && pr[j] <= min_factor[i] && i * pr[j] <= n_; ++j) {",
            "        min_factor[i * pr[j]] = pr[j];",
            "      }",
            "    }",
            "  }",
            "};",
            "// snippet-end"
        ]
    },
    "prime_factorization": {
        "prefix": "prime_factorization",
        "body": [
            "template<class T>",
            "std::map<T, int> prime_fact(T n){",
            "  std::map<T, int> result;",
            "  for (T i = 2; i * i <= n; ++i){",
            "    if (n % i != 0) continue;",
            "    int cnt = 0;",
            "    while (n % i == 0){",
            "      n /= i; ++cnt;",
            "    }",
            "    result[i] = cnt;",
            "  }",
            "  if (n != 1) result[n] = 1;",
            "  return result;",
            "}",
            "// snippet-end"
        ]
    },
    "sieve": {
        "prefix": "sieve",
        "body": [
            "std::vector<int> LinearTimeSieve() {",
            "  constexpr int n = 1000000;",
            "  int lp[n + 1];",
            "  std::fill(lp, lp + n + 1, 0);",
            "  std::vector<int> pr;",
            "  for (int i = 2; i <= n; ++i) {",
            "    if (!lp[i]) {",
            "      lp[i] = i;",
            "      pr.emplace_back(i);",
            "    }",
            "    for (int j = 0; j < (int)pr.size() && pr[j] <= lp[i] && i * pr[j] <= n;",
            "         ++j) {",
            "      lp[i * pr[j]] = pr[j];",
            "    }",
            "  }",
            "  return pr;",
            "}",
            "// snippet-end"
        ]
    },
    "totient": {
        "prefix": "totient",
        "body": [
            "template <class T>",
            "T Totient(T n) {",
            "  T res = n;",
            "  for (T i = 2; i * i <= n; ++i) {",
            "    if (n % i != 0) continue;",
            "    (res /= i) *= (i - 1);",
            "    while (n % i == 0) n /= i;",
            "  }",
            "  if (n != 1) (res /= n) *= (n - 1);",
            "  return res;",
            "}",
            "// snippet-end"
        ]
    },
    "lcs": {
        "prefix": "lcs",
        "body": [
            "std::string LCS(const std::string& str1, const std::string& str2) {",
            "  int n1 = str1.size(), n2 = str2.size();",
            "  std::vector<std::vector<int>> dp(n1 + 1, std::vector<int>(n2 + 1, 0));",
            "  for (int i = 0; i < n1; ++i) {",
            "    for (int j = 0; j < n2; ++j) {",
            "      if (str1[i] == str2[j]) {",
            "        dp[i + 1][j + 1] = dp[i][j] + 1;",
            "      } else {",
            "        dp[i + 1][j + 1] = std::max(dp[i + 1][j], dp[i][j + 1]);",
            "      }",
            "    }",
            "  }",
            "  int c1 = n1, c2 = n2;",
            "  std::string ret = \"\";",
            "  while (c1 > 0 && c2 > 0) {",
            "    if (str1[c1 - 1] == str2[c2 - 1]) {",
            "      ret += str1[c1 - 1];",
            "      --c1;",
            "      --c2;",
            "    } else {",
            "      if (dp[c1][c2] == dp[c1][c2 - 1]) {",
            "        --c2;",
            "      } else {",
            "        --c1;",
            "      }",
            "    }",
            "  }",
            "  std::reverse(ret.begin(), ret.end());",
            "  return ret;",
            "}",
            "// snippet-end"
        ]
    },
    "levenshtein_distance": {
        "prefix": "levenshtein_distance",
        "body": [
            "int Levenshtein_distance(const std::string& str1, const std::string& str2) {",
            "  int n1 = str1.size(), n2 = str2.size();",
            "  std::vector<std::vector<int>> dp(n1 + 1, std::vector<int>(n2 + 1, 0));",
            "  for (int i = 0; i <= n1; ++i) dp[i][0] = i;",
            "  for (int i = 0; i <= n2; ++i) dp[0][i] = i;",
            "  for (int i = 0; i < n1; ++i) {",
            "    for (int j = 0; j < n2; ++j) {",
            "      const int cost = (str1[i] != str2[j]);",
            "      dp[i + 1][j + 1] =",
            "          std::min({dp[i + 1][j] + 1, dp[i][j + 1] + 1, dp[i][j] + cost});",
            "    }",
            "  }",
            "  return dp[n1][n2];",
            "}",
            "// snippet-end"
        ]
    },
    "manacher": {
        "prefix": "manacher",
        "body": [
            "std::vector<int> Manacher(const std::string& str) {",
            "  int n = str.size();",
            "  std::vector<int> res(n);",
            "  int i = 0, j = 0;",
            "  while (i < n) {",
            "    while (i - j >= 0 && i + j < n && str[i - j] == str[i + j]) ++j;",
            "    res[i] = j;",
            "    int k = 1;",
            "    while (i - k >= 0 && k + res[i - k] < j) res[i + k] = res[i - k], ++k;",
            "    i += k;",
            "    j -= k;",
            "  }",
            "  return res;",
            "}",
            "// snippet-end",
            "",
            "// verification code",
            "/*",
            "void ukuku09_D() {",
            "  int n, q; cin >> n >> q;",
            "  string s; cin >> s;",
            "",
            "  vector<int> res = Manacher(s);",
            "",
            "  auto f = [](int x, int y) {",
            "    return max(x, y);",
            "  };",
            "",
            "  SegmentTree<int, decltype(f)> seg(res, 0, f);",
            "",
            "  while (q--) {",
            "    int l, r; cin >> l >> r; --l; --r;",
            "    int low = 1, high = (r - l + 2) / 2 + 1;",
            "    while (high - low > 1){",
            "      int mid = (high + low) >> 1;",
            "      if (seg.query(l + mid - 1, r - mid + 2) < mid) {",
            "        high = mid;",
            "      } else {",
            "        low = mid;",
            "      }",
            "    }",
            "",
            "    cout << 2 * low - 1 << '\\n';",
            "  }",
            "}",
            "*/"
        ]
    },
    "nextchar": {
        "prefix": "nextchar",
        "body": [
            "class NextChar {",
            " public:",
            "  NextChar(const std::string& str) : str_(str) { build(); }",
            "",
            "  // returns the first position in str[pos:n_) that c appears",
            "  // if c is not in str[pos:n_), returns n_",
            "  int find(int pos, char c) const {",
            "    assert(0 <= pos && pos < n_);",
            "    return table_[c - 'a'][pos];",
            "  }",
            "",
            "  // returns whether str contains c or not",
            "  bool contain(char c) const { return find(0, c) != n_; }",
            "",
            " private:",
            "  int n_;",
            "  std::string str_;",
            "  std::vector<std::vector<int>> table_;",
            "",
            "  void build() {",
            "    n_ = str_.size();",
            "    table_.resize(26, std::vector<int>(n_));",
            "    for (char c = 'a'; c <= 'z'; ++c) {",
            "      int nxt = n_;",
            "      for (int i = n_ - 1; i >= 0; --i) {",
            "        if (str_[i] == c) nxt = i;",
            "        table_[c - 'a'][i] = nxt;",
            "      }",
            "    }",
            "  }",
            "};",
            "// snippet-end",
            "",
            "// verification code",
            "/*",
            "void ABC138_E() {",
            "  string s, t;",
            "  cin >> s >> t;",
            "",
            "  NextChar nc(s);",
            "  int n = s.size();",
            "",
            "  int64 ans = 0;",
            "  int cur = 0;",
            "",
            "  for (char c : t) {",
            "    if (!nc.contain(c)) {",
            "      cout << -1 << endl;",
            "      return;",
            "    } else {",
            "      if (nc.find(cur, c) == n) {",
            "        ans += (n - cur);",
            "        cur = 0;",
            "        ans += (nc.find(cur, c) - cur + 1);",
            "        cur = (nc.find(cur, c) + 1) % n;",
            "      } else {",
            "        ans += (nc.find(cur, c) - cur + 1);",
            "        cur = (nc.find(cur, c) + 1) % n;",
            "      }",
            "    }",
            "  }",
            "",
            "  cout << ans << endl;",
            "}",
            "*/"
        ]
    },
    "rolling_hash": {
        "prefix": "rolling_hash",
        "body": [
            "using ull = unsigned long long;",
            "",
            "class RollingHash {",
            " public:",
            "  RollingHash(const std::string& str) : str_(str) { build(); }",
            "",
            "  // get hash value of [l, r)",
            "  std::pair<ull, ull> get(int l, int r) {",
            "    ull ret0 = (hash0_[r] - hash0_[l] * pow0_[r - l] % mod0_ + mod0_) % mod0_;",
            "    ull ret1 = (hash1_[r] - hash1_[l] * pow1_[r - l] % mod1_ + mod1_) % mod1_;",
            "    return {ret0, ret1};",
            "  }",
            "",
            " private:",
            "  const std::string str_;",
            "  static ull base0_;",
            "  static ull base1_;",
            "  static constexpr ull mod0_ = 2020202077;",
            "  static constexpr ull mod1_ = 2020202111;",
            "  std::vector<ull> hash0_;",
            "  std::vector<ull> hash1_;",
            "  static std::vector<ull> pow0_;",
            "  static std::vector<ull> pow1_;",
            "  static std::mt19937_64 mt_;",
            "",
            "  void build() {",
            "    int n = str_.size();",
            "    hash0_.assign(n + 1, 0);",
            "    hash1_.assign(n + 1, 0);",
            "    for (int i = 0; i < n; ++i) {",
            "      hash0_[i + 1] = (hash0_[i] * base0_ + str_[i]) % mod0_;",
            "      hash1_[i + 1] = (hash1_[i] * base1_ + str_[i]) % mod1_;",
            "    }",
            "    for (int i = 0; i < n; ++i) {",
            "      pow0_.emplace_back(pow0_.back() * base0_ % mod0_);",
            "      pow1_.emplace_back(pow1_.back() * base1_ % mod1_);",
            "    }",
            "  }",
            "};",
            "",
            "std::mt19937_64 RollingHash::mt_(",
            "    std::chrono::steady_clock::now().time_since_epoch().count());",
            "ull RollingHash::base0_ = std::uniform_int_distribution<ull>(",
            "    2, RollingHash::mod0_ - 1)(RollingHash::mt_);",
            "ull RollingHash::base1_ = std::uniform_int_distribution<ull>(",
            "    2, RollingHash::mod1_ - 1)(RollingHash::mt_);",
            "std::vector<ull> RollingHash::pow0_{1};",
            "std::vector<ull> RollingHash::pow1_{1};",
            "// snippet-end",
            "",
            "// verification code",
            "/*",
            "void ABC141_E() {",
            "  int n;",
            "  cin >> n;",
            "  string s;",
            "  cin >> s;",
            "  RollingHash rh(s);",
            "",
            "  auto ok = [&](int x) -> bool {",
            "    for (int i = 0; i + 2 * x <= n; ++i) {",
            "      for (int j = i + x; j + x <= n; ++j) {",
            "        if (rh.get(i, i + x) == rh.get(j, j + x)) {",
            "          return true;",
            "        }",
            "      }",
            "    }",
            "    return false;",
            "  };",
            "",
            "  int low = 0, high = n / 2 + 1;",
            "",
            "  while (high - low > 1) {",
            "    int mid = (low + high) >> 1;",
            "    if (ok(mid)) {",
            "      low = mid;",
            "    } else {",
            "      high = mid;",
            "    }",
            "  }",
            "",
            "  cout << low << '\\n';",
            "}",
            "*/",
            "/*",
            "void ALDS1_14_B() {",
            "  string t, p;",
            "  cin >> t >> p;",
            "  RollingHash rh0(t);",
            "  RollingHash rh1(p);",
            "",
            "  int n = t.size();",
            "  int m = p.size();",
            "",
            "  for (int i = 0; i + m <= n; ++i) {",
            "    if (rh0.get(i, i + m) == rh1.get(0, m)) {",
            "      cout << i << '\\n';",
            "    }",
            "  }",
            "}",
            "*/"
        ]
    },
    "z_algorithm": {
        "prefix": "z_algorithm",
        "body": [
            "std::vector<int> Zalgorithm(const std::string str) {",
            "  int n = str.size();",
            "  std::vector<int> res(n);",
            "  res[0] = n;",
            "  int i = 1, j = 0;",
            "  while (i < n) {",
            "    while (i + j < n && str[j] == str[i + j]) ++j;",
            "    res[i] = j;",
            "    if (j == 0) {",
            "      ++i;",
            "      continue;",
            "    }",
            "    int k = 1;",
            "    while (i + k < n && k + res[k] < j) res[i + k] = res[k], ++k;",
            "    i += k;",
            "    j -= k;",
            "  }",
            "  return res;",
            "};",
            "// snippet-end",
            "",
            "// verification code",
            "/*",
            "void ABC141_D() {",
            "  int n;",
            "  string s;",
            "  cin >> n >> s;",
            "  int ans = 0;",
            "",
            "  for (int i = 0; i < n; ++i) {",
            "    string t = s.substr(i, n - i);",
            "    vector<int> v = Zalgorithm(t);",
            "",
            "    for (int j = 0; j < n - i; ++j) {",
            "      ans = max(ans, min(j, v[j]));",
            "    }",
            "  }",
            "  cout << ans << endl;",
            "}",
            "*/"
        ]
    }
}